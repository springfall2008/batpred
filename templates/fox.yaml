pred_bat:
  module: predbat
  class: PredBat

  # Sets the prefix for all created entities in HA - only change if you want to run more than once instance
  prefix: predbat

  # Timezone to work in
  timezone: Europe/London

  # Currency, symbol for main currency second symbol for 1/100s e.g. $ c or £ p or e c
  currency_symbols:
    - '£'
    - 'p'

  # Number of threads to use in plan calculation
  # Can be auto for automatic, 0 for off or values 1-N for a fixed number
  threads: auto

  # XXX: This is a configuration template, delete this line once you edit your configuration
  template: True

  # Sets the maximum period of zero load before the gap is filled, default 30 minutes
  # To disable set it to 1440
  load_filter_threshold: 30

  #
  # Sensors, more than one can be specified and they will be summed up automatically
  #
  # For two inverters the load today would normally be the master load sensor only (to cover the entire house)
  # If you have three phase and one inverter per phase then you would need three load sensors
  #
  # For pv_today if you have multiple solar inverter inputs then you should include one entry for each inverter
  #
  load_today:
    - sensor.foxess_load_energy_today
  import_today:
    - sensor.foxess_grid_consumption_energy_today
  export_today:
    - sensor.foxess_feed_in_energy_today
  # Replace pv_today sensor with appropriate sensor name when using a separate solar power monitor for AC-coupled FoxESS
  pv_today:
    - sensor.foxess_solar_energy_today

  # Load forecast can be used to add to the historical load data (heat-pump)
  # To link to Predheat
  # Data must be in the format of 'last_updated' timestamp and 'energy' for incrementing kWh
  #load_forecast:
  #  - predheat.heat_energy$external
  #
  # Controls/status - must by 1 per inverter
  #
  num_inverters: 1
  inverter_type: FoxESS

  # Predbat statuses versus Fox work-modes
  #
  # PREDBAT           FOX
  # Demand (Eco)      Self-Use
  # This is the default, the load will be covered by solar and/or battery. Excess solar will
  # charge the battery or be exported if the battery is full. This is described as 'Eco' Mode
  # for GivEnergy inverters but other inverters use different terminology.
  #
  # Charging          Force Charge
  # The battery charges from the grid and the grid also covers any load. Solar power will
  # also be used to charge the battery.
  #
  # Freeze charging   Back-up (with reserve soc set to number.min_soc_on_grid)
  # The battery is charging but the current battery level (SoC) is frozen (held). Think of
  # it as a charge to the current battery level. The grid or solar covers any house load. 
  # If there is a shortfall of Solar power to meet house load, the excess house load is met
  # from grid import, but if there is excess Solar power above the house load, the excess 
  # solar will be used to charge the battery,
  #
  # Hold charging     Back-up (with reserve soc set to number.min_soc_on_grid)
  # A type of charge where the target SoC % is the same as the current SoC %, effectively the
  # same as a charge freeze (but without being explicitly selected).
  #
  # No Charge         Self use
  # A charge where the target SoC % is lower than the current battery SoC level so there will
  # be no charging unless the usage is unexpectedly high.
  #
  # Exporting         Force Discharge 
  # The battery is being force-discharged. The house load will be covered by the battery and
  # any excess is exported to the grid. Any solar generated will be exported.
  #
  # Freeze exporting  Feed-in First 
  # The battery is in demand mode, but with charging disabled. The battery or solar covers the
  # house load. As charging is disabled, if there is excess solar generated, the current SoC
  # level will be held and the excess solar will be exported. If there is a shortfall of
  # generated solar power to meet the house load, the battery will discharge to meet the extra
  # load.
  #
  # Hold exporting    Self use
  # The plan was to force export but the minimum battery level was reached and thus the battery
  # is kept in Demand mode. If the battery level again gets above the threshold it will be changed
  # back to Export mode.
  #
  # Calibration       Needs an automation
  # Fox inverters do not automatically calibrate, so to do this an automation is needed if required.
  # At least once every 7 days the battery should hit the 100% SoC mark.  This can be done by setting
  # the predbat min_keep, etc as needed if too much time has passed. 
  #
  # Error
  # If there is a configuration error or other problem, you should check the Predbat log file for more
  # details.

  # Services to control charging/discharging
  # charge_start_service - Should be set to a service that is called when charging starts
  charge_start_service:
    service: select.select_option
    entity_id: select.foxess_work_mode
    option: "Force Charge"

  # charge_freeze_service - If your inverter supports charge freeze set to a service that starts this mode
  # The Back-up work mode does not exist on older firmware versions
  charge_freeze_service:
    service: select.select_option
    entity_id: select.foxess_work_mode
    option: "Back-up"

 # charge_stop_service - Should be set to a service that is called when charging/charge freeze stops
  charge_stop_service:
    service: select.select_option
    entity_id: select.foxess_work_mode
    option: "Self Use"

  # discharge_start_service - Should be set to a service that is called when force export (discharge) starts
  discharge_start_service:
    service: select.select_option
    entity_id: select.foxess_work_mode
    option: "Force Discharge"

  # discharge_stop_service - Should be set to a service that is called when export/export freeze stops
  discharge_stop_service:
    service: select.select_option
    entity_id: select.foxess_work_mode
    option: "Self Use"
#    option: "Feed-in First"
# Should be   option: "Self Use" but I like FiF better ###

  # discharge_freeze_service - If your inverter supports export freeze set to a service that starts this mode
  discharge_freeze_service:
    service: select.select_option
    entity_id: select.foxess_work_mode
    option: "Feed-in First"

  #
  # Run balance inverters every N seconds (0=disabled) - only for multi-inverter
  #balance_inverters_seconds: 60
  #

  # charge_rate and discharge_rate come from the https://github.com/nathanmarlor/foxess_modbus/ integration, they are in kW but works without problems.
  charge_rate:
    - number.foxess_force_charge_power
  discharge_rate:
    - number.foxess_force_discharge_power
  battery_power:
    - sensor.foxess_invbatpower
  # Replace pv_power sensor with appropriate sensor name when using a separate solar power monitor for AC-coupled FoxESS
  pv_power:
    - sensor.foxess_pv_power
  load_power:
    - sensor.foxess_load_power
  grid_power:
    - sensor.foxess_grid_power
  grid_power_invert:
    - True
  soc_percent:
    - sensor.foxess_battery_soc
  soc_max:
    - sensor.foxess_bms_kwh_remaining
  # Derived from a template sensor (kWh, Stored Energy, Measurement to get statistics for the battery curve) off
  soc_kw:
    - sensor.foxess_soc_kwh_remaining
  reserve:
    - number.foxess_min_soc_on_grid
  # battery_min_soc is set manually via a number helper
  battery_min_soc:
    - input_number.battery_min_soc
  battery_temperature:
    - sensor.foxess_battery_temp

  # Inverter max AC limit (one per inverter). E.g for a 3.6kw inverter set to 3600
  # If you have a second inverter for PV only please add the two values together
  inverter_limit:
    - 5000

  # Set the maximum charge/discharge rate of the battery
  battery_rate_max:
    - 14112

  # Export limit is a software limit set on your inverter that prevents exporting above a given level
  # When enabled Predbat will model this limit
  #export_limit:
  # - 3600
  # - 3600

  # Some inverters don't turn off when the rate is set to 0, still charge or discharge at around 200w
  # The value can be set here in watts to model this (doesn't change operation)
  #inverter_battery_rate_min:
  #  - 200

  inverter_limit_charge:
   - 5000

  inverter_limit_discharge:
   - 5000

  # Workaround to limit the maximum reserve setting, some inverters won't allow 100% to be set
  # Comment out if your inverter allows 100%
  #inverter_reserve_max : 98

  # Some batteries tail off their charge rate at high soc%
  # enter the charging curve here as a % of the max charge rate for each soc percentage or set to 'auto' for predbat to determine the curves.
  # the default is 1.0 (full power)
  #battery_charge_power_curve:
  #  100 : 0.15
  #  99 : 0.15
  #  98 : 0.22
  #  97 : 0.31
  #  96 : 0.42
  #  95 : 0.48
  #  94 : 0.58
  #  93 : 0.68
  #  92 : 0.77
  #  91 : 0.85
  #  90 : 0.94
  #battery_discharge_power_curve:
  #  4: 1.0

  # Inverter clock skew in minutes, e.g. 1 means it's 1 minute fast and -1 is 1 minute slow
  # Separate start and end options are applied to the start and end time windows, mostly as you want to start late (not early) and finish early (not late)
  # Separate discharge skew for discharge windows only
  inverter_clock_skew_start: 0
  inverter_clock_skew_end: 0
  inverter_clock_skew_discharge_start: 0
  inverter_clock_skew_discharge_end: 0

  # Clock skew adjusts the Appdaemon time
  # This is the time that Predbat takes actions like starting discharge/charging
  # Only use this for workarounds if your inverter time is correct but Predbat is somehow wrong (AppDaemon issue)
  # 1 means add 1 minute to AppDaemon time, -1 takes it away
  clock_skew: 0

  # Set these to match solcast sensor names
  # The regular expression (re:) makes the solcast bit optional
  # If these don't match find your own names in Home Assistant
  pv_forecast_today: sensor.solcast_pv_forecast_forecast_today
  pv_forecast_tomorrow: sensor.solcast_pv_forecast_forecast_tomorrow
  pv_forecast_d3: sensor.solcast_pv_forecast_forecast_day_3
  pv_forecast_d4: sensor.solcast_pv_forecast_forecast_day_4

  # car_charging_energy defines an incrementing sensor which measures the charge added to your car
  # is used for car_charging_hold feature to filter out car charging from the previous load data
  # Automatically set to detect Wallbox and Zappi, if it doesn't match manually enter your sensor name
  # Also adjust car_charging_energy_scale if it's not in kwH to fix the units
  car_charging_energy: 're:(sensor.myenergi_zappi_[0-9a-z]+_charge_added_session|sensor.wallbox_portal_added_energy)'

  # Defines the number of cars modelled by the system, set to 0 for no car
  num_cars: 0

  # If you have Octopus Intelligent Go and are not using the Octopus Direct connection method, enable the intelligent slot information to add to pricing
  # Will automatically disable if not found, or comment out to disable fully
  # When enabled it overrides the 'car_charging_planned' feature and predict the car charging based on the intelligent plan (unless Octopus intelligent charging is False)
  # This matches the intelligent slot from the Octopus Energy integration
  octopus_intelligent_slot: 're:(binary_sensor.octopus_energy([0-9a-z_]+|)_intelligent_dispatching)'
  octopus_ready_time: 're:((select|time).octopus_energy_([0-9a-z_]+|)_intelligent_target_time)'
  octopus_charge_limit: 're:(number.octopus_energy([0-9a-z_]+|)_intelligent_charge_target)'

  # Example alternative configuration for Ohme integration release >=v0.6.1
  # octopus_intelligent_slot: 'binary_sensor.ohme_slot_active'
  # octopus_ready_time: 'time.ohme_target_time'
  # octopus_charge_limit: 'number.ohme_target_percent'

  # Octopus saving session points to the saving session Sensor in the Octopus plugin, when enabled saving sessions will be at the assumed
  # Rate is read automatically from the add-in and converted to pence using the conversion rate below (default is 8)
  octopus_saving_session: 're:(binary_sensor.octopus_energy([0-9a-z_]+|)_saving_session(s|))'
  octopus_saving_session_octopoints_per_penny: 8

  # Octopus free session points to the free session Sensor in the Octopus plugin
  # Note: You must enable this event sensor in the Octopus Integration in Home Assistant for it to work
  octopus_free_session: 're:(event.octopus_energy_([0-9a-z_]+|)_octoplus_free_electricity_session_events)'

  # Energy rates
  # Please set one of these three, if multiple are set then Octopus is used first, second rates_import/rates_export and latest basic metric

  # Set import and export entity to point to the Octopus Energy plugin import and export sensors
  # automatically matches your meter number assuming you have only one (no need to edit the below)
  # Will be ignored if you don't have the sensor but will error if you do have one and it's incorrect
  # NOTE: To get detailed energy rates you need to go in and manually enable the following events in HA
  #       event.octopus_energy_electricity_xxxxxxxx_previous_day_rates
  #       event.octopus_energy_electricity_xxxxxxxx_current_day_rates
  #       event.octopus_energy_electricity_xxxxxxxx_next_day_rates
  # and if you have export enable:
  #       event.octopus_energy_electricity_xxxxxxxx_export_previous_day_rates
  #       event.octopus_energy_electricity_xxxxxxxx_export_current_day_rates
  #       event.octopus_energy_electricity_xxxxxxxx_export_next_day_rates
  # Predbat will automatically find the event. entities from the link below to the sensors
  metric_octopus_import: 're:(sensor.(octopus_energy_|)electricity_[0-9a-z]+_[0-9a-z]+_current_rate)'
  metric_octopus_export: 're:(sensor.(octopus_energy_|)electricity_[0-9a-z]+_[0-9a-z]+_export_current_rate)'

  # Standing charge in pounds, can be set to a sensor or manually entered (e.g. 0.50 is 50p)
  # The default below will pick up the standing charge from the Octopus Plugin
  # The standing charge only impacts the cost graphs and doesn't change the way Predbat plans
  # If you don't want to show the standing charge then just delete this line or set to zero
  metric_standing_charge: 're:(sensor.(octopus_energy_|)electricity_[0-9a-z]+_[0-9a-z]+_current_standing_charge)'

  # Or set your actual rates across time for import and export
  # If start/end is missing it's assumed to be a fixed rate
  # Gaps are filled with zero rate
  #rates_import:
  #  -  start: "00:30:00"
  #     end: "04:30:00"
  #     rate: 7.5
  #  -  start: "04:30:00"
  #     end: "00:30:00"
  #     rate: 40.0
  #
  #rates_export:
  #  -  rate: 4.2

  # Can be used instead of the plugin to get import rates directly online
  # Overrides metric_octopus_import and rates_import
  # See the 'energy rates' part of the documentation for instructions on how to find the correct URL for your tariff and DNO region
  #
  # rates_import_octopus_url : "https://api.octopus.energy/v1/products/FLUX-IMPORT-23-02-14/electricity-tariffs/E-1R-FLUX-IMPORT-23-02-14-A/standard-unit-rates"
  # rates_import_octopus_url : "https://api.octopus.energy/v1/products/AGILE-24-10-01/electricity-tariffs/E-1R-AGILE-24-10-01-A/standard-unit-rates"

  # Overrides metric_octopus_export and rates_export
  # rates_export_octopus_url: "https://api.octopus.energy/v1/products/FLUX-EXPORT-23-02-14/electricity-tariffs/E-1R-FLUX-EXPORT-23-02-14-A/standard-unit-rates"
  # rates_export_octopus_url: "https://api.octopus.energy/v1/products/AGILE-OUTGOING-19-05-13/electricity-tariffs/E-1R-AGILE-OUTGOING-19-05-13-A/standard-unit-rates/"

  # Import rates can be overridden with rate_import_override
  # Export rates can be overridden with rate_export_override
  # Use the same format as above, but a date can be included if it just applies for a set day (e.g. Octopus power ups)
  # This will override even the Octopus plugin rates if enabled
  #
  #rates_import_override:
  # -  date: '2023-09-10'
  #    start: '14:00:00'
  #    end: '14:30:00'
  #    rate: 112
  #    load_scaling: 0.8

  # For pv estimate, leave blank for central estimate, or add 10 for 10% curve (worst case) or 90 or 90% curve (best case)
  # If you use 10 then disable pv_metric10_weight below
  # pv_estimate: 10

  # Days previous is the number of days back to find historical load data
  # Recommended is 7 to capture day of the week but 1 can also be used
  # if you have more history you could use 7 and 14 (in a list) but the standard data in HA only lasts 10 days
  days_previous:
    - 7

  # Days previous weight can be used to control the weighting of the previous load points, the values are multiplied by their
  # weights and then divided through by the total weight. E.g. if you used 1 and 0.5 then the first value would have 2/3rd of the weight and the second 1/3rd
  # Include one value for each days_previous value, each weighting on a separate line.
  # If any days_previous's that are not given a weighting they will assume a default weighting of 1.
  days_previous_weight:
    - 1

  # Number of hours forward to forecast, best left as-is unless you have specific reason
  forecast_hours: 48

  # Specify the devices that notifies are sent to, the default is 'notify' which goes to all
  #notify_devices:
  #  - mobile_app_treforsiphone12_2

  # Battery scaling makes the battery smaller (e.g. 0.9) or bigger than its reported
  # If you have an 80% DoD battery that falsely reports it's kwh then set it to 0.8 to report the real figures
  # One per inverter
  battery_scaling:
    - 1.0

  # Can be used to scale import and export data, used for workarounds
  import_export_scaling: 1.0

  # Export triggers:
  # For each trigger give a name, the minutes of export needed and the energy required in that time
  # Multiple triggers can be set at once so in total you could use too much energy if all run
  # Creates an entity called 'binary_sensor.predbat_export_trigger_<name>' which will be turned On when the condition is valid
  # connect this to your automation to start whatever you want to trigger
  export_triggers:
     - name: 'large'
       minutes: 60
       energy: 1.0
     - name: 'small'
       minutes: 15
       energy: 0.25

  # If you have a sensor that gives the energy consumed by your solar diverter then add it here
  # this will make the predictions more accurate. It should be an incrementing sensor, it can reset at midnight or not
  # It's assumed to be in Kwh but scaling can be applied if need be
  #iboost_energy_today: 'sensor.xxxxx'
  #iboost_energy_scaling: 1.0
  # Gas rates for comparison
  #metric_octopus_gas: 're:(sensor.(octopus_energy_|)gas_[0-9a-z]+_[0-9a-z]+_current_rate)'

  # Nordpool market energy rates
  #futurerate_url: 'https://dataportal-api.nordpoolgroup.com/api/DayAheadPrices?date=DATE&market=N2EX_DayAhead&deliveryArea=UK&currency=GBP'
  #futurerate_adjust_import: True
  #futurerate_adjust_export: False
  #futurerate_peak_start: "16:00:00"
  #futurerate_peak_end: "19:00:00"
  #futurerate_peak_premium_import: 14
  #futurerate_peak_premium_export: 6.5

  # Watch list, a list of sensors to watch for changes and then update the plan if they change
  # This is useful for things like the Octopus Intelligent Slot sensor so that the plan update as soon as you plugin in
  # Only uncomment the items you actually have set up above in apps.yaml, of course you can add your own as well
  # Note those using +[] are lists that are appended to this list, whereas {} items are single items only
  #watch_list:
  #  - '{octopus_intelligent_slot}'
  # - '{octopus_ready_time}'
  # - '{octopus_charge_limit}'
  #  - '{octopus_saving_session}'
  #  - '+[car_charging_planned]'
  #  - '+[car_charging_soc]'
  #  - '{car_charging_now}'
