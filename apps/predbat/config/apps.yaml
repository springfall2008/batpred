# ------------------------------------------------------------------
# This is an example configuration, please modify it
# ------------------------------------------------------------------
---
pred_bat:
  module: predbat
  class: PredBat

  # Timezone to work in
  timezone: Europe/London
  
  # Set to auto-match with a GivEnergy serial number, but you can override the serial or the sensor names
  # if it doesn't work or if you have more than one inverter you will need to list both
  geserial: 're:sensor.givtcp_(.+)_soc_kwh'
  geserial2: 're:sensor.givtcp2_(.+)_soc_kwh'

  #
  # Sensors, currently more than one can be specified and they will be summed up automatically
  # however if you have two inverters only set one of them as they will both read the same.
  #
  load_today: 
    - sensor.givtcp_{geserial}_load_energy_today_kwh
  import_today: 
    - sensor.givtcp_{geserial}_import_energy_today_kwh
  export_today: 
    - sensor.givtcp_{geserial}_export_energy_today_kwh
  #
  # If you enable ge_cloud_data then the load/import and export data will be fetches from the GE cloud instead of from GivTCP sensors
  # this is usually less efficent and of course prone to internet downtime, but could be useful if you lost your GivTCP data
  # Set the serial to the inverter serial to pull the data from and the key to your API key
  # When this is set load_today, import_today and export_today are not used
  #
  ge_cloud_data: False
  ge_cloud_serial: '{geserial}'
  ge_cloud_key: 'xxxx'
  #
  # Controls/status - must by 1 per inverter
  #
  num_inverters: 1
  #
  # When set use the REST API rather than HA entity for control, should be more reliable/faster to control
  # Set one per inverter
  givtcp_rest: 
   - 'http://homeassistant.local:6345'
   - 'http://homeassistant.local:6346'

  # If not using REST then instead set the Control here (one for each inverter)
  # - you can delete this section if using REST
  charge_rate: 
    - number.givtcp_{geserial}_battery_charge_rate
    - number.givtcp2_{geserial2}_battery_charge_rate
  discharge_rate: 
    - number.givtcp_{geserial}_battery_discharge_rate
    - number.givtcp2_{geserial2}_battery_discharge_rate
  soc_kw: 
    - sensor.givtcp_{geserial}_soc_kwh
    - sensor.givtcp2_{geserial2}_soc_kwh
  soc_max: 
    - sensor.givtcp_{geserial}_battery_capacity_kwh
    - sensor.givtcp2_{geserial2}_battery_capacity_kwh
  reserve: 
    - number.givtcp_{geserial}_battery_power_reserve
    - number.givtcp2_{geserial2}_battery_power_reserve
  inverter_mode: 
   - select.givtcp_{geserial}_mode
   - select.givtcp2_{geserial2}_mode
  charge_start_time: 
   - select.givtcp_{geserial}_charge_start_time_slot_1
   - select.givtcp2_{geserial2}_charge_start_time_slot_1
  charge_end_time: 
   - select.givtcp_{geserial}_charge_end_time_slot_1
   - select.givtcp2_{geserial2}_charge_end_time_slot_1
  charge_limit: 
   - number.givtcp_{geserial}_target_soc
   - number.givtcp2_{geserial2}_target_soc
  scheduled_charge_enable: 
   - switch.givtcp_{geserial}_enable_charge_schedule
   - switch.givtcp2_{geserial2}_enable_charge_schedule
  scheduled_discharge_enable:
   - switch.givtcp_{geserial}_enable_discharge_schedule
   - switch.givtcp2_{geserial2}_enable_discharge_schedule
  discharge_start_time:
   - select.givtcp_{geserial}_discharge_start_time_slot_1
   - select.givtcp2_{geserial2}_discharge_start_time_slot_1
  discharge_end_time: 
   - select.givtcp_{geserial}_discharge_end_time_slot_1
   - select.givtcp2_{geserial2}_discharge_end_time_slot_1
  
  # Inverter max AC limit (one per inverter). E.g for a 3.6kw inverter set to 3600
  # If you have a second inverter for PV only please add the two values together
  inverter_limit: 
   - 7500
   - 7500

  # Inverter clock skew in minutes, e.g. 1 means it's 1 minute fast and -1 is 1 minute slow
  # Seperate start and end options are applied to the start and end time windows, mostly as you want to start late (not early) and finish early (not late)
  # Seperate discharge skew for discharge windows only
  inverter_clock_skew_start: 0
  inverter_clock_skew_end: 0
  inverter_clock_skew_discharge_start: 0
  inverter_clock_skew_discharge_end: 0
  
  # Set these to match solcast sensor names
  # The regular expression (re:) makes the solcast bit optional
  # If these don't match find your own names in Home Assistant
  pv_forecast_today: re:(sensor.(solcast_|)forecast_today)
  pv_forecast_tomorrow: re:(sensor.(solcast_|)forecast_tomorrow)
  pv_forecast_d3: re:(sensor.(solcast_|)forecast_d3)
  pv_forecast_d4: re:(sensor.(solcast_|)forecast_d4)

  # car_charging_energy defines an incrementing sensor which measures the charge added to your car
  # is used for car_charging_hold feature to filter out car charging from the previous load data
  # Automatically set to detect Wallbox and Zappi, if it doesn't match manually enter your sensor name
  # Also adjust car_charging_energy_scale if it's not in kwH to fix the units
  car_charging_energy: 're:(sensor.myenergi_zappi_[0-9a-z]+_charge_added_session|sensor.wallbox_portal_added_energy)'
  
  # car_charging_planned is set to a sensor which when positive indicates the car will charged in the upcoming low rate slots
  # This should not be needed if you use Octopus Intelligent Slots which will take priority if enabled
  # The list of possible values is in car_charging_planned_response
  # Auto matches Zappi and Wallbox, or change it for your own
  car_charging_planned: 're:(sensor.wallbox_portal_status_description|sensor.myenergi_zappi_[0-9a-z]+_plug_status)'
  car_charging_planned_response:
    - 'yes'
    - 'on'
    - 'true'
    - 'connected'
    - 'ev connected'
    - 'charging'
    - 'paused'
    - 'waiting for car demand'
    - 'waiting for ev'
    - 'scheduled'
    - 'enabled'
    - 'latched'
    - 'locked'
    - 'plugged in'

  # To make planned car charging more accurate, either using car_charging_planned or Octopus Inteligent
  # specify your battery size in kwh, charge limit % and current car battery soc % sensors/values
  # If you have intelligent you don't need to use this as it allocate slots, but it may help to get a more accurate figure
  # car_charging_battery_size: 75
  # car_charging_limit: 're:number.tsunami_charge_limit'
  # car_charging_soc: 're:sensor.tsunami_battery'

  # If you have Octopus intelligent, enable the intelligent slot information to add to pricing
  # Will automatically disable if not found, or comment out to disable fully
  # When enabled it overrides the 'car_charging_planned' feature and predict the car charging based on the intelligent plan (unless octopus intelligent charging is False)
  octopus_intelligent_slot: 're:binary_sensor.octopus_intelligent_slot'

  # Energy rates
  # Please set one of these three, if multiple are set then Octopus is used first, second rates_import/rates_export and latestly basic metric
  
  # Set import and export entity to point to the Octopus Energy plugin
  # automatically matches your meter number assuming you have only one (no need to edit the below)
  # Will be ignored if you don't have the sensor
  # Or manually set it to the correct sensor names if the automatic match doesn't work e.g:
  # sensor.octopus_energy_electricity_xxxxxxxxxx_xxxxxxxxxxxxx_current_rate
  # sensor.octopus_energy_electricity_xxxxxxxxxx_xxxxxxxxxxxxx_export_current_rate
  metric_octopus_import: 're:(sensor.(octopus_energy_|)electricity_[0-9a-z]+_[0-9a-z]+_current_rate)'
  metric_octopus_export: 're:(sensor.(octopus_energy_|)electricity_[0-9a-z]+_[0-9a-z]+_export_current_rate)'
  
  # Or set your actual rates across time for import and export
  # If start/end is missing it's assumed to be a fixed rate
  # Gaps are filled with metric_house from above
  #rates_import:
  #  -  start: "00:30:00"
  #     end: "04:30:00"
  #     rate: 7.5
  #  -  start: "04:30:00"
  #     end: "00:30:00"
  #     rate: 40.0
  #     
  #rates_export:
  #  -  rate: 4.2

  # Can be used instead of the plugin to get import rates directly online
  # Overrides metric_octopus_import and rates_import
  # rates_import_octopus_url : "https://api.octopus.energy/v1/products/FLUX-IMPORT-23-02-14/electricity-tariffs/E-1R-FLUX-IMPORT-23-02-14-A/standard-unit-rates"
  # rates_import_octopus_url : "https://api.octopus.energy/v1/products/AGILE-FLEX-BB-23-02-08/electricity-tariffs/E-1R-AGILE-FLEX-BB-23-02-08-A/standard-unit-rates"
  
  # Overrides metric_octopus_export and rates_export
  # rates_export_octopus_url: "https://api.octopus.energy/v1/products/FLUX-EXPORT-BB-23-02-14/electricity-tariffs/E-1R-FLUX-EXPORT-BB-23-02-14-A/standard-unit-rates"
  # rates_export_octopus_url: "https://api.octopus.energy/v1/products/AGILE-OUTGOING-BB-23-02-28/electricity-tariffs/E-1R-AGILE-OUTGOING-BB-23-02-28-A/standard-unit-rates/"
  # rates_export_octopus_url: "https://api.octopus.energy/v1/products/OUTGOING-FIX-12M-BB-23-02-09/electricity-tariffs/E-1R-OUTGOING-FIX-12M-BB-23-02-09-A/standard-unit-rates/"

  # Or set rates to be assumed for imports for the house, charging the battery and exports
  # this method will not allow automatic setting of charging windows
  # metric_house: 38
  # metric_battery: 7.5
  # metric_export: 4.2

  # For pv estimate, leave blank for central estimate, or add 10 for 10% curve (worst case) or 90 or 90% curve (best case)
  # If you use 10 then disable pv_metric10_weight below
  # pv_estimate: 10
  
  # Days previous is the number of days back to find historical load data
  # Recommended is 7 to capture day of the week but 1 can also be used
  # if you have more history you could use 7 and 14 (in a list) but the standard data in HA only lasts 10 days
  days_previous: 
    - 7

  # Number of hours forward to forecast, best left as-is unless you have specific reason
  forecast_hours: 48

  # The number of hours ahead to count in charge planning (for cost estimates)
  # It's best to set this on your charge window repeat cycle (24) but you may want to set it higher for more variable
  # tariffs like Agile
  forecast_plan_hours: 24

  # Maximum number of charge and discharge windows
  # Larger numbers of windows can increase runtime, normally 128 is more than enough for most uses
  max_windows: 128
  
  # Specify the devices that notifies are sent to, the default is 'notify' which goes to all
  #notify_devices: 
  #  - mobile_app_treforsiphone12_2

  # Set the frequency in minutes that this plugin is run
  # recommend something that divides by 60 (5, 10 or 15) or you won't trigger at the start of energy price slots
  run_every: 5

  # Battery scaling makes the battery smaller (e.g. 0.9) or bigger than its reported
  # If you have an 80% DoD battery that falsely reports it's kwh then set it to 0.8 to report the real figures
  battery_scaling: 1.0
  
  # Can be used to scale import and export data, used for workarounds
  import_export_scaling: 1.0

  # Export triggers:
  # For each trigger give a name, the minutes of export needed and the energy required in that time
  # Multiple triggers can be set at once so in total you could use too much energy if all run
  # Creates an entity called 'binary_sensor.predbat_export_trigger_<name>' which will be turned On when the condition is valid
  # connect this to your automation to start whatever you want to trigger
  export_triggers:
     - name: 'large'
       minutes: 60
       energy: 1.0
     - name: 'small'
       minutes: 15
       energy: 0.25
  
  # Enable user configuration inside Home Assistant
  user_config_enable: True  
  
  # ---------------------------------------------------------------------------------------------------
  # User config - these items are configurable inside Home Assistant when user_config_enable is set to True
  # In this case these items only provide default values when the entities are first created
  # ---------------------------------------------------------------------------------------------------

  # Battery loss accounts for energy lost charging the battery, 0.05 is 5%
  # Battery loss discharge accounts for energy lost discharging the battery, 0.05 is 5%
  battery_loss: 0.05
  battery_loss_discharge: 0.05

  # Battery rate scaling adjusts your maximum charge/discharge rate from that reported by GivTCP
  # e.g. a value of 1.1 would give you 10% faster charge/discharge than reported
  battery_rate_max_scaling: 1.0

  # Scaling factor applied to historial load, tune up if you want to be more pessimistic on future consumption
  # Use 1.0 to use exactly previous load data (1.1 would add 10% to load)
  load_scaling: 1.0

  # Scaling factor applied to pv data, tune down if you want to be more pessimistic on PV production vs Solcast
  # Use 1.0 to use exactly the solcast data (0.9 would remove 10% from forecast)
  pv_scaling: 1.0

  # Weighting given to the 10% PV scenario, comment out or put to 0.0 to disable this
  # A value of 0.1 assumes that 1:10 times we get the 10% scenario and hence to count this in the metric benefit/cost
  pv_metric10_weight: 0.15
  
  # When car charging hold is enable loads of above theshold kwh are assumed to be car charging and car_charging_rate will be subtracted (default 7.4)
  # Or if an incrementing energy sensor is provided actuals can be subtracted
  # The wallbox sensor is an example, automatically added if you have one, or comment our or replace with your own
  # Car charging energy scale - 1.0 if in Kwh or enter a different figure to scale the data accordingly (2.0 would double the data)
  car_charging_hold: True
  car_charging_energy_scale: 1.0
  car_charging_threshold: 6.0

  # Sets the car charging rate in kw, can also be pulled automatically from Ocotpus Intelligent if enabled
  # Also used to define the rate for car-charging hold
  car_charging_rate: 7.4

  # car_charging_loss gives the amount of energy lost when charging the car (load in the home vs energy added to the battery) 
  # 0.08 is 8%
  car_charging_loss: 0.08
  
  # Car charging planning - these are used if Octopus intelligent isn't enabled and car_charging_planned is connected correctly
  # car_charging_plan_time is the time that charging should be ready for.
  # car_charging_plan_smart when enabled the cheapest slots are used first regardless of order, when false it's just the next low rate slot
  car_charging_plan_time: "07:00:00"
  car_charging_plan_smart: False
  
  # Used to enable/disable octopus intelligent charging feature, you must have set octopus_intelligent_slot (above) to enable this
  octopus_intelligent_charging: True

  # Enable calculate best to work out the best battery SOC % based on cost, when disabled no scenarios apart from the default settings are computed
  calculate_best: True

  # calculate_best_charge:      If set to False then charge windows will not be calculated and the default inverter settings are used
  # calculate_charge_oldest:    If set to True the charge windows are calculated oldest first (in the highest price bracket), when False it's the newest first
  # calculate_charge_all:       When True all charge windows are calculated to a single percentage in a first pass (or only pass if there is only 1 window)
  # calculate_charge_passes:    Sets the number of discharge calculation passes to run (for multi-window only), the default is 2 (more than 2 has no impact)
  calculate_best_charge: True
  calculate_charge_oldest: False
  calculate_charge_all: True
  calculate_charge_passes: 2

  # calculate_best_discharge:   If set to False then discharge windows will not be calculated - defaults to 'set_discharge_window'
  # calculate_discharge_all:    When True all discharge windows are calculated to a single percentage in a first pass (or only pass if there is only 1 window)
  # calculate_discharge_passes: Sets the number of discharge calculation passes to run (for multi-window only), the default is 1 (more than 2 has no impact)
  # calculate_discharge_oldest: When True calculate from the oldest window (in the highest price bracket) first, when false start from the newest
  # calculate_discharge_first:  When True discharge takes priority over charging (to maximise profit on export), when false charging is optimised first. Default to True
  calculate_best_discharge: True
  calculate_discharge_all: False
  calculate_discharge_oldest: True
  calculate_discharge_passes: 1
  calculate_discharge_first: True

  # best_soc margin : added to the final SOC estimate (in kwh) to set the battery charge level (pushes it up). 
  #                   Best not used with multiple charge windows as it tends up limit everything.
  # best_soc_min : sets the minimum charge level (in kwh) for charging during each slot and the minimum discharge level also (set to 0 if you want to skip some slots)
  # best_soc_keep : is minimum battery level to try to keep above during the whole period of the simulation time, soft constraint only (use min for hard constraint)
  # best_soc_step: is the accuracy to calculate the charge levels to, higher values make calculations quicker, smaller ones will take longer (recommended 0.5 or 0.25)
  # best_soc_pass_margin: Only used for multiple charge windows, the margin to add to the first pass calculations only (default is 0)
  best_soc_margin: 0
  best_soc_min: 2
  best_soc_keep: 2
  best_soc_step: 0.25
  best_soc_pass_margin: 0
     
  # Control if charge slots of > 30 minutes can be combined. When disabled they will be split up, increasing runtimes but potentially more accurate for planning.
  # Not recommended to set to False when best_soc_min set to True or all slots will be kept
  # Default is enabled (True)
  combine_charge_slots: True

  # When combine charge is False discharge slots will be split into the given slot size, recommended 15 or 30 (must be multiple of 5) - default 30
  charge_slot_split: 30

  # Control if discharge slots of > 30 minute can be combined. When disabled they will be split up, increasing runtimes but potentially more accurate for planning.
  # Default is enabled (True)
  combine_discharge_slots: True

  # When combine discharge is False discharge slots will be split into the given slot size, recommended 15 or 30 (must be multiple of 5) - default 15
  # A value of 15 maybe more useful for discharge planning if the available battery to export isn't that large
  # When combine discharge is True then the split amount is used to determine the intervals that the window is re-sized in (must be mutiple of 5)
  discharge_slot_split: 15

  # Allow mixed rates to be combined into a single average rate charge/discharge window (e.g. Agile windows)
  combine_mixed_rates : False

  # Metric min improvement sets the minimum cost improvement that it's worth lowering the battery SOC % for
  # If it's 0 then this is disabled.
  #
  # A figure of around 5 (which is 5p) is a good one to use if enabled.
  # If you use pv_metric10_weight then you probably don't need to enable this as the 10% forecast does the same thing better 
  # Do not use if you have multiple charge windows in a given period as it won't lead to good results
  # or you could even go to something like -0.1 to say you would charge less even if it cost up to 0.1p more (best used with metric10)
  metric_min_improvement: -0.1

  # Min improvement metric for discharge
  metric_min_improvement_discharge: 0.1

  # Threshold below average rates as the minimum to consider for a charge window, 0.8 = 80% of average rate
  # If you set this too low you might not get enough charge slots. If it's too high you might get too many in the 24-hour period (max is 10)
  rate_low_threshold: 0.8

  # Threshold above average rates as to the minimum export rate to consider exporting for - 1.2 = 20% above average rate
  rate_high_threshold: 1.2
  
  # rate_low_match_export - When enabled consider import rates that are lower than the highest export rate (minus any battery losses)
  rate_low_match_export: False
  
  # When enabled the next charge window will be automatically configured based on the incoming rates
  # Only works if the charging time window has been enabled and import rates are configured with the rates_import or using Octopus import
  # Set window minutes defines how many minutes before the charge window we should program it (do not set above 30 if you are using Agile or similar)
  # Will also automatically disable charging if not required and re-enable it when required. 
  # If you turn this off later check that 'GivTCP Enable Charge Schedule' is turned back on.
  set_charge_window: True
  set_window_notify: True
  set_window_minutes: 30

  # When enabled automatically discharge for export during high rate periods 
  # inverter mode and discharge start/end time entities above must be set correctly and you must have an export rate set correctly
  # exports are in 30-minute slots, not all slots will be used
  set_discharge_window: True
  set_discharge_notify: True
  
  # When enable automatically set the battery SOC charge amount a defined number of minutes before charging starts
  # note it maybe set more than once if things change
  set_soc_enable: True
  set_soc_notify: True
  set_soc_minutes: 30

  # When set_reserve_enable is True the reserve % will be reprogrammed during a charging window or discharging window to match the target SOC/discharge % in order
  # to prevent discharge and then reset back to minimum % outside the window. Set the set_reserve_min to your minimum reserve % which is often 4%.
  # The feature applies with set_soc_enable or set_discharge_window is True 
  # When set_reserve_hold is True then if the current charge % is above the target charging will be disabled and the reserve will be used to hold the level (Good for gen3 workaround)
  set_reserve_enable: True
  set_reserve_notify: True
  set_reserve_hold: True
  set_reserve_min: 4

  # IBoost model, when enabled tries to model excess solar energy being used to heat hot water (or similar)
  # Max energy sets the number of kwh that iBoost can consume during a day before turning off - default 3kwh
  # Max Power sets the maximum power in watts to consume - default 2400
  # Min Power sets the minimum power in watts to consume - default 500
  # Min soc sets the minimum home battery soc % to enable iboost on, default 0
  # You will see predbat.iboost_today entity which tracks the estimated amount consumed during the day, and resets at night
  iboost_enable: False
  iboost_max_power: 2400
  iboost_min_power: 500
  iboost_min_soc: 0
  iboost_max: 3.0
  
  # Debug enable prints lots of debug, leave off by default
  debug_enable: False
