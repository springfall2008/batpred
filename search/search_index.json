{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Home battery prediction and automatic charging for Home Assistant supporting multiple inverters including: GivEnergy Hybrid, AC and AIO (Local & Cloud) Solis Solax (Local & Cloud) Sunsynk Huawei SolarEdge Fox (Local & Cloud) Sofar LuxPower Solar Assistant Sigenergy Sigenstor Also known by some as Batpred or Batman! License Please see License Copyright (c) Trefor Southwell 2025-2026 - All rights reserved This software may be used at no cost for personal use only No warranty is given, either expressed or implied For support please raise a GitHub ticket or use the Facebook Group: Predbat and watch my YouTube Channel Use my referral code for Octopus Energy: https://share.octopus.energy/jolly-eel-176 Use my referral code for Axle Energy (UK): https://vpp.axle.energy/landing/grid?ref=R-VWIICRSA Some inverters have their own groups e.g.: GivTCP Solis If you want to buy me a beer then please use Paypal or GitHub sponsor Taster Once you are up and running you will get a chart that predicts your battery levels over time: You can also see this in a plan format predicting your overall costs and your carbon footprint (if enabled, UK only for now): You can see the cost over time for the plan that Predbat has made and also how it might turn out if your solar production (should you have solar) is lower than expected or if you use a bit more energy than planned (10% scenario): You can see your energy rates over time and where the battery is being charged: Power charts can show you how the prediction maps to your inverter: You can model iBoost or similar solar diverters, this will be shown on your plan and you can even use it to trigger smart devices e.g. an emersion heater based on energy rates. You can predict when your car will charge and use Predbat to schedule the cheapest car charging slots: Charts can track your cost savings using Predbat and from having a PV and Battery system The calibration chart is useful for tuning the model for things like inverter losses until it matches reality: Predbat can track your actual vs predicted energy usage and make real-time adjustments to the predictions if you use more or less: You can tune lots of parameters to match your system and needs: You can also override the plan temporarily if you have a particular reason to: Please read the documentation for more information!","title":"Introduction"},{"location":"#introduction","text":"Home battery prediction and automatic charging for Home Assistant supporting multiple inverters including: GivEnergy Hybrid, AC and AIO (Local & Cloud) Solis Solax (Local & Cloud) Sunsynk Huawei SolarEdge Fox (Local & Cloud) Sofar LuxPower Solar Assistant Sigenergy Sigenstor Also known by some as Batpred or Batman!","title":"Introduction"},{"location":"#license","text":"Please see License Copyright (c) Trefor Southwell 2025-2026 - All rights reserved This software may be used at no cost for personal use only No warranty is given, either expressed or implied For support please raise a GitHub ticket or use the Facebook Group: Predbat and watch my YouTube Channel Use my referral code for Octopus Energy: https://share.octopus.energy/jolly-eel-176 Use my referral code for Axle Energy (UK): https://vpp.axle.energy/landing/grid?ref=R-VWIICRSA Some inverters have their own groups e.g.: GivTCP Solis If you want to buy me a beer then please use Paypal or GitHub sponsor","title":"License"},{"location":"#taster","text":"Once you are up and running you will get a chart that predicts your battery levels over time: You can also see this in a plan format predicting your overall costs and your carbon footprint (if enabled, UK only for now): You can see the cost over time for the plan that Predbat has made and also how it might turn out if your solar production (should you have solar) is lower than expected or if you use a bit more energy than planned (10% scenario): You can see your energy rates over time and where the battery is being charged: Power charts can show you how the prediction maps to your inverter: You can model iBoost or similar solar diverters, this will be shown on your plan and you can even use it to trigger smart devices e.g. an emersion heater based on energy rates. You can predict when your car will charge and use Predbat to schedule the cheapest car charging slots: Charts can track your cost savings using Predbat and from having a PV and Battery system The calibration chart is useful for tuning the model for things like inverter losses until it matches reality: Predbat can track your actual vs predicted energy usage and make real-time adjustments to the predictions if you use more or less: You can tune lots of parameters to match your system and needs: You can also override the plan temporarily if you have a particular reason to: Please read the documentation for more information!","title":"Taster"},{"location":"apps-yaml/","text":"apps.yaml settings The basic Predbat configuration is defined in the apps.yaml file. Depending on how you installed Predbat the apps.yaml file will be held in one of three different directories in Home Assistant: if you have used the Predbat app installation method , apps.yaml will be in the directory /addon_configs/6adb4f0d_predbat , with the HACS, Appdaemon app then Predbat installation method , it's in /config/appdaemon/apps/batpred/config/ , or if the combined AppDaemon/Predbat app installation method was used, it's in /addon_configs/46f69597_appdaemon-predbat/apps . You will need to use a file editor within Home Assistant (e.g. either the File editor or Studio Code Server apps) to edit the apps.yaml file - see editing configuration files within Home Assistant if you need to install an editor. This section of the documentation describes what the different configuration items in apps.yaml do. When you edit apps.yaml , the change will automatically be detected and Predbat will be reloaded with the updated file. You don't need to restart the Predbat or AppDaemon app for your edits to take effect. Warning! apps.yaml file format When editing the apps.yaml file you must ensure that the file remains correctly formatted. YAML files are especially finicky about how the file contents are indented and it's very easy to end up with an incorrectly formatted file that will cause problems for Predbat. The YAML Basics from This Smart Home is a good introduction video to how YAML should be correctly structured but as a brief introduction: At the start of the apps.yaml file is the predbat module definition: pred_bat: module: predbat class: PredBat YAML can be thought of as a tree structure with 'pred_bat' at the top of the tree and everything else, e.g. 'module' and 'class' being children of the pred_bat tree. Each child entry must be indented by two spaces under the parent it follows, so 'module' and 'class' are thus children of 'pred_bat'. The YAML file consists of configuration item, a colon, and then the configuration value, for example, timezone is a child configuration item under the over-arching 'pred_bat' parent: timezone: Europe/London If the configuration item is a list of values, each of the list values appears on a new line, indented by a further two spaces, a dash, and then the value. For example, car_charging_response is a child of 'pred_bat' and consists of two values, 'yes' and 'no': car_charging_now_response: - 'yes' - 'on' Child entries can have children of their own, so for example rates_import_override is a child of the overarching 'pred_bat', and it has children configuration items of its own being 'start', 'end' and 'rate': rates_import_override: - start: '13:00:00' end: '14:00:00' rate: 0 The indentation of children being two spaces indented from their parents and there being two spaces before the dash are especially critical. It's easy to mis-edit and have one or three spaces which isn't valid YAML. NB: the sequence of entries in apps.yaml doesn't matter, as long as the YAML itself is structured correctly you can move things and edit things anywhere in the file. Templates You can find template configurations in the following location: https://github.com/springfall2008/batpred/tree/main/templates The GivEnergy GivTCP template will be installed by default but if you are using another inverter please copy the correct template for your inverter into the directory where your apps.yaml is stored, replacing the existing apps.yaml file, and modify it from there. Please read Inverter Setup for inverter control software and details of setting apps.yaml for non-GivEnergy inverters Checking your apps.yaml Syntax errors will be highlighted by the Home Assistant editor or via other YAML-aware editors such as VSCode. Once you have completed your apps.yaml and started Predbat you may want to open the Predbat Web Interface and click on 'apps.yaml'. Review any items shown in a red background as those do not match (it's okay for a 2nd inverter not to match if you only have one configured). Regular expressions that do not match can be ignored if you are not supporting that feature (e.g. Car SoC if you don't have a car). As an example these do not match and are shown in the web interface in red, I'm ignoring them as I only have one inverter and I'm using the Predbat internal Solcast rather than the external integration: Storing secrets Predbat supports the Home Assistant secrets mechanism for storing sensitive information like API keys, passwords, and tokens. Using secrets.yaml Create a secrets.yaml file in one of these locations (checked in order, only the first one is read): Path specified in PREDBAT_SECRETS_FILE environment variable secrets.yaml in the same directory as your apps.yaml /homeassistant/secrets.yaml (standard Home Assistant location) The secrets.yaml file contains key-value pairs of your secrets, e.g.: octopus_api_key: \"sk_live_abc123xyz...\" solcast_api_key: \"def456uvw...\" Referencing secrets in apps.yaml Use the !secret tag followed by the secret key name in your apps.yaml . You only need to enter the keys you are using: pred_bat: module: predbat class: PredBat ha_key: !secret ha_key # Home Assistant Long-Lived Access Token octopus_api_key: !secret octopus_api_key # Octopus API key (if using Octopus direct) solcast_api_key: !secret solcast_api_key # Solcast API key (if using Solcast direct) forecast_solar_api_key: !secret forecast_solar_api_key # Forecast.solar API key (if using Forecast.solar) ge_cloud_key: !secret ge_cloud_key # GivEnergy API key (if using GE Cloud) fox_key: !secret fox_key # Fox ESS API key and username (if using Fox Cloud) axle_api_key: !secret axle_api_key # Axle API key (if using Axle VPP) When Predbat loads, it will automatically replace !secret octopus_api_key with the actual value from secrets.yaml . If a secret is referenced in apps.yaml but not found in secrets.yaml , Predbat will log a warning and the configuration item will be set to None . Benefits of using secrets Keeps sensitive information separate from configuration files Makes it safer to share your apps.yaml for troubleshooting All secrets stored in one centralized location Compatible with Home Assistant's secrets system Basics Basic configuration items prefix Set to the prefix name to be used for all entities that Predbat creates in Home Assistant. Default 'predbat'. Unlikely that you will need to change this. prefix: predbat timezone Set to your local timezone, the default is Europe/London. It must be set to a valid Python time zone for your location timezone: Europe/London currency_symbols Sets your symbol to use for your main currency e.g. \u00a3, \u20ac or $ and for 1/100th unit e.g. p or c. You must define both currency_symbol entries. currency_symbols: - '\u00a3' - 'p' template Initially set to True, this is used to stop Predbat from operating until you have finished configuring your apps.yaml . Once you have made all other required changes to apps.yaml this line should be deleted or commented out: template: True Home Assistant connection Predbat can speak directly to Home Assistant rather than going via AppDaemon. If you are using a standard Predbat app then this will be automatic and you should normally not need to set this. If you find you get issues where Predbat cannot communicate with Home Assistant after running for a long period of time and you get web socket errors, then creating a HA access key as described below can resolve this. If you run Predbat in a Docker container then you will need to set the URL or IP address of Home Assistant and an access key. The access key is a long-lived security access token you can create inside Home Assistant: Click on your user initials (bottom left) in HA; Click the Security tab Scroll to the bottom of the security screen and under 'Long-lived Access tokens', click 'Create Token' then copy the generated access token into ha_key in apps.yaml Currently, if this communication is not established Predbat will fall back to AppDaemon, however, some users have experienced failures due to a 10-second timeout set by AppDaemon. In future versions of Predbat, AppDaemon will be removed. ha_url: 'http://homeassistant.local:8123' ha_key: 'xxxxxxxxxxx' NOTE: It's recommended to store ha_key in secrets.yaml and reference it as ha_key: !secret ha_key - see Storing secrets . TIP: You can replace homeassistant.local with the IP address of your Home Assistant server if you have it set to a fixed IP address. This will remove the need for a DNS lookup of the IP address every time Predbat talks to Home Assistant and may improve reliability as a result. threads If defined sets the number of threads to use during plan calculation, the default is 'auto' which will use the same number of threads as you have CPUs in your system. Valid values are: 'auto' - Use the same number of threads as your CPU count '0' - Don't use threads - disabled 'N' - Use N threads, recommended values are between 2 and 8 threads: auto enable_coarse_fine_levels Controls the two-pass coarse/fine optimization algorithm for improved planning performance. The default is True (enabled). When enabled, Predbat uses a two-pass optimization strategy: Coarse pass : Quickly evaluates a reduced set of slot length combinations to identify approximately optimal charge/export window sizes Fine pass : Refines the search by focusing only on slot lengths near those identified as optimal This significantly reduces planning time while maintaining near-optimal results. You can disable this by setting it to False if needed. enable_coarse_fine_levels: True Web interface Docker users can change the web port for the Predbat web interface by setting web_port to a new port number. The default port of 5052 must always be used for the Predbat app. web_port: 5052 notify_devices A list of device names to notify when Predbat sends a notification. The default is just 'notify' which contacts all mobile devices notify_devices: - mobile_app_treforsiphone12_2 days_previous Predbat needs to know what your likely future house load will be to set and manage the battery level to support it. days_previous defines a list (which has to be entered as one entry per line) of the previous days of historical house load that are to be used to predict your future daily load. It's recommended that you set days_previous so Predbat calculates an average house load using multiple days' history so that 'unusual' load activity (e.g. saving sessions, \"big washing day\", etc) get averaged out. For example, if you want Predbat to average house load for the past week: days_previous: - 2 - 3 - 4 - 5 - 6 - 7 - 8 Or if you want Predbat to take the average of the same day for the last two weeks: days_previous: - 7 - 14 Or to just assume that house load on a particular day is the same as the same day of last week (not recommended): days_previous: - 7 Further details and worked examples of how days_previous works are covered at the end of this document. Do keep in mind that Home Assistant only keeps 10 days of history by default, so if you want to access more than this for Predbat you might need to increase the number of days of history kept in HA before it is purged by editing and adding the following to the /homeassistant/configuration.yaml configuration file and restarting Home Assistant afterwards: recorder: purge_keep_days: 14 days_previous_weight - A list (again with one entry per line) of weightings to be applied to each of the days in days_previous. For example, to apply a 100% weighting for the first-day entry in days_previous, but only a 50% weighting to the second day in days_previous: days_previous_weight: - 1 - 0.5 The default value is 1, and all history days are equally weighted, so if you don't want to weight individual days you can simply use: days_previous_weight: - 1 forecast_hours the number of hours that Predbat will forecast, 48 is the suggested amount, although other values can be used such as 30 or 36 if you have a small battery and thus don't need to forecast 2 days ahead. forecast_hours: 48 plan_random_delay Can set the maximum number of seconds of delay when recalculating the plan after it expires. The exact delay will be between 0 and this value. The default is 0. plan_random_delay: 30 Inverter information The template apps.yaml for each inverter type comes pre-configured with regular expressions that should auto-discover the Home Assistant entity names for that inverter type. If you have more than one inverter or entity names are non-standard then you will need to edit apps.yaml for your inverter entities. Givenergy Cloud Direct Predbat now supports direct communication with the GivEnergy cloud services instead of local control via GivTCP to your inverter. Log into the GivEnergy Portal web site and create an API key and copy it into the ge_cloud_key setting in apps.yaml . If you set ge_cloud_automatic to True, the number of inverters and their settings will be configured automatically. Or, if you set ge_cloud_automatic to False then you need to manually configure ge_cloud_serial to your inverter serial number for Predbat to use on the GivEnergy Cloud. If you set ge_cloud_data to False then Predbat will use the local Home Assistant data for history rather than the cloud data; you will need to wait until you have a few days of history established (at least days_previous days) before this will work correctly. ge_cloud_direct: True ge_cloud_automatic: True ge_cloud_serial: '{geserial}' ge_cloud_key: 'xxxxx' ge_cloud_data: True NOTE: It's recommended to store ge_cloud_key in secrets.yaml and reference it as ge_cloud_key: !secret givenergy_api_key - see Storing secrets . SolaX Cloud Direct Predbat supports direct communication with the SolaX Cloud API to control SolaX inverters and batteries without requiring local integrations. To use SolaX Cloud Direct, you need to obtain API credentials (client ID and client secret) from your SolaX Cloud account. Getting your SolaX Cloud API credentials Log in to your SolaX Cloud account at: - EU: https://www.solaxcloud.com - US: https://www.solaxcloud.us - CN: https://www.solaxcloud.com.cn Navigate to Settings \u2192 API Management (or Developer Settings) Create a new API application or access existing credentials Copy your Client ID and Client Secret Add these to your apps.yaml configuration Basic SolaX Cloud configuration If you set solax_automatic to true , Predbat will automatically discover your plants, inverters, and batteries, and configure all necessary entities without manual intervention. solax_client_id: 'your_client_id_here' solax_client_secret: 'your_client_secret_here' solax_region: 'eu' # Options: 'eu', 'us', or 'cn' solax_automatic: true solax_enable_controls: true NOTE: It's strongly recommended to store solax_client_id and solax_client_secret in secrets.yaml and reference them as: solax_client_id: !secret solax_client_id solax_client_secret: !secret solax_client_secret See Storing secrets for more information. Region selection Set solax_region based on where your SolaX Cloud account is registered: 'eu' - European region (default) - openapi-eu.solaxcloud.com 'us' - United States region - openapi-us.solaxcloud.com 'cn' - China region - openapi.solaxcloud.com Optional configuration options solax_plant_id : If you have multiple plants registered in your SolaX Cloud account but only want Predbat to control specific plants, you can filter by plant ID: solax_plant_id: '1618699116555534337' If not specified, Predbat will control all plants found in your account. solax_enable_controls : Set to False to disable automatic inverter control (read-only mode). Useful for monitoring without control: solax_enable_controls: False Automatic configuration (solax_automatic: true) When solax_automatic is enabled, Predbat will: Discover all plants with inverters and batteries in your SolaX Cloud account Automatically configure num_inverters based on the number of plants found Set inverter_type to SolaxCloud for each plant Create and configure all required entities including: - Battery power, SOC, capacity, and temperature sensors - Inverter and PV power sensors - Energy totals (yield, charged, discharged, imported, exported, load) - Charge/discharge schedule controls (start/end times, target SOC, rates) - Enable/disable switches for charge and export schedules - Reserve SOC setting No manual entity configuration is required when using automatic mode. Published entities When SolaX Cloud is configured, Predbat creates the following entities for each plant (replace {plant_id} with your actual plant ID): Sensors: sensor.predbat_solax_{plant_id}_battery_soc - Battery state of charge (kWh) sensor.predbat_solax_{plant_id}_battery_capacity - Battery capacity (kWh) sensor.predbat_solax_{plant_id}_battery_temperature - Battery temperature (\u00b0C) sensor.predbat_solax_{plant_id}_battery_max_power - Battery maximum power (W) sensor.predbat_solax_{plant_id}_inverter_max_power - Inverter maximum power (W) sensor.predbat_solax_{plant_id}_pv_capacity - PV array capacity (kWp) sensor.predbat_solax_{plant_id}_total_yield - Total PV generation (kWh) sensor.predbat_solax_{plant_id}_total_charged - Total battery charged (kWh) sensor.predbat_solax_{plant_id}_total_discharged - Total battery discharged (kWh) sensor.predbat_solax_{plant_id}_total_imported - Total grid import (kWh) sensor.predbat_solax_{plant_id}_total_exported - Total grid export (kWh) sensor.predbat_solax_{plant_id}_total_load - Total load consumption (kWh, calculated) sensor.predbat_solax_{plant_id}_total_earnings - Total earnings from exports Control entities: number.predbat_solax_{plant_id}_setting_reserve - Battery reserve SOC (%) select.predbat_solax_{plant_id}_battery_schedule_charge_start_time - Charge start time select.predbat_solax_{plant_id}_battery_schedule_charge_end_time - Charge end time number.predbat_solax_{plant_id}_battery_schedule_charge_target_soc - Charge target SOC (%) number.predbat_solax_{plant_id}_battery_schedule_charge_rate - Charge rate (W) switch.predbat_solax_{plant_id}_battery_schedule_charge_enable - Enable/disable charging select.predbat_solax_{plant_id}_battery_schedule_export_start_time - Export start time select.predbat_solax_{plant_id}_battery_schedule_export_end_time - Export end time number.predbat_solax_{plant_id}_battery_schedule_export_target_soc - Export target SOC (%) number.predbat_solax_{plant_id}_battery_schedule_export_rate - Export rate (W) switch.predbat_solax_{plant_id}_battery_schedule_export_enable - Enable/disable exporting Manual configuration (solax_automatic: False) If you disable automatic configuration, you must manually configure inverter entities in apps.yaml similar to other inverter types. In this case, set: solax_automatic: False num_inverters: 1 inverter_type: 'SolaxCloud' Then manually configure all required entities following the standard Predbat inverter configuration pattern. Multi-inverter / Multi-plant setup If you have multiple SolaX plants, automatic configuration will handle them automatically. Each plant will be treated as a separate inverter in Predbat's configuration. Supported inverter types (SolaX cloud) SolaX Cloud API supports various SolaX inverter models including: X1 series (single-phase) X3 series (three-phase) X3-Hybrid series Other SolaX cloud-connected inverters Both residential (business_type=1) and commercial (business_type=4) installations are supported. Troubleshooting (SolaX cloud) If you experience connection issues: Verify your client ID and client secret are correct Confirm you're using the correct region setting Check that your SolaX Cloud account has API access enabled Review Predbat logs for authentication errors Test your API credentials using the standalone test: cd /config/appdaemon/apps/predbat python3 solax.py --client-id YOUR_CLIENT_ID --client-secret YOUR_CLIENT_SECRET --region eu Solis Cloud API EXPERIMENTAL: This is a new integration and may have issues. Predbat includes support for Solis inverters via the Solis Cloud API, allowing direct cloud-based monitoring and control of Solis hybrid inverters with battery storage. Configuration (solis) Add the following to your apps.yaml to configure the Solis Cloud integration: solis_api_key: !secret solis_api_key solis_api_secret: !secret solis_api_secret solis_automatic: True solis_control_enable: True Configuration options: solis_api_key - Your Solis Cloud API Key (KeyId) - obtain from Solis Cloud portal solis_api_secret - Your Solis Cloud API Secret (KeySecret) - obtain from Solis Cloud portal solis_inverter_sn - Default is all inverters on your account unless set. Can be a single string or a list for multiple inverters. solis_automatic - Set to True to automatically configure Predbat entities (recommended, default: False ) solis_base_url - Solis Cloud API base URL (optional, auto-detects region) solis_control_enable - Enable/disable control commands (default: True , set to False for monitoring only) NOTE: It's strongly recommended to store api_key and api_secret in secrets.yaml and reference them as !secret solis_api_key - see Storing secrets . Important notes (Solis) IMPORTANT: The Solis Cloud integration cannot automatically determine your battery size from the inverter. You have two options: Manual configuration (recommended): Set soc_max in apps.yaml manually with your battery capacity in kWh: soc_max: - 13.5 Replace 13.5 with your actual battery capacity in kWh. Automatic detection: Leave soc_max unset or set to 0, and Predbat will attempt to automatically determine battery size by analyzing historical charging data. This requires: - At least several days of historical data from soc_percent and battery_power sensors - Charging periods with at least 15% SoC change - May take time to collect sufficient data Manual configuration is recommended as it's immediate and more reliable. Automatic configuration (solis_automatic: True) When automatic: True (recommended), Predbat will automatically create and configure the following entities for each inverter: Sensors: Battery SOC, capacity, voltage, current, power, and temperature PV power and total energy Grid power and import/export energy Load power and consumption Inverter status and product model Control entities: Reserve SOC setting Charge/discharge slot times (6 slots supported) Charge/discharge target SOC per slot Charge/discharge power rates Charge/discharge enable switches per slot Storage mode selection Battery protection settings No manual entity configuration is required when using automatic mode. Manual configuration (solis_automatic: False) If you disable automatic configuration, you must manually configure inverter entities in apps.yaml similar to other inverter types. In this case, set: solis_api_key: !secret solis_api_key solis_api_secret: !secret solis_api_secret solis_automatic: False solis_control_enable: True num_inverters: 1 inverter_type: 'SolisCloud' soc_max: - 13.5 Then manually configure all required entities following the standard Predbat inverter configuration pattern. Supported inverter types (Solis Cloud) The Solis Cloud API supports various Solis hybrid inverter models with battery storage, including: RHI series (single-phase hybrid) RAI series (three-phase hybrid) S5 series hybrid inverters Other Solis cloud-connected hybrid inverters Both V1 (older firmware) and V2 (newer firmware) time window formats are automatically detected and supported. Troubleshooting (Solis Cloud) If you experience connection issues: Verify your API key and secret are correct Check your inverter serial number is exact (no spaces or extra characters) Confirm your Solis Cloud account has API access enabled Review Predbat logs for authentication errors Ensure soc_max is set correctly in apps.yaml (battery capacity in kWh) Check that control_enable is set appropriately for your needs num_inverters The number of inverters you have. If you increase this above 1 you must provide multiple of each of the inverter entities num_inverters: 1 inverter_type inverter_type defaults to 'GE' (GivEnergy) if not set in apps.yaml , or should be set to one of the inverter types that are already pre-programmed into Predbat: FoxCloud: Fox Cloud integration FoxESS: FoxESS via modbus GE: GivEnergy via GivTCP GEC: GivEnergy Cloud integration GEE: GivEnergy EMC GS: Ginlong Solis HU: Huawei Solar SA: Solar Assistant SE: SolarEdge SF: Sofar HYD SFMB: Sofar HYD with solarman modbus SIG: SigEnergy Sigenstor SK: Sunsynk SolaxCloud: SolaX Cloud API integration (EXPERIMENTAL) SolisCloud: Solis Cloud API integration (EXPERIMENTAL) SX4: Solax Gen4 (Modbus Power Control) If you have multiple inverters, then set inverter_type to a list of the inverter types. If you have created a custom inverter type in apps.yaml then inverter_type must be set to the same code as has been used in the custom inverter definition. geserial Only for GE inverters, this is a helper regular expression to find your inverter serial number, if it doesn't work edit it manually or change individual entities to match. If you have more than one GivEnergy inverter you will need one per inverter to be used in the later configuration lines. If you only have a single GivEnergy inverter then comment out all lines that refer to geserial2 in apps.yaml . geserial: 're:sensor.givtcp_(.+)_soc_kwh' geserial2: 're:sensor.givtcp2_(.+)_soc_kwh' If you are running GivTCP v3 and have an 'All-In-One' (AIO) or a 3-phase inverter then the helper regular expression will not correctly work and you will need to manually set geserial in apps.yaml to your inverter serial number which must be entered in lower case, e.g.: geserial: 'chNNNNgZZZ' TIP: If you have a single GivEnergy AIO, all control is directly to the AIO and the gateway is not required. Check the GivTCP configuration to determine whether inverter 1 (the givtcp sensors) is the AIO or the gateway, or inverter 2 (the givtcp2 sensors) is the AIO or gateway. Then in apps.yaml comment out the lines corresponding to the gateway, leaving just the givtcp or givtcp2 lines for the AIO. Also, delete the appropriate givtcp_rest inverter control line corresponding to the gateway so that Predbat controls the AIO directly. TIP2: If you have multiple GivEnergy AIO's, all the AIO's are controlled by the AIO gateway and not controlled individually. geserial should be manually configured to be your AIO gateway serial number 'gwNNNNgZZZ' and all the geserial2 lines should be commented out in apps.yaml . You should also delete the second givtcp_rest inverter control line so that Predbat controls the AIOs via the gateway. GivTCP version 3 is required for multiple AIOs or a 3-phase inverter. Historical data Predbat can either get historical data (house load, import, export and PV generation) directly from GivTCP or it can obtain it from the GivEnergy cloud. Unless you have a specific reason to not use the GivTCP data (e.g. you've lost your GivTCP data), its recommended to use GivTCP. Data from Home Assistant The following configuration entries in apps.yaml are pre-configured to automatically use the appropriate sensors. If you have a 3-phase electricity supply and one inverter (and battery) on each phase then you will need to add one line for the load, import, export and PV sensors for each of the 3 phases. If you have a single-phase electricity supply and multiple inverters on the phase then you will need to add one line for each of the load and PV sensors. You don't need multiple lines for the import or export sensors as each inverter will give the same total import or export information. Edit if necessary if you have non-standard sensor names: load_today - Entity name for the house load in kWh today (must be incrementing) load_power - Current load power sensor in W (used with load_power_fill_enable to improve load_today data accuracy) load_power_fill_enable - When True (default), uses load_power data to fill gaps and smooth load_today sensor data. Set to False to disable this feature. import_today - Imported energy today in kWh (incrementing) export_today - Exported energy today in kWh (incrementing) pv_today - PV energy today in kWh (incrementing). If you have multiple inverters, enter each inverter PV sensor on a separate line. If you have an AC-coupled inverter then enter the Home Assistant sensor for your PV inverter. If you don't have any PV panels, comment or delete this line out of apps.yaml . Note: these '_today' entity names must all be energy sensors recording electricity measured over a time period, NOT power sensors which measure instantaneous power. The load_power_fill_enable feature helps to improve the accuracy of historical load data by using instantaneous power readings to fill gaps and smooth out load_today sensors that update infrequently (e.g., sensors that increment in kWh units may only update every hour). This preprocessing happens before the main load data analysis and can significantly improve prediction accuracy, especially for systems with coarse-grained energy sensors. See the Workarounds section below for configuration settings for scaling these if required. If you have multiple inverters then you may find that the load_today figures are incorrect as the inverters share the house load between them. In this circumstance, one solution is to create a Home Assistant template helper to calculate house load from {pv generation}+{battery discharge}-{battery charge}+{import}-{export}. The example below is defined in configuration.yaml (not the HA user interface) so it only updates every 5 minutes rather than on every underlying sensor state change: e.g. # Home consumption energy sensor, updated every 5 minutes instead of the default of every sensor state change template: - trigger: - platform: time_pattern minutes: \"/5\" sensor: - name: \"House Load Today\" unique_id: \"house_load_today\" unit_of_measurement: kWh state_class: total device_class: energy state: > {% set pv_xxx = states('sensor.givtcp_xxx_pv_energy_today_kwh') %} {% set pv_yyy = states('sensor.givtcp2_yyy_pv_energy_today_kwh') %} {% set dis_xxx = states('sensor.givtcp_xxx_battery_discharge_energy_today_kwh') %} {% set dis_yyy = states('sensor.givtcp2_yyy_battery_discharge_energy_today_kwh') %} {% set chg_xxx = states('sensor.givtcp_xxx_battery_charge_energy_today_kwh') %} {% set chg_yyy = states('sensor.givtcp2_yyy_battery_charge_energy_today_kwh') %} {% set import = states('sensor.givtcp_xxx_import_energy_today_kwh') %} {% set export = states('sensor.givtcp_xxx_export_energy_today_kwh') %} {% if pv_xxx in ['unknown','unavailable'] or pv_yyy in ['unknown','unavailable'] or dis_xxx in ['unknown','unavailable'] or dis_yyy in ['unknown','unavailable'] or chg_xxx in ['unknown','unavailable'] or chg_yyy in ['unknown','unavailable'] or import in ['unknown','unavailable'] or export in ['unknown','unavailable'] %} {{ this.state }} {% else %} {% if now().hour == 0 and now().minute < 1 %} 0.0 {% else %} {% set load = (import | float(0) + pv_xxx | float(0) + pv_yyy | float(0) + dis_xxx | float(0) + dis_yyy | float(0) - export | float(0) - chg_xxx | float(0) - chg_yyy | float(0)) | round(2) %} {% set previous = this.state | float(0) %} {{ [load, previous] | max }} {% endif %} {% endif %} The template looks complex but it ensures that if any of the underlying sensors is unavailable, the load sensor returns the previous energy value, at midnight the sensor resets to zero properly, and during the day the sensor can only ever increase, never decrease. If you are using the LoadML feature of Predbat and have multiple inverters that share the load, you will similarly need to create a template load power sensor: # Home consumption power sensor, updated every 5 minutes instead of the default of every sensor state change - trigger: - platform: time_pattern minutes: \"/5\" sensor: - name: \"House Load Power\" unique_id: \"house_load_power\" unit_of_measurement: kW device_class: power state_class: measurement state: > {% set pv_xxx = states('sensor.givtcp_xxx_pv_power') %} {% set pv_yyy = states('sensor.givtcp2_yyy_pv_power') %} {% set bat_xxx = states('sensor.givtcp_xxx_battery_power') %} {% set bat_yyy = states('sensor.givtcp2_yyy_battery_power') %} {% set grid = states('sensor.givtcp_xxx_grid_power') %} {% if pv_xxx in ['unknown','unavailable'] or pv_yyy in ['unknown','unavailable'] or bat_xxx in ['unknown','unavailable'] or bat_yyy in ['unknown','unavailable'] or grid in ['unknown','unavailable'] %} {{ this.state }} {% else %} {{ (pv_xxx | float(0) + pv_yyy | float(0) + bat_xxx | float(0) + bat_yyy | float(0) - grid | float(0)) | round(2) }} {% endif %} If you have GivEnergy inverters and are using REST mode, then also set givtcp_rest_power_ignore to True in apps.yaml for both inverter so Predbat uses your custom power sensor (and not the inverter sensors via REST). GivEnergy Cloud Data If you have an issue with the GivTCP data, Predbat can get the required historical data from the GivEnergy cloud instead. This data is updated every 30 minutes. Connecting to the cloud is less efficient and means that Predbat will be dependent upon your internet connection and the GivEnergy cloud to operate. ge_cloud_data - When True Predbat will connect to the GivEnergy cloud rather than GivTCP sensors for historical load_today, import_today and export_today inverter data ge_cloud_serial - Set the inverter serial number to use for the cloud data ge_cloud_key - Set to your API Key for the GE Cloud (long string) If you need to create a ge_cloud_key, in the GivEnergy cloud portal: Click 'account settings' in the menu bar (icon of a person overlaid with a cogwheel) Click 'Manage Account Security' then 'Manage API Tokens' then 'Create API Token' Enter a name for the token e.g. 'Predbat' Select 'No expiry' for the token expiry duration, or choose a fixed duration but remember to create a new token before it expires as Predbat's access will stop once the token expires Ensure that 'api:inverter' is ticked Create token Finally, copy/paste the token created into ge_cloud_key within apps.yaml GivEnergy Cloud controls Experimental Predbat now supports GE Cloud controls directly from inside Predbat. When enabled Predbat will connect directly with the GE Cloud and expose the controls of your inverter inside home assistant. Note You will still have to configure apps.yaml to point to these controls. ge_cloud_direct - Set to True to enable GE Cloud direct access ge_cloud_key - Set to your API Key for the GE Cloud (long string) Load filtering By default, if Predbat sees a gap in the historical load data it will fill it with average data. This is to help in the cases of small amounts of lost data. For entire lost days you should change days_previous to point to different days(s) or include 3 or more days and if you set switch.predbat_load_filter_modal to true, the lowest day's historical load will be discarded. load_filter_threshold - Sets the number of minutes of zero load data to be considered a gap (that's filled with average data), the default is 30. To disable, set it to 1440. iBoost energy iboost_energy_today - Set to a sensor which tracks the amount of energy sent to your solar diverter, which can also be used to subtract from your historical load for more accurate predictions. Inverter control configurations inverter_limit One per inverter. Controls the way Predbat models your inverter, this does not change the way it is controlled. When set, it defines the maximum AC output power in watts for your inverter. This is used by Predbat in calculating the plan to emulate clipping that occurs in the inverter when your solar produces more than the inverter can handle, but it won't be that accurate as the source of the data isn't minute-by-minute. For a Hybrid inverter make sure the Hybrid Inverter toggle is on, you should set the inverter limit to be the maximum power of the inverter in Watts e.g. a 5kW inverter will have a limit of 5000. If you have a separate Micro Inverter for your PV then you should add its power to the inverter limit For an AC Coupled inverter make sure the Hybrid Inverter toggle is off and set this to the power of your AC Coupled inverter. Do not add on separate Micro Inverters to the total power. If you have multiple inverters then set the value of each one in a list format. NB: inverter_limit is ONLY used by Predbat to improve the quality of the plan, any solar clipping is done by the inverter and is not controlled by Predbat. export_limit One per inverter (optional). Controls the way Predbat models your inverter, this does not change the way it is controlled. When set defines the maximum watts of AC power your inverter can export to the grid at (e.g. 2500). This is used by Predbat in calculating the plan to emulate your inverter's software export limit setting that you will have if your G98/G99 approval was lower than your maximum inverter power (check your install information for details). If you do not set an export limit then it is assumed to be unlimited (and thus limited by your inverter or PV system). inverter_limit_charge and inverter_limit_discharge An optional list of values with one entry per inverter. e.g. inverter_limit_charge: - 4200 inverter_limit_discharge: - 3000 When set in Watts, overrides the maximum charge/discharge rate settings used when controlling the inverter. This can be used if you need Predbat to cap your inverter battery rate (e.g. due to grid import/export limitations or to charge overnight at a slower rate to reduce inverter/battery heating). By default Predbat will normally configure all timed charges or discharges to be at the inverter's maximum rate and these options enable you to reduce that maximum rate. Low rate charging could also be used to slow down Predbat's charge rate whilst still meeting the battery plan. inverter_can_charge_during_export Global setting, defaults to True. Controls the way Predbat models your inverter, this does not change the way it is controlled. During a force export period if the generated solar exceeds the inverter limit or the export limit then the inverter will scale back the export rate. If this setting is True then the inverter can end up charging the battery from PV while still in Force Export mode. If this setting if False then the inverter will not charge the battery and the excess PV will be lost. Controlling the Inverter There are a few different ways to control your inverter: Home Assistant entity controls (standard) GivTCP REST Interface (GivEnergy Inverters only) Service API MQTT API Home Assistant entity inverter control Predbat can control inverters by updating Home Assistant entities. The template apps.yaml for is pre-configured with regular expressions for many configuration items, but some of them may need updating to match your system. If you only have a single inverter then the second inverter lines can be commented out if so desired or left in place (as they are ignored). The givtcp_rest line should be commented out/deleted on anything but GivTCP REST mode. Charge/Discharge rate charge_rate - Battery charge rate entity in watts discharge_rate - Battery discharge rate entity in watts or charge_rate_percent - Battery charge rate entity in percent of maximum rate (0-100) discharge_rate_percent - Battery discharge max rate entity in percent of maximum rate (0-100) or timed_charge_current - Battery charge rate entity in amps timed_discharge_current - Battery discharge rate entity in amps Battery Information battery_voltage - Nominal maximum battery voltage (not current battery voltage) - only needed for inverters controlled via Amps and used internally by Predbat to convert Watts to Amps to control the inverter. battery_rate_max - Sets the maximum battery charge/discharge rate in watts (e.g. 6000). For GivEnergy inverters this can be determined from the inverter, but must be set for non-GivEnergy inverters or Predbat will default to 2600W. Predbat also uses battery_rate_max when creating charge and discharge curves , looking for charging or discharging at 95% of the max rate. Be careful of setting the rate at a value higher than your inverter can handle for grid charging in order for Predbat to be able to find the historical 'full rate' charging/discharging needed to correctly calculate the curves. soc_max - Entity name for the maximum charge level for the battery in kWh. If not set or set to 0, Predbat will attempt to automatically determine the battery size by analyzing historical charging data from soc_percent and battery_power sensors. This requires at least several days of historical data with charging periods of 15% or more SoC change. If automatic detection fails, you must manually set this value. battery_min_soc - When set limits the target SoC% setting for charge and discharge to a minimum percentage value reserve - sensor name for the reserve SoC % setting. The reserve SoC is the lower limit target % to discharge the battery down to. battery_temperature - Defined the temperature of the battery in degrees C (default is 20 if not set). Power Data Note this are not required for normal operation, only to produce power flow data or for battery curve calculations. One entry per inverter: battery_power - Current battery power in W or kW Battery power should be positive for discharge and negative for charge, if your sensor is the other way around then set battery_power_invert to True pv_power - Current PV power in W or kW load_power - Current load power in W or kW grid_power - Current grid power in W or kW Grid power should be negative for import and positive for export, if your sensor is the other way around then set grid_power_invert to True e.g: battery_power: - sensor.givtcp_{geserial}_battery_power battery_power_invert: - False grid_power: - sensor.givtcp_{geserial}_grid_power grid_power_invert: - False pv_power: - sensor.givtcp_{geserial}_pv_power load_power: - sensor.givtcp_{geserial}_load_power Battery SoC soc_kw - Entity name of the battery SoC in kWh, should be the inverter one not an individual battery or soc_percent Entity name of the battery SoC in percent of the maximum battery size, should be the inverter one not an individual battery Inverter Info inverter_reserve_max - When set defines the maximum reserve setting in % (default is 100) inverter_mode - Givenergy inverter mode control inverter_time - Inverter timestamp, used to track the last update of the inverter data inverter_battery_rate_min - Defines the minimum discharge/charge rate of the battery in watts (default is 0) Schedule charge_start_time - Battery charge start time entity - can be a HA select entity in format HH:MM or HH:MM:SS or a HA time entity. charge_end_time - Battery charge end time entity - can be a HA select entity in format HH:MM or HH:MM:SS or a HA time entity. discharge_start_time - Battery discharge start time, same format as charge_start_time. discharge_end_time - Battery discharge end time, same format as charge_end_time. charge_start_hour , charge_start_minute - Battery charge start time for inverters with separate hour and minute control entities. charge_end_hour , charge_end_minute - Ditto for battery charge end time. discharge_start_hour , discharge_start_minute - Ditto for battery discharge start time discharge_end_hour and discharge_end_minute - Ditto for battery discharge end time charge_time - Battery charge time entity for inverters that require a charge time expressed as a range in the format \" start hour : start minute - end hour : end minute \". discharge_time = Ditto battery discharge time expressed as a time range. charge_limit - Entity name for used to set the SoC target for the battery in percentage (AC charge target) scheduled_charge_enable - Switch to enable/disable battery charge according to the charge start/end times defined above. scheduled_discharge_enable - Switch to enable/disable battery discharge according to the discharge start/end times defined above. discharge_target_soc - Set the battery target percent for timed exports, will be written to minimum by Predbat. pause_mode - GivEnergy pause mode register (if present) pause_start_time - scheduled pause start time (only if supported by your inverter) pause_end_time - scheduled pause start time (only if supported by your inverter) idle_start_time - start time for idle (Eco) mode - for GivEnergy EMS idle_end_time - end time for idle (Eco) mode - for GivEnergy EMS If you are using REST control the configuration items should still be kept as not all controls work with REST. Some inverters require a \"button press\" to be triggered by Predbat to update the charge/discharge schedules in the inverter after the appropriate HA entities have been set. If your inverter features a combined charge/discharge update button, the charge_discharge_update_button can be set to the button name. e.g.: charge_discharge_update_button: - button.solis_charge_discharge If your inverter has separate buttons for setting charging and discharging schedules on the inverter, set both charge_update_button and discharge_update_button . e.g.: charge_update_button: - button.solis_charge discharge_update_button: - button.solis_discharge TIP: Some older GivEnergy inverters such as the Gen 1 hybrid and AC3 inverter that have had firmware upgrades to introduce battery pause functionality do not have sufficient memory on the inverter to provide control of battery pause start and end times. GivTCP does not recognise this and so still provides the select.givtcp_xxxx_battery_pause_start_time_slot and end_time_slot controls, but they do not work. Predbat can report an error trying to set them, or they revert back to 00:00:00 after being changed by Predbat and there will also be errors setting these controls reported in the GivTCP log. For these inverters the pause_start_time and pause_end_time entries should be commented out in apps.yaml to stop Predbat trying to use them. See section below on creating the battery charge power curve . REST Interface inverter control For GivEnergy inverters Predbat can control the inverter directly via REST instead of via the Home Assistant GivTCP inverter controls detailed above. When configured in apps.yaml , control communication from Predbat to GivTCP is via REST which bypasses some issues with MQTT. givtcp_rest - One entry per Inverter, sets the GivTCP REST API URL ( http://homeassistant.local:6345 is the normal address and port for the first inverter, and the same address but ending :6346 if you have a second inverter - if you don't have a second inverter (or if you have multiple AIO's that are controlled through the gateway), delete the second line. If you are using Docker then change 'homeassistant.local' to the Docker IP address. TIP: You can replace homeassistant.local with the IP address of your Home Assistant server if you have it set to a fixed IP address. This may improve reliability of the REST connection as it doesn't need to lookup the HA server IP address each time. To check your REST is working open up the readData API point in a Web browser e.g: http://homeassistant.local:6345/readData If you get a bunch of inverter information back then it's working! Note that Predbat will still retrieve inverter information via REST, this configuration only applies to how Predbat controls the inverter. givtcp_rest_power_ignore - Optional, defaults to False. When set to True for a given inverter, Predbat will use the configured sensor entities (load_power, pv_power, grid_power, battery_power) instead of reading power values from the GivTCP REST API. This can be useful if you want to use alternative sensors or if the REST API power readings are unreliable. Set this to False (or omit) to use REST API power readings (default behavior). Service API Some inverters have the Service API enabled, this allows the configuration to call an arbitrary Home Assistant service to start/stop charging and discharging charge_start_service - Should be set to a service that is called when charging starts charge_freeze_service - If your inverter supports charge freeze set to a service that starts this mode charge_stop_service - Should be set to a service that is called when charging/charge freeze stops discharge_start_service - Should be set to a service that is called when force export (discharge) starts discharge_freeze_service - If your inverter supports export freeze set to a service that starts this mode discharge_stop_service - Should be set to a service that is called when export/export freeze stops Services that are not configuration will not be called. Example service is below: charge_start_service: service: switch.turn_off entity_id: \"switch.sunsynk_inverter_use_timer\" See Service API for details. Note that device_id will be passed to the service automatically, or it can be set in apps.yaml . MQTT API Some Inverters are enabled with an MQTT API, in this case certain MQTT messages are send via the HA MQTT service. The mqtt_topic in apps.yaml set in the root of the MQTT topic (shown as topic below). Set reserve Called when the reserve (discharge-to %) is changed topic: topic /set/reserve payload: reserve Set target soc Called when the target (charge-to %) SoC is changed topic: topic /set/target_soc payload: soc Set charge rate Called to change the charge rate in Watts topic: topic /set/charge_rate payload: charge_rate Set discharge rate Called to change the discharge rate in Watts topic: topic /set/discharge_rate payload: discharge_rate Set charge Called when a charge is started topic: topic /set/charge payload: charge_rate Set discharge Called when a forced export (discharge) is started topic: topic /set/discharge payload: discharge_rate Set auto Called when a charge/discharge is cancelled and the inverter goes back to home demand mode. topic: topic /set/auto payload: true Solcast Solar Forecast As described in the Predbat installation instructions , Predbat needs a solar forecast in order to predict solar generation and battery charging which can be provided by the Solcast integration. By default, the template apps.yaml is pre-configured to use the Solcast forecast integration for Home Assistant. The apps.yaml contains regular expressions for the following configuration items that should auto-discover the Solcast forecast entity names. They are unlikely to need changing although a few people have reported their entity names don't contain 'solcast' so worth checking, or editing if you have non-standard names: pv_forecast_today - Entity name for today's Solcast forecast pv_forecast_tomorrow - Entity name for tomorrow's Solcast's forecast pv_forecast_d3 - Entity name for Solcast's forecast for the day after tomorrow pv_forecast_d4 - Entity name for Solcast's forecast for two days after tomorrow Sensors for d5, d6 & d7 are supported, but not that useful so are not pre-defined in the template. If you do not have a PV array then comment out or delete these Solcast lines from apps.yaml . Alternatively, Predbat can obtain the solar forecast directly from Solcast and the Solcast integration is thus not required. Uncomment the following Solcast cloud interface settings in apps.yaml and set the API key correctly: solcast_host: 'https://api.solcast.com.au/' solcast_api_key: 'xxxx' solcast_poll_hours: 8 NOTE: It's recommended to store solcast_api_key in secrets.yaml and reference it as solcast_api_key: !secret solcast_api_key - see Storing secrets . Note that by default the Solcast API will be used to download all sites (up to 2 for hobby accounts), if you want to override this set your sites manually using solcast_sites as an array of site IDs: solcast_sites: - 'xxxx' If you have more than 2 array orientations and thus more than one Solcast API key, enter each key in a list: solcast_api_key: - xxxx_API_key_1 - yyyy_API_key_2 Keep in mind hobbyist accounts only have 10 polls per day so you need to ensure that the solcast_poll_hours refresh period is set so that you do not exceed the 10 poll limit. If you have two arrays then each Solcast refresh will consume 2 polls so its suggested that you set solcast_poll_hours to 4.8 to maximise your polls over a 24 hour period (5 polls a day, 24/5=poll every 4.8 hours). If you use the same Solcast account for other automations the total polls need to be kept under the limit or you will experience failures. If you use the same Solcast account for other automations the poll frequency will need to be reduced to ensure the total polls is kept under your account daily poll limit or you will experience failures. If you have multiple PV arrays connected to hybrid inverters or you have AC-coupled inverters, then ensure your PV configuration in Solcast covers all arrays. If however, you have a mixed PV array setup with some PV that does not feed into the inverters that Predbat is managing (e.g. hybrid GE inverters with older firmware but a separate older FIT array that directly feeds AC into the house), then it's recommended that Solcast is only configured for the PV connected to the inverters that Predbat is managing. NB: Gen2, Gen3 and Gen1 hybrid inverters with the 'fast performance' firmware can charge their batteries from excess AC that would be exported, so for these inverters, you should configure Solcast with your total solar generation capability. Solcast produces 3 forecasted PV estimates, the 'central' (50% or most likely to occur) PV forecast, the '10%' (1 in 10 more cloud coverage 'worst case') PV forecast, and the '90%' (1 in 10 less cloud coverage 'best case') PV forecast. By default, Predbat will use the central (PV50) estimate and apply to it the input_number.predbat_pv_metric10_weight weighting of the 10% (worst case) estimate. You can thus adjust the metric10_weight to be more pessimistic about the solar forecast. Predbat models cloud coverage by using the difference between the PV and PV10 forecasts to work out a cloud factor, this modulates the PV output predictions up and down over the plan slot duration as if there were passing clouds. This can have an impact on planning, especially for things like freeze charging which could assume the PV will cover the house load but it might not due to clouds. pv_estimate in apps.yaml can be used to configure Predbat to always use the 10% forecast by setting the configuration item to '10', or '90' to always use the 90% PV estimate (not recommended!). Set to blank or delete / comment out the line to use the default central estimate. If pv_estimate is set to 10 then input_number.predbat_pv_metric10_weight in Home Assistant should be set to 1.0. See also PV configuration options in Home Assistant . Forecast.solar Solar Forecast The Forecast.solar service can also be used in Predbat, the free version offer access without an API Key but is limited to hourly data and does not provide any 10% or 90% data. Predbat Solar calibration can use past data to improve this information and provide the 10% data. You can create one or more rooftops by providing a list of the data for each one, they will be summed up automatically. The latitude and longitude are your location in world, or for the UK you can set a postcode. The azimuth is the direction of the roof: 0=North, -90=East, 90=West, -180/180 = South The declination is the angle of the panels, e.g. 45 for a sloped roof or 20 for those on a flat roof The efficiency relates to the aging of your panels, 0.95 is for newer systems but they will lose around 1% each year. The optional forecast_solar_max_age setting sets the number of hours between updates to PV data, the default is 8. forecast_solar: - postcode: SW1A 2AB kwp: 3 azimuth: 45 declination: 45 efficiency: 0.95 forecast_solar_max_age: 4 or you can set longitude and latitude if you are not in the UK or postcode does not work: latitude: 51.5072 longitude: -0.1276 Optionally you can set an api_key for personal or professional accounts and you can also set 'days' to define how many future days of data the forecast includes (2 for free, 3 for personal or 6 for professional) forecast_solar: - postcode: SW1A 2AB api_key: 'xxxxx' days: 3 Note you can omit any of these settings for a default value. They do not have to be exact if you use Predbat auto calibration for PV to improve the data quality. Energy Rates There are a number of configuration items in apps.yaml for telling Predbat what your import and export rates are. These are described in detail in Energy Rates and are listed here just for completeness: metric_octopus_import - Import rates from the Octopus Energy integration metric_octopus_export - Export rates from the Octopus Energy integration metric_octopus_gas - Gas rates from the Octopus Energy integration octopus_intelligent_slot - Octopus Intelligent GO slot sensor from the Octopus Energy integration octopus_saving_session - Energy saving sessions sensor from the Octopus Energy integration octopus_saving_session_octopoints_per_penny - Sets the Octopoints per pence rates_import_octopus_url - Octopus pricing URL (over-rides metric_octopus_import) rates_export_octopus_url - Octopus export pricing URL (over-rides metric_octopus_export) metric_standing_charge - Standing charge in pounds rates_import - Import rates over a 24-hour period with start and end times rates_export - Export rates over a 24-hour period with start and end times rates_gas - Gas rates over a 24-hour period with start and end times rates_import_override - Over-ride import rate for specific date and time range, e.g. Octopus Power-up events rates_export_override - Over-ride export rate for specific date and time range futurerate_url - URL of future energy market prices for Agile users futurerate_adjust_import and futurerate_adjust_export - Whether tomorrow's predicted import or export prices should be adjusted based on market prices or not futurerate_peak_start and futurerate_peak_end - start/end times for peak-rate adjustment carbon_postcode - Postcode to retrieve Carbon intensity grid information for carbon_automatic - Retrieve Carbon intensity information automatically based upon postcode carbon_intensity - Carbon intensity of the grid in half-hour slots from an integration. octopus_api_key - Sets API key to communicate directly with octopus. Recommended: store in secrets.yaml and use !secret octopus_api_key octopus_account - Sets Octopus account number axle_api_key - API key to communicate with Axle Energy VPP (Virtual Power Plant) service. Recommended: store in secrets.yaml and use !secret axle_api_key axle_pence_per_kwh - Payment rate in pence per kWh for Axle Energy VPP events (default: 100) axle_automatic - Optional, whether to use the default entity name binary_sensor.predbat_axle_event for axle event details (default True, use the default entity name) axle_session - Optional, enables manual override of the Axle event entity name axle_control - Optional, whether to switch Predbat to read-only mode during active Axle VPP events (default: False) plan_interval_minutes - Sets time duration of the slots used by Predbat for planning Note that gas rates are only required if you have a gas boiler, and an iBoost, and are using Predbat to determine whether it's cheaper to heat your hot water with the iBoost or via gas Energy Comparison You can configure in apps.yaml a compare_list section to define a list of Energy tariffs for Predbat to compare based on your predicted load and solar generation. See the Predbat Compare feature for details of how to define the tariffs to be compared. Car Charging Integration Predbat can include electric vehicle charging in its plan and manage the battery activity so that the battery isn't discharged into your car when the car is charging (although you can override this if you wish by setting the switch.predbat_car_charging_from_battery to True in Home Assistant). Details of configuring apps.yaml for EV charging are described in Configure apps.yaml for your car charging , and a list of these configuration items is included below for completeness: num_cars number of cars you want Predbat to plan for car_charging_exclusive for multiple EV's to indicate if they can be charged independently or not car_charging_energy - Energy consumed by your EV charger octopus_intelligent_slot - Octopus Energy integration 'intelligent dispatching' sensor that indicates whether you are within an Octopus Energy \"smart charge\" slot octopus_ready_time - Octopus Energy integration sensor for when the car charging will be completed by octopus_charge_limit - Octopus Energy integration sensor for car charging limit octopus_slot_low_rate - Whether Octopus Intelligent Slots reported will be at the lowest rate if at home octopus_slot_max - Maximum number of 30-minute cheap rate slots per 24-hour period car_charging_planned - Indicates when your EV is plugged in and planned to charge during low-rate slots. car_charging_planned_response - Values for the car_charging_planned sensor that indicate that the car is plugged in and will charge in the next low rate slot. car_charging_now - Sensor to indicate when the EV is charging car_charging_now_response - Responses for car_charging_now to indicate that the car is charging car_charging_battery_size - Car battery size in kWh car_charging_limit - Percentage limit the car is set to charge to car_charging_soc - Car's current charge level expressed as a percentage ohme_login - Ohme EV charger account login ohme_password - Password for above Ohme account ohme_automatic_octopus_intelligent - Controls whether Predbat talks directly to the above Ohme account Watch List - automatically start Predbat execution By default Predbat will run automatically every 5 minute and to execute the plan, and re-evaluate the plan automatically every 10 minutes. You can manually force Predbat to start executing by turning switch.predbat_active on - see Predbat's output data . Additionally Predbat can 'watch' a number of Home Assistant entities and if one of those changes, Predbat will automatically start executing. This can be useful for EV owners such as to detect when you have plugged the EV in (for Predbat to stop the battery discharging), and with Intelligent Octopus Go if Octopus gives you additional charge slots. In apps.yaml , uncomment (or add) the following lines, customising to the list of configuration items you have setup in apps.yaml and want Predbat to watch for changes for: watch_list: - '{octopus_intelligent_slot}' - '{octopus_ready_time}' - '{octopus_charge_limit}' - '{octopus_saving_session}' - '+[car_charging_planned]' - '+[car_charging_soc]' - '{car_charging_now}' Note the notation for watch_list, a single value apps.yaml configuration item such as octopus_intelligent_slot is surrounded by curly bracket parenthesis {}, but for apps.yaml configuration items that can be a list such as car_charging_soc they are surrounded by +[ and ]. Load Forecast In addition to the historical house load data that Predbat uses by default, you can optionally provide a forecast of future load such as is produced by Predheat for Hot water and Heat Pump heating systems or via Predai load_forecast - this should be configured to point to a sensor and attribute. The attribute must be in either The format of 'last_updated' timestamp and 'energy' in incrementing kWh. The format of a dictionary of timestamps and energy data in incremental KWh. For example: Or apps.yaml should be configured to point to the forecast sensor and attribute (in the above formats) like this: load_forecast: - sensor_name$attribute_name So if using Predheat it would be configured as: load_forecast: - predheat.heat_energy$external Set load_forecast_only to True if you do not wish to use the Predbat forecast but instead want to use this as your only forecast data e.g using PredAi: load_forecast_only: True load_forecast: - sensor.givtcp_{geserial}_load_energy_today_kwh_prediction$results Balance Inverters When you have two or more inverters it's possible they get out of sync so they are at different charge levels or they start to cross-charge (one discharges into another). When enabled, balance inverters try to recover this situation by disabling either charging or discharging from one of the batteries until they re-align. Most of the Predbat configuration for balancing inverters is through a number of Home Assistant controls for Balancing Inverters , but there is one configuration item in apps.yaml : balance_inverters_seconds: seconds Defines how often to run the inverter balancing, 30 seconds is recommended if your machine is fast enough, but the default is 60 seconds. Workarounds There are a number of different configuration items in apps.yaml that can be used to tweak the way Predbat operates and workaround weirdness you may have from your inverter and battery setup. Base load Sometimes the load predictions can yield near zero data due to inaccuracy of data (e.g. a second PV system not tracked, car data being unreliable, poor sensors). In order to not get unrealistically low values you can set a base load value (in watts) which Predbat will use as a minimum load for a slot duration. To set a base load set base_load as an integer value in watts. base_load: 300 The above example load forecasts will now not fall below 300 watts which would be 0.15 kWh in a (default) 30-minute period. Clock skew clock_skew: minutes Skews the local (computer) time that Predbat uses (from the computer that Predbat is running on). Set to 1 means add a minute to the Predbat computer time, set to -1 means take a minute off the Predbat computer time. This clock adjustment will be used by Predbat when real-time actions happen e.g. triggering a charge or discharge. If your inverter's time is different to the time on the computer running Home Assistant, you may need to skew the time settings made on the inverter when you trigger charging or discharging. Again 1 means the inverter is 1 minute fast and -1 means the inverter is 1 minute slow. Separate start and end options are applied to the start and end time windows, mostly as you want to start battery activity late (not early) and finish early (not late). You can adjust the charge and discharge times written to the inverter by setting the following in apps.yaml : inverter_clock_skew_start: minutes inverter_clock_skew_end: minutes Skews the setting of the charge slot registers vs the predicted start time inverter_clock_skew_discharge_start: minutes inverter_clock_skew_discharge_end: minutes Skews the setting of the discharge slot registers vs the predicted start time Battery size scaling battery_scaling: - scale Default value 1.0. Multiple battery size scales can be entered, one per inverter on separate lines. This setting is used to scale the battery-reported SoC kWh to make it appear bigger or larger than it is. As the GivEnergy inverters treat all batteries attached to an inverter as in effect one giant battery, if you have multiple batteries on an inverter that need scaling you should enter a composite scaling value for all batteries attached to the inverter. TIP: If you have a GivEnergy 2.6 or 5.2kWh battery then it will have an 80% depth of discharge but it will falsely report its capacity as being the 100% size, so set battery_scaling to 0.8 to report the correct usable capacity figure to Predbat. TIP: Likewise, if you have one or multiple GivEnergy All-in-Ones (AIOs), it will incorrectly report the 13.5kWh usable capacity of each AIO as 15.9kWh, so set battery_scaling to 0.85 to correct this. If you are going to chart your battery SoC in Home Assistant then you may want to use predbat.soc_kw_h0 as your current SoC (as this will be scaled) rather than the usual givtcp_SERIAL_NUMBER_soc GivTCP entity so everything lines up. Import export scaling import_export_scaling: scale Default value 1.0. Used to scale the import & export kWh data from GivTCP if the inverter information is incorrect. Inverter rate minimum inverter_battery_rate_min: watts One per inverter (optional), set in Watts, when set models a \"bug\" in the inverter firmware in some models where if charge or discharge rates are set to 0 you actually get a small amount of charge or discharge. The recommended setting is 200 for Gen 1 hybrids with this issue. Inverter reserve maximum inverter_reserve_max: percent Global, sets the maximum reserve % that may be set to the inverter, the default is 98, as some Gen 2 & Gen 3 inverters and AIO firmware versions refuse to be set to 100. Comment the line out or set it to 100 if your inverter allows setting it to 100%. Savings Max Charge Slots Every day Predbat calculates the financial savings you have made by running Predbat vs not using Predbat to automate your battery activity. The are calculated by default by comparing Predbat's activity to you having one fixed nightly charge slot set to charge at the lowest import rate with a target of 100%. You can change the number of simulated charge slots for this comparison by setting: calculate_savings_max_charge_slots: 1 If set to 0 then Demand (Eco) mode will be used as the baseline, or if non-zero then the maximum number of charging slots can be set (e.g. 2). Automatic restarts If the app that is providing the inverter control stops functioning it can prevent Predbat from functioning correctly. In this case, you can tell Predbat how to restart the app using a service. Right now only communication loss with GE inverters is detectable but in the future other systems will be supported. When enabled if communication is lost then the service configured will be triggered and can cause a restart which may restart the connection. This may be useful with GivTCP if you have time sync errors or lose the REST service every now and again. The auto_restart itself is a list of commands to run to trigger a restart. The shell command will call a 'sh' shell and can be used to delete files and suchlike. The service command is used to call a service and can contain arguments of addon and/or entity_id . The configuration below is for GivTCP v3. auto_restart: - shell: 'rm -rf /homeassistant/GivTCP/*.pkl' - service: hassio/addon_restart addon: 533ea71a_givtcp NB: If you are running GivTCP v2 then the line '533ea71a_givtcp' must be replaced with 'a6a2857d_givtcp' as the slug-id (Home Assistant app identifier) is different between GivTCP v2 and v3. Battery charge/discharge curves Some batteries tail off their charge rate at high SoC% or their discharge rate at low SoC%, and these optional configuration items enable you to model this tail-off in Predbat. Note that the charge/discharge curves only affect the accuracy of the charging/discharging model Predbat applies in the forward battery plan, Predbat will still instruct the inverter to charge/discharge at full rate regardless of the charging curve so not having these curves only has an impact on plan accuracy. If you know the battery charge or discharge curves (e.g. manufacturer info or your own testing) then you can manually configure this in apps.yaml , or Predbat can calculate the curves based on historical inverter charging/discharging data in Home Assistant. If the battery has not recently been fully charged or fully discharged at a charge/discharge rate that is at least 95% of your maximum charge/discharge rate then Predbat will not be able to calculate the curves and you'll get a warning in the logfile. For some inverters you may not be able to practically charge/discharge at full rates so you'll keep getting the curve warning every time Predbat starts. Simply create dummy curves to stop this warning, e.g: battery_charge_power_curve: 100 : 1.0 battery_discharge_power_curve: 1 : 1.0 battery_charge_power_curve - This optional configuration item enables you to model in Predbat a tail-off in charging at high SoC%. Enter the charging curve as a series of steps of % of max charge rate for each SoC percentage. The percentage steps can either be expressed as an integer number (e.g. 97) or as a string (e.g. \"97\"); the Percent symbol is not required (see example curve below). The default is 1.0 (full power) charge to 100%. Modelling the charge curve becomes important if you have limited charging slots (e.g. only a few hours a night) or you wish to make accurate use of the low power charging mode ( switch.predbat_set_charge_low_power ). If the battery_charge_power_curve option is not set in apps.yaml and Predbat performs an initial run (e.g. due to restarting the Predbat/AppDaemon app, or an edit being made to apps.yaml ), then Predbat will automatically calculate the charging curve for you from historical battery charging information. You should look at the Predbat logfile to find the predicted battery charging curve and copy/paste it into your apps.yaml file. The logfile will also include a recommendation for how to set your battery_rate_max_scaling setting in HA. The YouTube video charging curve and low power charging explains how the curve works and shows how Predbat automatically creates it. Setting this option to auto will cause the computed curve to be stored and used automatically. This is not recommended if you use low power charging mode as your history will eventually not contain any full power charging data to compute the curve, so in this case it's best to manually configure the charge curve in apps.yaml . NB: For Predbat to calculate your charging curve it needs to have access to historical Home Assistant data for status , battery_charge_rate , battery_power and soc_percent or soc_kw . These must be configured in apps.yaml to point to Home Assistant entities that have appropriate history data for your inverter/battery. Either soc_percent or soc_kw from apps.yaml can be used to generate the charge curve. If both are defined then soc_percent is used in preference. Predbat will search through the charge history of your inverter, looking for periods of where Predbat status is Charging, battery_charge_rate is at least 95% of the maximum inverter battery charge rate, and the battery charges to above 85% SoC. From the corresponding battery_power readings, Predbat determines the charge curve. If suitable charge history cannot be found then Predbat will report that it cannot create the charge curve. If you have a GivEnergy inverter and are using the recommended default REST mode to control your inverter then you will need to uncomment out the following entries in apps.yaml : charge_rate: - number.givtcp_{geserial}_battery_charge_rate battery_power: - sensor.givtcp_{geserial}_battery_power soc_kw: - sensor.givtcp_{geserial}_soc_kwh Example charging curve from a GivEnergy 9.5kWh battery with the latest firmware and Gen 1 inverter: battery_charge_power_curve: 91 : 0.91 92 : 0.81 93 : 0.71 94 : 0.62 95 : 0.52 96 : 0.43 97 : 0.33 98 : 0.24 99 : 0.24 100 : 0.24 battery_discharge_power_curve - This optional configuration item enables you to model in Predbat a tail-off in discharging at low SoC%. Enter the discharging curve as a series of steps of % of max discharge rate for each SoC percentage. The default is 1.0 (full power) discharge to 0%. If the battery_discharge_power_curve option is not set in apps.yaml and Predbat performs an initial run (e.g. due to restarting the Predbat/AppDaemon app, or an edit being made to apps.yaml ), then Predbat will automatically calculate the discharging curve for you from historical battery discharging information. You should look at the Predbat logfile to find the predicted battery discharging curve and copy/paste it into your apps.yaml file. Setting This option to auto will cause the computed curve to be stored and used automatically. This may not work very well if you don't do regular discharges to empty the battery. In the same way, as for the battery charge curve above, Predbat needs to have access to historical Home Assistant data for status , battery_discharge_rate , battery_power and soc_percent or soc_kw . These must be configured in apps.yaml to point to Home Assistant entities that have appropriate history data for your inverter/battery. Either soc_percent or soc_kw from apps.yaml can be used to generate the discharge curve. If both are defined then soc_percent is used in preference. Predbat will search through the discharge history of your inverter, looking for periods of where Predbat status is Exporting or Discharging, battery_discharge_rate is at least 95% of the maximum inverter battery discharge rate, and the battery discharges down below 20% SoC. From the corresponding battery_power readings, Predbat determines the discharge curve. If suitable discharge history cannot be found then Predbat will report that it cannot create the discharge curve. If you are using REST mode to control your GivEnergy inverter then the following entries in apps.yaml will need to be uncommented : discharge_rate: - number.givtcp_{geserial}_battery_discharge_rate battery_power: - sensor.givtcp_{geserial}_battery_power soc_kw: - sensor.givtcp_{geserial}_soc_kwh battery_charge_power_curve_default - This optional configuration item provides a fallback charging curve when Predbat cannot auto-detect the curve from your inverter. This is useful when: Your inverter doesn't provide historical charging data needed for auto-detection You've recently installed Predbat and don't have sufficient historical data yet Auto-detection fails but you know your battery's charging characteristics The default curve is only used if: You have not manually configured battery_charge_power_curve (i.e., it is not set, or is set to \"auto\" ) Auto-detection from inverter history fails or returns no curve Precedence: If you manually configure battery_charge_power_curve (with any value other than \"auto\" ), it will be used exclusively and neither auto-detection nor the default will be considered. Only if battery_charge_power_curve is set to \"auto\" or not configured at all will the system attempt auto-detection, with the default as a fallback if auto-detection fails. Example: battery_charge_power_curve_default: 91 : 0.91 92 : 0.81 93 : 0.71 94 : 0.62 95 : 0.52 96 : 0.43 97 : 0.33 98 : 0.24 99 : 0.24 100 : 0.24 battery_discharge_power_curve_default - This optional configuration item provides a fallback discharging curve when Predbat cannot auto-detect the curve from your inverter. Similar to the charge curve default above, this is used as a fallback, but only if you have not manually configured battery_discharge_power_curve (or have set it to \"auto\" ). Precedence: If you manually configure battery_discharge_power_curve , it takes absolute precedence and is always used. Only if battery_discharge_power_curve is set to \"auto\" or not configured at all will Predbat attempt to auto-detect the curve from inverter history; if that fails, the default battery_discharge_power_curve_default is used as a fallback. Example: battery_discharge_power_curve_default: 10 : 0.85 9 : 0.75 8 : 0.65 7 : 0.55 6 : 0.45 5 : 0.35 4 : 0.25 3 : 0.15 2 : 0.10 1 : 0.05 Battery temperature curves Your battery's maximum charge and discharge rate can be impacted by cold weather, Predbat can predict this if you provide a temperature sensor and define a curve. You must make sure battery_temperature is defined (one per inverter). Set battery_temperature_history to a sensor with history, this will be used to predict future temperatures based on past changes Set battery_temperature_charge_curve to define the maximum charge rate in C which is a percentage of your battery capacity. Set battery_temperature_discharge_curve to define the maximum discharge rate in C which is a percentage of your battery capacity. An example for GivEnergy Gen2 battery is below. Note You must adjust the curve for your system. gaps in the curve above 20 will use 20 degrees, and gaps below 0 will use 0 degrees. Do not leave gaps in the curve between 20 and 0. # Battery temperature charge adjustment curve # Specific in C which is a multiple of the battery capacity # e.g. 0.33 C is 33% of the battery capacity # values unspecified will be assumed to be 1.0 hence rate is capped by the max charge rate battery_temperature_history: sensor.givtcp_battery_stack_1_bms_temperature battery_temperature_charge_curve: 20: 0.50 19: 0.33 18: 0.33 17: 0.33 16: 0.33 15: 0.33 14: 0.33 13: 0.33 12: 0.33 11: 0.33 10: 0.25 9: 0.25 8: 0.25 7: 0.25 6: 0.25 5: 0.25 4: 0.25 3: 0.25 2: 0.25 1: 0.15 0: 0.00 Weather Alert System Predbat can take data directly from the Meteo-Alarm feed and use it to trigger keeping your battery charged so you have power in the event of a power cut. Please look at the Meteo Alarm for more details. The apps.yaml must be configured to select the URL for your country and the events you want Predbat to retain your battery level for.`` # Alert feeds - customise to your country, the alert types, severity and keep value # Customise to your needs, delete the ones you don't want to trigger on - e.g. remove Amber, Moderate and Possible. alerts: url: \"https://feeds.meteoalarm.org/feeds/meteoalarm-legacy-atom-united-kingdom\" event: \"(Amber|Yellow|Orange|Red).*(Wind|Snow|Fog|Rain|Thunderstorm|Avalanche|Frost|Heat|Coastal event|Flood|Forestfire|Ice|Low temperature|Storm|Tornado|Tsunami|Volcano|Wildfire)\" severity: \"Moderate|Severe|Extreme\" certainty: \"Possible|Likely|Expected\" keep: 40 The event severity and certainty are all regular expressions and can be set to one or multiple values using regular expression syntax. Any unset values are ignored. Your location (from Home Assistant) is used to filter alerts that apply only to your area. If this does not work or if you want to change the location, you can also set latitude and longitude in the alerts section of the apps.yaml . Events that match the given criteria will try to keep your battery at the percentage level specified by keep (default 100%) during the entire event period. This works by using a much stronger version of best_soc_keep but only for that time period. Your Predbat status will also have [Alert] in it during the alert time period and the triangle alert symbol will show on your HTML plan for the time period of the alert. Predbat records details of any weather alerts in the entity sensor.predbat_alertfeed_status which has a state value of the textual description of the alert. The entity has two attributes: keep - set to the SoC keep percentage figure specified in apps.yaml (or the default 100) during the alert time period so can be used in an automation trigger if you want to take additional actions in Home Assistant alerts - set to a list of dictionaries of details of any current or future alert events that match your alert criteria in apps.yaml . Each list entry contains event severity, certainty, urgency, area, time period, title, etc. Triggers export_triggers - The export trigger feature is useful to help trigger your own automation based on Predbat predicting in the plan that you will have spare solar energy that would be exported - this could happen if the battery is full or there is more predicted solar generation than can be charged into the battery. You can use the trigger in an automation, for example, you could turn on an immersion heater or the washing machine to consume the excess solar power. The triggers count export energy until the next active charge slot only. For each trigger give a name, the minutes of export needed, and the energy required in that time. Multiple triggers can be enabled by Predbat at once so in total you could use too much energy if multiple triggered automations all run. Each trigger specified in apps.yaml will create a Home Assistant entity called 'binary_sensor.predbat_export_trigger_ name ' which will be turned on when the predicted trigger conditions are valid. Connect this binary sensor to your automation to start whatever you want to trigger. Set the name for each trigger, the number of minutes of solar export you need, and the amount of energy in kWh you will need available during that period in apps.yaml: For example: export_triggers: - name: \"large\" minutes: 60 energy: 1.0 - name: \"small\" minutes: 15 energy: 0.25 Note: Predbat will set an export trigger to True if in the plan it predicts that there will be more than the specified amount of excess solar energy over the specified time. In the example above, the 'large' trigger will be set to True for the 1-hour period where Predbat predicts that there will be a total of 1kWh of excess solar generation over that period . For clarity the trigger is not set based on actual excess solar generation or export. It should also be recognised that this prediction could be wrong; there could be less solar generation or more house load than was predicted in the plan. If you wish to trigger activities based on Predbat charging or discharging the battery rather than spare solar energy you can instead use the following binary sensors in Home Assistant: binary_sensor.predbat_charging - Will be True when the home battery is inside a charge slot (either being charged or being held at a level). Note that this does include charge freeze slots where the discharge rate is set to zero without charging the battery. binary_sensor.predbat_exporting - Will be True when the home battery is inside a force discharge slot. This does not include discharge freeze slots where the charge rate is set to zero to export excess solar only. Understanding how days_previous works As described earlier, days_previous is a list of the previous days of historical house load that are averaged together to predict your future daily load. e.g., if you want the average of the same day for the last 2 weeks: days_previous: - 7 - 14 This section describes in more detail how days_previous is used by Predbat in creating the future battery plan, and gives some worked examples and a 'gotcha' to be aware of. When Predbat forecasts future home demand it counts backwards the days_previous number of days to find the appropriate historical home consumption. This is best explained through a worked example: In this example, days_previous is set to use history from 2 days ago: days_previous: - 2 If right now today it's Monday 3:15pm and Predbat is predicting the forward plan for the next 48 hours: For tomorrow's (Tuesday) 9am slot, Predbat will look backwards 2 days from Tuesday so will use the historical home consumption from Sunday 9am as being the predicted load for Tuesday 9am. For the day after (Wednesday) 9am slot, Predbat again looks backwards 2 days from that day, so will use historical home consumption from Monday 9am as being the Wednesday 9am prediction. This pattern of counting backwards days_previous days to find the appropriate time slot to load historical home consumption from requires Predbat to operate some additional special processing if days_previous is set to a low value or forecast_hours to a high value. Extending the previous example but this time days_previous is set to use history from just the previous day: days_previous: - 1 Today it's still Monday 3:15pm and Predbat is predicting the forward plan for the next 48 hours: For tomorrow's (Tuesday) 9am slot, Predbat will look backwards 1 day from Tuesday so will use the historical home consumption from today's (Monday) 9am as being the predicted load for Tuesday 9am. For the day after (Wednesday) 9am slot, Predbat again looks backwards 1 day from that day, so looks for historical home consumption from Tuesday 9am as being the Wednesday 9am prediction, but of course, it's still Monday, and Tuesday hasn't happened yet so we can't know what that historical consumption was! What Predbat does in this circumstance is to subtract a further day from days_previous and for Wednesday 9am's prediction, it will therefore use the historical load from Monday 9am. This issue of finding future historical load only occurs when days_previous is set to 1 and Predbat is forecasting more than 24 hours from 'now'. So to highlight this with some edge cases, today is still Monday 3:15pm, days_previous is still set to '1' and in the forward plan: For tomorrow's (Tuesday) 2:30pm slot, Predbat looks backwards 1 day from Tuesday and takes the historical home consumption from today's (Monday) 2:30pm slot. For tomorrow's (Tuesday) 3:00pm slot, Predbat looks backwards 1 day and takes the historical load from today's (Monday) 3:00pm slot - which we are only part way through so only 15 minutes of load will be predicted for tomorrow 3pm. For tomorrow's (Tuesday) 3:30pm slot, Predbat looks backwards 1 day but the 3:30pm slot today hasn't yet occurred so Predbat will take the historical load from the prior day and has to use Sunday's 3:30pm load for tomorrow's prediction. Ditto the predicted load for tomorrow's (Tuesday) 4:00pm slot comes from Sunday 4pm. As today rolls forward and Predbat keeps on updating the forward plan each time it runs, the prediction will be updated with the correct previous_day history as and when it exists. It's recommended therefore that days_previous isn't set to 1, or if it is, that you understand the way this has to work and the consequences. If you want to set days_previous to take an average of the house load over all the days of the last week it's suggested that it be set as: days_previous: - 2 - 3 - 4 - 5 - 6 - 7 - 8","title":"apps.yaml settings"},{"location":"apps-yaml/#appsyaml-settings","text":"The basic Predbat configuration is defined in the apps.yaml file. Depending on how you installed Predbat the apps.yaml file will be held in one of three different directories in Home Assistant: if you have used the Predbat app installation method , apps.yaml will be in the directory /addon_configs/6adb4f0d_predbat , with the HACS, Appdaemon app then Predbat installation method , it's in /config/appdaemon/apps/batpred/config/ , or if the combined AppDaemon/Predbat app installation method was used, it's in /addon_configs/46f69597_appdaemon-predbat/apps . You will need to use a file editor within Home Assistant (e.g. either the File editor or Studio Code Server apps) to edit the apps.yaml file - see editing configuration files within Home Assistant if you need to install an editor. This section of the documentation describes what the different configuration items in apps.yaml do. When you edit apps.yaml , the change will automatically be detected and Predbat will be reloaded with the updated file. You don't need to restart the Predbat or AppDaemon app for your edits to take effect.","title":"apps.yaml settings"},{"location":"apps-yaml/#warning-appsyaml-file-format","text":"When editing the apps.yaml file you must ensure that the file remains correctly formatted. YAML files are especially finicky about how the file contents are indented and it's very easy to end up with an incorrectly formatted file that will cause problems for Predbat. The YAML Basics from This Smart Home is a good introduction video to how YAML should be correctly structured but as a brief introduction: At the start of the apps.yaml file is the predbat module definition: pred_bat: module: predbat class: PredBat YAML can be thought of as a tree structure with 'pred_bat' at the top of the tree and everything else, e.g. 'module' and 'class' being children of the pred_bat tree. Each child entry must be indented by two spaces under the parent it follows, so 'module' and 'class' are thus children of 'pred_bat'. The YAML file consists of configuration item, a colon, and then the configuration value, for example, timezone is a child configuration item under the over-arching 'pred_bat' parent: timezone: Europe/London If the configuration item is a list of values, each of the list values appears on a new line, indented by a further two spaces, a dash, and then the value. For example, car_charging_response is a child of 'pred_bat' and consists of two values, 'yes' and 'no': car_charging_now_response: - 'yes' - 'on' Child entries can have children of their own, so for example rates_import_override is a child of the overarching 'pred_bat', and it has children configuration items of its own being 'start', 'end' and 'rate': rates_import_override: - start: '13:00:00' end: '14:00:00' rate: 0 The indentation of children being two spaces indented from their parents and there being two spaces before the dash are especially critical. It's easy to mis-edit and have one or three spaces which isn't valid YAML. NB: the sequence of entries in apps.yaml doesn't matter, as long as the YAML itself is structured correctly you can move things and edit things anywhere in the file.","title":"Warning! apps.yaml file format"},{"location":"apps-yaml/#templates","text":"You can find template configurations in the following location: https://github.com/springfall2008/batpred/tree/main/templates The GivEnergy GivTCP template will be installed by default but if you are using another inverter please copy the correct template for your inverter into the directory where your apps.yaml is stored, replacing the existing apps.yaml file, and modify it from there. Please read Inverter Setup for inverter control software and details of setting apps.yaml for non-GivEnergy inverters","title":"Templates"},{"location":"apps-yaml/#checking-your-appsyaml","text":"Syntax errors will be highlighted by the Home Assistant editor or via other YAML-aware editors such as VSCode. Once you have completed your apps.yaml and started Predbat you may want to open the Predbat Web Interface and click on 'apps.yaml'. Review any items shown in a red background as those do not match (it's okay for a 2nd inverter not to match if you only have one configured). Regular expressions that do not match can be ignored if you are not supporting that feature (e.g. Car SoC if you don't have a car). As an example these do not match and are shown in the web interface in red, I'm ignoring them as I only have one inverter and I'm using the Predbat internal Solcast rather than the external integration:","title":"Checking your apps.yaml"},{"location":"apps-yaml/#storing-secrets","text":"Predbat supports the Home Assistant secrets mechanism for storing sensitive information like API keys, passwords, and tokens.","title":"Storing secrets"},{"location":"apps-yaml/#using-secretsyaml","text":"Create a secrets.yaml file in one of these locations (checked in order, only the first one is read): Path specified in PREDBAT_SECRETS_FILE environment variable secrets.yaml in the same directory as your apps.yaml /homeassistant/secrets.yaml (standard Home Assistant location) The secrets.yaml file contains key-value pairs of your secrets, e.g.: octopus_api_key: \"sk_live_abc123xyz...\" solcast_api_key: \"def456uvw...\"","title":"Using secrets.yaml"},{"location":"apps-yaml/#referencing-secrets-in-appsyaml","text":"Use the !secret tag followed by the secret key name in your apps.yaml . You only need to enter the keys you are using: pred_bat: module: predbat class: PredBat ha_key: !secret ha_key # Home Assistant Long-Lived Access Token octopus_api_key: !secret octopus_api_key # Octopus API key (if using Octopus direct) solcast_api_key: !secret solcast_api_key # Solcast API key (if using Solcast direct) forecast_solar_api_key: !secret forecast_solar_api_key # Forecast.solar API key (if using Forecast.solar) ge_cloud_key: !secret ge_cloud_key # GivEnergy API key (if using GE Cloud) fox_key: !secret fox_key # Fox ESS API key and username (if using Fox Cloud) axle_api_key: !secret axle_api_key # Axle API key (if using Axle VPP) When Predbat loads, it will automatically replace !secret octopus_api_key with the actual value from secrets.yaml . If a secret is referenced in apps.yaml but not found in secrets.yaml , Predbat will log a warning and the configuration item will be set to None .","title":"Referencing secrets in apps.yaml"},{"location":"apps-yaml/#benefits-of-using-secrets","text":"Keeps sensitive information separate from configuration files Makes it safer to share your apps.yaml for troubleshooting All secrets stored in one centralized location Compatible with Home Assistant's secrets system","title":"Benefits of using secrets"},{"location":"apps-yaml/#basics","text":"Basic configuration items","title":"Basics"},{"location":"apps-yaml/#prefix","text":"Set to the prefix name to be used for all entities that Predbat creates in Home Assistant. Default 'predbat'. Unlikely that you will need to change this. prefix: predbat","title":"prefix"},{"location":"apps-yaml/#timezone","text":"Set to your local timezone, the default is Europe/London. It must be set to a valid Python time zone for your location timezone: Europe/London","title":"timezone"},{"location":"apps-yaml/#currency_symbols","text":"Sets your symbol to use for your main currency e.g. \u00a3, \u20ac or $ and for 1/100th unit e.g. p or c. You must define both currency_symbol entries. currency_symbols: - '\u00a3' - 'p'","title":"currency_symbols"},{"location":"apps-yaml/#template","text":"Initially set to True, this is used to stop Predbat from operating until you have finished configuring your apps.yaml . Once you have made all other required changes to apps.yaml this line should be deleted or commented out: template: True","title":"template"},{"location":"apps-yaml/#home-assistant-connection","text":"Predbat can speak directly to Home Assistant rather than going via AppDaemon. If you are using a standard Predbat app then this will be automatic and you should normally not need to set this. If you find you get issues where Predbat cannot communicate with Home Assistant after running for a long period of time and you get web socket errors, then creating a HA access key as described below can resolve this. If you run Predbat in a Docker container then you will need to set the URL or IP address of Home Assistant and an access key. The access key is a long-lived security access token you can create inside Home Assistant: Click on your user initials (bottom left) in HA; Click the Security tab Scroll to the bottom of the security screen and under 'Long-lived Access tokens', click 'Create Token' then copy the generated access token into ha_key in apps.yaml Currently, if this communication is not established Predbat will fall back to AppDaemon, however, some users have experienced failures due to a 10-second timeout set by AppDaemon. In future versions of Predbat, AppDaemon will be removed. ha_url: 'http://homeassistant.local:8123' ha_key: 'xxxxxxxxxxx' NOTE: It's recommended to store ha_key in secrets.yaml and reference it as ha_key: !secret ha_key - see Storing secrets . TIP: You can replace homeassistant.local with the IP address of your Home Assistant server if you have it set to a fixed IP address. This will remove the need for a DNS lookup of the IP address every time Predbat talks to Home Assistant and may improve reliability as a result.","title":"Home Assistant connection"},{"location":"apps-yaml/#threads","text":"If defined sets the number of threads to use during plan calculation, the default is 'auto' which will use the same number of threads as you have CPUs in your system. Valid values are: 'auto' - Use the same number of threads as your CPU count '0' - Don't use threads - disabled 'N' - Use N threads, recommended values are between 2 and 8 threads: auto","title":"threads"},{"location":"apps-yaml/#enable_coarse_fine_levels","text":"Controls the two-pass coarse/fine optimization algorithm for improved planning performance. The default is True (enabled). When enabled, Predbat uses a two-pass optimization strategy: Coarse pass : Quickly evaluates a reduced set of slot length combinations to identify approximately optimal charge/export window sizes Fine pass : Refines the search by focusing only on slot lengths near those identified as optimal This significantly reduces planning time while maintaining near-optimal results. You can disable this by setting it to False if needed. enable_coarse_fine_levels: True","title":"enable_coarse_fine_levels"},{"location":"apps-yaml/#web-interface","text":"Docker users can change the web port for the Predbat web interface by setting web_port to a new port number. The default port of 5052 must always be used for the Predbat app. web_port: 5052","title":"Web interface"},{"location":"apps-yaml/#notify_devices","text":"A list of device names to notify when Predbat sends a notification. The default is just 'notify' which contacts all mobile devices notify_devices: - mobile_app_treforsiphone12_2","title":"notify_devices"},{"location":"apps-yaml/#days_previous","text":"Predbat needs to know what your likely future house load will be to set and manage the battery level to support it. days_previous defines a list (which has to be entered as one entry per line) of the previous days of historical house load that are to be used to predict your future daily load. It's recommended that you set days_previous so Predbat calculates an average house load using multiple days' history so that 'unusual' load activity (e.g. saving sessions, \"big washing day\", etc) get averaged out. For example, if you want Predbat to average house load for the past week: days_previous: - 2 - 3 - 4 - 5 - 6 - 7 - 8 Or if you want Predbat to take the average of the same day for the last two weeks: days_previous: - 7 - 14 Or to just assume that house load on a particular day is the same as the same day of last week (not recommended): days_previous: - 7 Further details and worked examples of how days_previous works are covered at the end of this document. Do keep in mind that Home Assistant only keeps 10 days of history by default, so if you want to access more than this for Predbat you might need to increase the number of days of history kept in HA before it is purged by editing and adding the following to the /homeassistant/configuration.yaml configuration file and restarting Home Assistant afterwards: recorder: purge_keep_days: 14 days_previous_weight - A list (again with one entry per line) of weightings to be applied to each of the days in days_previous. For example, to apply a 100% weighting for the first-day entry in days_previous, but only a 50% weighting to the second day in days_previous: days_previous_weight: - 1 - 0.5 The default value is 1, and all history days are equally weighted, so if you don't want to weight individual days you can simply use: days_previous_weight: - 1","title":"days_previous"},{"location":"apps-yaml/#forecast_hours","text":"the number of hours that Predbat will forecast, 48 is the suggested amount, although other values can be used such as 30 or 36 if you have a small battery and thus don't need to forecast 2 days ahead. forecast_hours: 48","title":"forecast_hours"},{"location":"apps-yaml/#plan_random_delay","text":"Can set the maximum number of seconds of delay when recalculating the plan after it expires. The exact delay will be between 0 and this value. The default is 0. plan_random_delay: 30","title":"plan_random_delay"},{"location":"apps-yaml/#inverter-information","text":"The template apps.yaml for each inverter type comes pre-configured with regular expressions that should auto-discover the Home Assistant entity names for that inverter type. If you have more than one inverter or entity names are non-standard then you will need to edit apps.yaml for your inverter entities.","title":"Inverter information"},{"location":"apps-yaml/#givenergy-cloud-direct","text":"Predbat now supports direct communication with the GivEnergy cloud services instead of local control via GivTCP to your inverter. Log into the GivEnergy Portal web site and create an API key and copy it into the ge_cloud_key setting in apps.yaml . If you set ge_cloud_automatic to True, the number of inverters and their settings will be configured automatically. Or, if you set ge_cloud_automatic to False then you need to manually configure ge_cloud_serial to your inverter serial number for Predbat to use on the GivEnergy Cloud. If you set ge_cloud_data to False then Predbat will use the local Home Assistant data for history rather than the cloud data; you will need to wait until you have a few days of history established (at least days_previous days) before this will work correctly. ge_cloud_direct: True ge_cloud_automatic: True ge_cloud_serial: '{geserial}' ge_cloud_key: 'xxxxx' ge_cloud_data: True NOTE: It's recommended to store ge_cloud_key in secrets.yaml and reference it as ge_cloud_key: !secret givenergy_api_key - see Storing secrets .","title":"Givenergy Cloud Direct"},{"location":"apps-yaml/#solax-cloud-direct","text":"Predbat supports direct communication with the SolaX Cloud API to control SolaX inverters and batteries without requiring local integrations. To use SolaX Cloud Direct, you need to obtain API credentials (client ID and client secret) from your SolaX Cloud account.","title":"SolaX Cloud Direct"},{"location":"apps-yaml/#getting-your-solax-cloud-api-credentials","text":"Log in to your SolaX Cloud account at: - EU: https://www.solaxcloud.com - US: https://www.solaxcloud.us - CN: https://www.solaxcloud.com.cn Navigate to Settings \u2192 API Management (or Developer Settings) Create a new API application or access existing credentials Copy your Client ID and Client Secret Add these to your apps.yaml configuration","title":"Getting your SolaX Cloud API credentials"},{"location":"apps-yaml/#basic-solax-cloud-configuration","text":"If you set solax_automatic to true , Predbat will automatically discover your plants, inverters, and batteries, and configure all necessary entities without manual intervention. solax_client_id: 'your_client_id_here' solax_client_secret: 'your_client_secret_here' solax_region: 'eu' # Options: 'eu', 'us', or 'cn' solax_automatic: true solax_enable_controls: true NOTE: It's strongly recommended to store solax_client_id and solax_client_secret in secrets.yaml and reference them as: solax_client_id: !secret solax_client_id solax_client_secret: !secret solax_client_secret See Storing secrets for more information.","title":"Basic SolaX Cloud configuration"},{"location":"apps-yaml/#region-selection","text":"Set solax_region based on where your SolaX Cloud account is registered: 'eu' - European region (default) - openapi-eu.solaxcloud.com 'us' - United States region - openapi-us.solaxcloud.com 'cn' - China region - openapi.solaxcloud.com","title":"Region selection"},{"location":"apps-yaml/#optional-configuration-options","text":"solax_plant_id : If you have multiple plants registered in your SolaX Cloud account but only want Predbat to control specific plants, you can filter by plant ID: solax_plant_id: '1618699116555534337' If not specified, Predbat will control all plants found in your account. solax_enable_controls : Set to False to disable automatic inverter control (read-only mode). Useful for monitoring without control: solax_enable_controls: False","title":"Optional configuration options"},{"location":"apps-yaml/#automatic-configuration-solax_automatic-true","text":"When solax_automatic is enabled, Predbat will: Discover all plants with inverters and batteries in your SolaX Cloud account Automatically configure num_inverters based on the number of plants found Set inverter_type to SolaxCloud for each plant Create and configure all required entities including: - Battery power, SOC, capacity, and temperature sensors - Inverter and PV power sensors - Energy totals (yield, charged, discharged, imported, exported, load) - Charge/discharge schedule controls (start/end times, target SOC, rates) - Enable/disable switches for charge and export schedules - Reserve SOC setting No manual entity configuration is required when using automatic mode.","title":"Automatic configuration (solax_automatic: true)"},{"location":"apps-yaml/#published-entities","text":"When SolaX Cloud is configured, Predbat creates the following entities for each plant (replace {plant_id} with your actual plant ID): Sensors: sensor.predbat_solax_{plant_id}_battery_soc - Battery state of charge (kWh) sensor.predbat_solax_{plant_id}_battery_capacity - Battery capacity (kWh) sensor.predbat_solax_{plant_id}_battery_temperature - Battery temperature (\u00b0C) sensor.predbat_solax_{plant_id}_battery_max_power - Battery maximum power (W) sensor.predbat_solax_{plant_id}_inverter_max_power - Inverter maximum power (W) sensor.predbat_solax_{plant_id}_pv_capacity - PV array capacity (kWp) sensor.predbat_solax_{plant_id}_total_yield - Total PV generation (kWh) sensor.predbat_solax_{plant_id}_total_charged - Total battery charged (kWh) sensor.predbat_solax_{plant_id}_total_discharged - Total battery discharged (kWh) sensor.predbat_solax_{plant_id}_total_imported - Total grid import (kWh) sensor.predbat_solax_{plant_id}_total_exported - Total grid export (kWh) sensor.predbat_solax_{plant_id}_total_load - Total load consumption (kWh, calculated) sensor.predbat_solax_{plant_id}_total_earnings - Total earnings from exports Control entities: number.predbat_solax_{plant_id}_setting_reserve - Battery reserve SOC (%) select.predbat_solax_{plant_id}_battery_schedule_charge_start_time - Charge start time select.predbat_solax_{plant_id}_battery_schedule_charge_end_time - Charge end time number.predbat_solax_{plant_id}_battery_schedule_charge_target_soc - Charge target SOC (%) number.predbat_solax_{plant_id}_battery_schedule_charge_rate - Charge rate (W) switch.predbat_solax_{plant_id}_battery_schedule_charge_enable - Enable/disable charging select.predbat_solax_{plant_id}_battery_schedule_export_start_time - Export start time select.predbat_solax_{plant_id}_battery_schedule_export_end_time - Export end time number.predbat_solax_{plant_id}_battery_schedule_export_target_soc - Export target SOC (%) number.predbat_solax_{plant_id}_battery_schedule_export_rate - Export rate (W) switch.predbat_solax_{plant_id}_battery_schedule_export_enable - Enable/disable exporting","title":"Published entities"},{"location":"apps-yaml/#manual-configuration-solax_automatic-false","text":"If you disable automatic configuration, you must manually configure inverter entities in apps.yaml similar to other inverter types. In this case, set: solax_automatic: False num_inverters: 1 inverter_type: 'SolaxCloud' Then manually configure all required entities following the standard Predbat inverter configuration pattern.","title":"Manual configuration (solax_automatic: False)"},{"location":"apps-yaml/#multi-inverter-multi-plant-setup","text":"If you have multiple SolaX plants, automatic configuration will handle them automatically. Each plant will be treated as a separate inverter in Predbat's configuration.","title":"Multi-inverter / Multi-plant setup"},{"location":"apps-yaml/#supported-inverter-types-solax-cloud","text":"SolaX Cloud API supports various SolaX inverter models including: X1 series (single-phase) X3 series (three-phase) X3-Hybrid series Other SolaX cloud-connected inverters Both residential (business_type=1) and commercial (business_type=4) installations are supported.","title":"Supported inverter types (SolaX cloud)"},{"location":"apps-yaml/#troubleshooting-solax-cloud","text":"If you experience connection issues: Verify your client ID and client secret are correct Confirm you're using the correct region setting Check that your SolaX Cloud account has API access enabled Review Predbat logs for authentication errors Test your API credentials using the standalone test: cd /config/appdaemon/apps/predbat python3 solax.py --client-id YOUR_CLIENT_ID --client-secret YOUR_CLIENT_SECRET --region eu","title":"Troubleshooting (SolaX cloud)"},{"location":"apps-yaml/#solis-cloud-api","text":"EXPERIMENTAL: This is a new integration and may have issues. Predbat includes support for Solis inverters via the Solis Cloud API, allowing direct cloud-based monitoring and control of Solis hybrid inverters with battery storage.","title":"Solis Cloud API"},{"location":"apps-yaml/#configuration-solis","text":"Add the following to your apps.yaml to configure the Solis Cloud integration: solis_api_key: !secret solis_api_key solis_api_secret: !secret solis_api_secret solis_automatic: True solis_control_enable: True Configuration options: solis_api_key - Your Solis Cloud API Key (KeyId) - obtain from Solis Cloud portal solis_api_secret - Your Solis Cloud API Secret (KeySecret) - obtain from Solis Cloud portal solis_inverter_sn - Default is all inverters on your account unless set. Can be a single string or a list for multiple inverters. solis_automatic - Set to True to automatically configure Predbat entities (recommended, default: False ) solis_base_url - Solis Cloud API base URL (optional, auto-detects region) solis_control_enable - Enable/disable control commands (default: True , set to False for monitoring only) NOTE: It's strongly recommended to store api_key and api_secret in secrets.yaml and reference them as !secret solis_api_key - see Storing secrets .","title":"Configuration (solis)"},{"location":"apps-yaml/#important-notes-solis","text":"IMPORTANT: The Solis Cloud integration cannot automatically determine your battery size from the inverter. You have two options: Manual configuration (recommended): Set soc_max in apps.yaml manually with your battery capacity in kWh: soc_max: - 13.5 Replace 13.5 with your actual battery capacity in kWh. Automatic detection: Leave soc_max unset or set to 0, and Predbat will attempt to automatically determine battery size by analyzing historical charging data. This requires: - At least several days of historical data from soc_percent and battery_power sensors - Charging periods with at least 15% SoC change - May take time to collect sufficient data Manual configuration is recommended as it's immediate and more reliable.","title":"Important notes (Solis)"},{"location":"apps-yaml/#automatic-configuration-solis_automatic-true","text":"When automatic: True (recommended), Predbat will automatically create and configure the following entities for each inverter: Sensors: Battery SOC, capacity, voltage, current, power, and temperature PV power and total energy Grid power and import/export energy Load power and consumption Inverter status and product model Control entities: Reserve SOC setting Charge/discharge slot times (6 slots supported) Charge/discharge target SOC per slot Charge/discharge power rates Charge/discharge enable switches per slot Storage mode selection Battery protection settings No manual entity configuration is required when using automatic mode.","title":"Automatic configuration (solis_automatic: True)"},{"location":"apps-yaml/#manual-configuration-solis_automatic-false","text":"If you disable automatic configuration, you must manually configure inverter entities in apps.yaml similar to other inverter types. In this case, set: solis_api_key: !secret solis_api_key solis_api_secret: !secret solis_api_secret solis_automatic: False solis_control_enable: True num_inverters: 1 inverter_type: 'SolisCloud' soc_max: - 13.5 Then manually configure all required entities following the standard Predbat inverter configuration pattern.","title":"Manual configuration (solis_automatic: False)"},{"location":"apps-yaml/#supported-inverter-types-solis-cloud","text":"The Solis Cloud API supports various Solis hybrid inverter models with battery storage, including: RHI series (single-phase hybrid) RAI series (three-phase hybrid) S5 series hybrid inverters Other Solis cloud-connected hybrid inverters Both V1 (older firmware) and V2 (newer firmware) time window formats are automatically detected and supported.","title":"Supported inverter types (Solis Cloud)"},{"location":"apps-yaml/#troubleshooting-solis-cloud","text":"If you experience connection issues: Verify your API key and secret are correct Check your inverter serial number is exact (no spaces or extra characters) Confirm your Solis Cloud account has API access enabled Review Predbat logs for authentication errors Ensure soc_max is set correctly in apps.yaml (battery capacity in kWh) Check that control_enable is set appropriately for your needs","title":"Troubleshooting (Solis Cloud)"},{"location":"apps-yaml/#num_inverters","text":"The number of inverters you have. If you increase this above 1 you must provide multiple of each of the inverter entities num_inverters: 1","title":"num_inverters"},{"location":"apps-yaml/#inverter_type","text":"inverter_type defaults to 'GE' (GivEnergy) if not set in apps.yaml , or should be set to one of the inverter types that are already pre-programmed into Predbat: FoxCloud: Fox Cloud integration FoxESS: FoxESS via modbus GE: GivEnergy via GivTCP GEC: GivEnergy Cloud integration GEE: GivEnergy EMC GS: Ginlong Solis HU: Huawei Solar SA: Solar Assistant SE: SolarEdge SF: Sofar HYD SFMB: Sofar HYD with solarman modbus SIG: SigEnergy Sigenstor SK: Sunsynk SolaxCloud: SolaX Cloud API integration (EXPERIMENTAL) SolisCloud: Solis Cloud API integration (EXPERIMENTAL) SX4: Solax Gen4 (Modbus Power Control) If you have multiple inverters, then set inverter_type to a list of the inverter types. If you have created a custom inverter type in apps.yaml then inverter_type must be set to the same code as has been used in the custom inverter definition.","title":"inverter_type"},{"location":"apps-yaml/#geserial","text":"Only for GE inverters, this is a helper regular expression to find your inverter serial number, if it doesn't work edit it manually or change individual entities to match. If you have more than one GivEnergy inverter you will need one per inverter to be used in the later configuration lines. If you only have a single GivEnergy inverter then comment out all lines that refer to geserial2 in apps.yaml . geserial: 're:sensor.givtcp_(.+)_soc_kwh' geserial2: 're:sensor.givtcp2_(.+)_soc_kwh' If you are running GivTCP v3 and have an 'All-In-One' (AIO) or a 3-phase inverter then the helper regular expression will not correctly work and you will need to manually set geserial in apps.yaml to your inverter serial number which must be entered in lower case, e.g.: geserial: 'chNNNNgZZZ' TIP: If you have a single GivEnergy AIO, all control is directly to the AIO and the gateway is not required. Check the GivTCP configuration to determine whether inverter 1 (the givtcp sensors) is the AIO or the gateway, or inverter 2 (the givtcp2 sensors) is the AIO or gateway. Then in apps.yaml comment out the lines corresponding to the gateway, leaving just the givtcp or givtcp2 lines for the AIO. Also, delete the appropriate givtcp_rest inverter control line corresponding to the gateway so that Predbat controls the AIO directly. TIP2: If you have multiple GivEnergy AIO's, all the AIO's are controlled by the AIO gateway and not controlled individually. geserial should be manually configured to be your AIO gateway serial number 'gwNNNNgZZZ' and all the geserial2 lines should be commented out in apps.yaml . You should also delete the second givtcp_rest inverter control line so that Predbat controls the AIOs via the gateway. GivTCP version 3 is required for multiple AIOs or a 3-phase inverter.","title":"geserial"},{"location":"apps-yaml/#historical-data","text":"Predbat can either get historical data (house load, import, export and PV generation) directly from GivTCP or it can obtain it from the GivEnergy cloud. Unless you have a specific reason to not use the GivTCP data (e.g. you've lost your GivTCP data), its recommended to use GivTCP.","title":"Historical data"},{"location":"apps-yaml/#data-from-home-assistant","text":"The following configuration entries in apps.yaml are pre-configured to automatically use the appropriate sensors. If you have a 3-phase electricity supply and one inverter (and battery) on each phase then you will need to add one line for the load, import, export and PV sensors for each of the 3 phases. If you have a single-phase electricity supply and multiple inverters on the phase then you will need to add one line for each of the load and PV sensors. You don't need multiple lines for the import or export sensors as each inverter will give the same total import or export information. Edit if necessary if you have non-standard sensor names: load_today - Entity name for the house load in kWh today (must be incrementing) load_power - Current load power sensor in W (used with load_power_fill_enable to improve load_today data accuracy) load_power_fill_enable - When True (default), uses load_power data to fill gaps and smooth load_today sensor data. Set to False to disable this feature. import_today - Imported energy today in kWh (incrementing) export_today - Exported energy today in kWh (incrementing) pv_today - PV energy today in kWh (incrementing). If you have multiple inverters, enter each inverter PV sensor on a separate line. If you have an AC-coupled inverter then enter the Home Assistant sensor for your PV inverter. If you don't have any PV panels, comment or delete this line out of apps.yaml . Note: these '_today' entity names must all be energy sensors recording electricity measured over a time period, NOT power sensors which measure instantaneous power. The load_power_fill_enable feature helps to improve the accuracy of historical load data by using instantaneous power readings to fill gaps and smooth out load_today sensors that update infrequently (e.g., sensors that increment in kWh units may only update every hour). This preprocessing happens before the main load data analysis and can significantly improve prediction accuracy, especially for systems with coarse-grained energy sensors. See the Workarounds section below for configuration settings for scaling these if required. If you have multiple inverters then you may find that the load_today figures are incorrect as the inverters share the house load between them. In this circumstance, one solution is to create a Home Assistant template helper to calculate house load from {pv generation}+{battery discharge}-{battery charge}+{import}-{export}. The example below is defined in configuration.yaml (not the HA user interface) so it only updates every 5 minutes rather than on every underlying sensor state change: e.g. # Home consumption energy sensor, updated every 5 minutes instead of the default of every sensor state change template: - trigger: - platform: time_pattern minutes: \"/5\" sensor: - name: \"House Load Today\" unique_id: \"house_load_today\" unit_of_measurement: kWh state_class: total device_class: energy state: > {% set pv_xxx = states('sensor.givtcp_xxx_pv_energy_today_kwh') %} {% set pv_yyy = states('sensor.givtcp2_yyy_pv_energy_today_kwh') %} {% set dis_xxx = states('sensor.givtcp_xxx_battery_discharge_energy_today_kwh') %} {% set dis_yyy = states('sensor.givtcp2_yyy_battery_discharge_energy_today_kwh') %} {% set chg_xxx = states('sensor.givtcp_xxx_battery_charge_energy_today_kwh') %} {% set chg_yyy = states('sensor.givtcp2_yyy_battery_charge_energy_today_kwh') %} {% set import = states('sensor.givtcp_xxx_import_energy_today_kwh') %} {% set export = states('sensor.givtcp_xxx_export_energy_today_kwh') %} {% if pv_xxx in ['unknown','unavailable'] or pv_yyy in ['unknown','unavailable'] or dis_xxx in ['unknown','unavailable'] or dis_yyy in ['unknown','unavailable'] or chg_xxx in ['unknown','unavailable'] or chg_yyy in ['unknown','unavailable'] or import in ['unknown','unavailable'] or export in ['unknown','unavailable'] %} {{ this.state }} {% else %} {% if now().hour == 0 and now().minute < 1 %} 0.0 {% else %} {% set load = (import | float(0) + pv_xxx | float(0) + pv_yyy | float(0) + dis_xxx | float(0) + dis_yyy | float(0) - export | float(0) - chg_xxx | float(0) - chg_yyy | float(0)) | round(2) %} {% set previous = this.state | float(0) %} {{ [load, previous] | max }} {% endif %} {% endif %} The template looks complex but it ensures that if any of the underlying sensors is unavailable, the load sensor returns the previous energy value, at midnight the sensor resets to zero properly, and during the day the sensor can only ever increase, never decrease. If you are using the LoadML feature of Predbat and have multiple inverters that share the load, you will similarly need to create a template load power sensor: # Home consumption power sensor, updated every 5 minutes instead of the default of every sensor state change - trigger: - platform: time_pattern minutes: \"/5\" sensor: - name: \"House Load Power\" unique_id: \"house_load_power\" unit_of_measurement: kW device_class: power state_class: measurement state: > {% set pv_xxx = states('sensor.givtcp_xxx_pv_power') %} {% set pv_yyy = states('sensor.givtcp2_yyy_pv_power') %} {% set bat_xxx = states('sensor.givtcp_xxx_battery_power') %} {% set bat_yyy = states('sensor.givtcp2_yyy_battery_power') %} {% set grid = states('sensor.givtcp_xxx_grid_power') %} {% if pv_xxx in ['unknown','unavailable'] or pv_yyy in ['unknown','unavailable'] or bat_xxx in ['unknown','unavailable'] or bat_yyy in ['unknown','unavailable'] or grid in ['unknown','unavailable'] %} {{ this.state }} {% else %} {{ (pv_xxx | float(0) + pv_yyy | float(0) + bat_xxx | float(0) + bat_yyy | float(0) - grid | float(0)) | round(2) }} {% endif %} If you have GivEnergy inverters and are using REST mode, then also set givtcp_rest_power_ignore to True in apps.yaml for both inverter so Predbat uses your custom power sensor (and not the inverter sensors via REST).","title":"Data from Home Assistant"},{"location":"apps-yaml/#givenergy-cloud-data","text":"If you have an issue with the GivTCP data, Predbat can get the required historical data from the GivEnergy cloud instead. This data is updated every 30 minutes. Connecting to the cloud is less efficient and means that Predbat will be dependent upon your internet connection and the GivEnergy cloud to operate. ge_cloud_data - When True Predbat will connect to the GivEnergy cloud rather than GivTCP sensors for historical load_today, import_today and export_today inverter data ge_cloud_serial - Set the inverter serial number to use for the cloud data ge_cloud_key - Set to your API Key for the GE Cloud (long string) If you need to create a ge_cloud_key, in the GivEnergy cloud portal: Click 'account settings' in the menu bar (icon of a person overlaid with a cogwheel) Click 'Manage Account Security' then 'Manage API Tokens' then 'Create API Token' Enter a name for the token e.g. 'Predbat' Select 'No expiry' for the token expiry duration, or choose a fixed duration but remember to create a new token before it expires as Predbat's access will stop once the token expires Ensure that 'api:inverter' is ticked Create token Finally, copy/paste the token created into ge_cloud_key within apps.yaml","title":"GivEnergy Cloud Data"},{"location":"apps-yaml/#givenergy-cloud-controls","text":"Experimental Predbat now supports GE Cloud controls directly from inside Predbat. When enabled Predbat will connect directly with the GE Cloud and expose the controls of your inverter inside home assistant. Note You will still have to configure apps.yaml to point to these controls. ge_cloud_direct - Set to True to enable GE Cloud direct access ge_cloud_key - Set to your API Key for the GE Cloud (long string)","title":"GivEnergy Cloud controls"},{"location":"apps-yaml/#load-filtering","text":"By default, if Predbat sees a gap in the historical load data it will fill it with average data. This is to help in the cases of small amounts of lost data. For entire lost days you should change days_previous to point to different days(s) or include 3 or more days and if you set switch.predbat_load_filter_modal to true, the lowest day's historical load will be discarded. load_filter_threshold - Sets the number of minutes of zero load data to be considered a gap (that's filled with average data), the default is 30. To disable, set it to 1440.","title":"Load filtering"},{"location":"apps-yaml/#iboost-energy","text":"iboost_energy_today - Set to a sensor which tracks the amount of energy sent to your solar diverter, which can also be used to subtract from your historical load for more accurate predictions.","title":"iBoost energy"},{"location":"apps-yaml/#inverter-control-configurations","text":"","title":"Inverter control configurations"},{"location":"apps-yaml/#inverter_limit","text":"One per inverter. Controls the way Predbat models your inverter, this does not change the way it is controlled. When set, it defines the maximum AC output power in watts for your inverter. This is used by Predbat in calculating the plan to emulate clipping that occurs in the inverter when your solar produces more than the inverter can handle, but it won't be that accurate as the source of the data isn't minute-by-minute. For a Hybrid inverter make sure the Hybrid Inverter toggle is on, you should set the inverter limit to be the maximum power of the inverter in Watts e.g. a 5kW inverter will have a limit of 5000. If you have a separate Micro Inverter for your PV then you should add its power to the inverter limit For an AC Coupled inverter make sure the Hybrid Inverter toggle is off and set this to the power of your AC Coupled inverter. Do not add on separate Micro Inverters to the total power. If you have multiple inverters then set the value of each one in a list format. NB: inverter_limit is ONLY used by Predbat to improve the quality of the plan, any solar clipping is done by the inverter and is not controlled by Predbat.","title":"inverter_limit"},{"location":"apps-yaml/#export_limit","text":"One per inverter (optional). Controls the way Predbat models your inverter, this does not change the way it is controlled. When set defines the maximum watts of AC power your inverter can export to the grid at (e.g. 2500). This is used by Predbat in calculating the plan to emulate your inverter's software export limit setting that you will have if your G98/G99 approval was lower than your maximum inverter power (check your install information for details). If you do not set an export limit then it is assumed to be unlimited (and thus limited by your inverter or PV system).","title":"export_limit"},{"location":"apps-yaml/#inverter_limit_charge-and-inverter_limit_discharge","text":"An optional list of values with one entry per inverter. e.g. inverter_limit_charge: - 4200 inverter_limit_discharge: - 3000 When set in Watts, overrides the maximum charge/discharge rate settings used when controlling the inverter. This can be used if you need Predbat to cap your inverter battery rate (e.g. due to grid import/export limitations or to charge overnight at a slower rate to reduce inverter/battery heating). By default Predbat will normally configure all timed charges or discharges to be at the inverter's maximum rate and these options enable you to reduce that maximum rate. Low rate charging could also be used to slow down Predbat's charge rate whilst still meeting the battery plan.","title":"inverter_limit_charge and inverter_limit_discharge"},{"location":"apps-yaml/#inverter_can_charge_during_export","text":"Global setting, defaults to True. Controls the way Predbat models your inverter, this does not change the way it is controlled. During a force export period if the generated solar exceeds the inverter limit or the export limit then the inverter will scale back the export rate. If this setting is True then the inverter can end up charging the battery from PV while still in Force Export mode. If this setting if False then the inverter will not charge the battery and the excess PV will be lost.","title":"inverter_can_charge_during_export"},{"location":"apps-yaml/#controlling-the-inverter","text":"There are a few different ways to control your inverter: Home Assistant entity controls (standard) GivTCP REST Interface (GivEnergy Inverters only) Service API MQTT API","title":"Controlling the Inverter"},{"location":"apps-yaml/#home-assistant-entity-inverter-control","text":"Predbat can control inverters by updating Home Assistant entities. The template apps.yaml for is pre-configured with regular expressions for many configuration items, but some of them may need updating to match your system. If you only have a single inverter then the second inverter lines can be commented out if so desired or left in place (as they are ignored). The givtcp_rest line should be commented out/deleted on anything but GivTCP REST mode.","title":"Home Assistant entity inverter control"},{"location":"apps-yaml/#chargedischarge-rate","text":"charge_rate - Battery charge rate entity in watts discharge_rate - Battery discharge rate entity in watts or charge_rate_percent - Battery charge rate entity in percent of maximum rate (0-100) discharge_rate_percent - Battery discharge max rate entity in percent of maximum rate (0-100) or timed_charge_current - Battery charge rate entity in amps timed_discharge_current - Battery discharge rate entity in amps","title":"Charge/Discharge rate"},{"location":"apps-yaml/#battery-information","text":"battery_voltage - Nominal maximum battery voltage (not current battery voltage) - only needed for inverters controlled via Amps and used internally by Predbat to convert Watts to Amps to control the inverter. battery_rate_max - Sets the maximum battery charge/discharge rate in watts (e.g. 6000). For GivEnergy inverters this can be determined from the inverter, but must be set for non-GivEnergy inverters or Predbat will default to 2600W. Predbat also uses battery_rate_max when creating charge and discharge curves , looking for charging or discharging at 95% of the max rate. Be careful of setting the rate at a value higher than your inverter can handle for grid charging in order for Predbat to be able to find the historical 'full rate' charging/discharging needed to correctly calculate the curves. soc_max - Entity name for the maximum charge level for the battery in kWh. If not set or set to 0, Predbat will attempt to automatically determine the battery size by analyzing historical charging data from soc_percent and battery_power sensors. This requires at least several days of historical data with charging periods of 15% or more SoC change. If automatic detection fails, you must manually set this value. battery_min_soc - When set limits the target SoC% setting for charge and discharge to a minimum percentage value reserve - sensor name for the reserve SoC % setting. The reserve SoC is the lower limit target % to discharge the battery down to. battery_temperature - Defined the temperature of the battery in degrees C (default is 20 if not set).","title":"Battery Information"},{"location":"apps-yaml/#power-data","text":"Note this are not required for normal operation, only to produce power flow data or for battery curve calculations. One entry per inverter: battery_power - Current battery power in W or kW Battery power should be positive for discharge and negative for charge, if your sensor is the other way around then set battery_power_invert to True pv_power - Current PV power in W or kW load_power - Current load power in W or kW grid_power - Current grid power in W or kW Grid power should be negative for import and positive for export, if your sensor is the other way around then set grid_power_invert to True e.g: battery_power: - sensor.givtcp_{geserial}_battery_power battery_power_invert: - False grid_power: - sensor.givtcp_{geserial}_grid_power grid_power_invert: - False pv_power: - sensor.givtcp_{geserial}_pv_power load_power: - sensor.givtcp_{geserial}_load_power","title":"Power Data"},{"location":"apps-yaml/#battery-soc","text":"soc_kw - Entity name of the battery SoC in kWh, should be the inverter one not an individual battery or soc_percent Entity name of the battery SoC in percent of the maximum battery size, should be the inverter one not an individual battery","title":"Battery SoC"},{"location":"apps-yaml/#inverter-info","text":"inverter_reserve_max - When set defines the maximum reserve setting in % (default is 100) inverter_mode - Givenergy inverter mode control inverter_time - Inverter timestamp, used to track the last update of the inverter data inverter_battery_rate_min - Defines the minimum discharge/charge rate of the battery in watts (default is 0)","title":"Inverter Info"},{"location":"apps-yaml/#schedule","text":"charge_start_time - Battery charge start time entity - can be a HA select entity in format HH:MM or HH:MM:SS or a HA time entity. charge_end_time - Battery charge end time entity - can be a HA select entity in format HH:MM or HH:MM:SS or a HA time entity. discharge_start_time - Battery discharge start time, same format as charge_start_time. discharge_end_time - Battery discharge end time, same format as charge_end_time. charge_start_hour , charge_start_minute - Battery charge start time for inverters with separate hour and minute control entities. charge_end_hour , charge_end_minute - Ditto for battery charge end time. discharge_start_hour , discharge_start_minute - Ditto for battery discharge start time discharge_end_hour and discharge_end_minute - Ditto for battery discharge end time charge_time - Battery charge time entity for inverters that require a charge time expressed as a range in the format \" start hour : start minute - end hour : end minute \". discharge_time = Ditto battery discharge time expressed as a time range. charge_limit - Entity name for used to set the SoC target for the battery in percentage (AC charge target) scheduled_charge_enable - Switch to enable/disable battery charge according to the charge start/end times defined above. scheduled_discharge_enable - Switch to enable/disable battery discharge according to the discharge start/end times defined above. discharge_target_soc - Set the battery target percent for timed exports, will be written to minimum by Predbat. pause_mode - GivEnergy pause mode register (if present) pause_start_time - scheduled pause start time (only if supported by your inverter) pause_end_time - scheduled pause start time (only if supported by your inverter) idle_start_time - start time for idle (Eco) mode - for GivEnergy EMS idle_end_time - end time for idle (Eco) mode - for GivEnergy EMS If you are using REST control the configuration items should still be kept as not all controls work with REST. Some inverters require a \"button press\" to be triggered by Predbat to update the charge/discharge schedules in the inverter after the appropriate HA entities have been set. If your inverter features a combined charge/discharge update button, the charge_discharge_update_button can be set to the button name. e.g.: charge_discharge_update_button: - button.solis_charge_discharge If your inverter has separate buttons for setting charging and discharging schedules on the inverter, set both charge_update_button and discharge_update_button . e.g.: charge_update_button: - button.solis_charge discharge_update_button: - button.solis_discharge TIP: Some older GivEnergy inverters such as the Gen 1 hybrid and AC3 inverter that have had firmware upgrades to introduce battery pause functionality do not have sufficient memory on the inverter to provide control of battery pause start and end times. GivTCP does not recognise this and so still provides the select.givtcp_xxxx_battery_pause_start_time_slot and end_time_slot controls, but they do not work. Predbat can report an error trying to set them, or they revert back to 00:00:00 after being changed by Predbat and there will also be errors setting these controls reported in the GivTCP log. For these inverters the pause_start_time and pause_end_time entries should be commented out in apps.yaml to stop Predbat trying to use them. See section below on creating the battery charge power curve .","title":"Schedule"},{"location":"apps-yaml/#rest-interface-inverter-control","text":"For GivEnergy inverters Predbat can control the inverter directly via REST instead of via the Home Assistant GivTCP inverter controls detailed above. When configured in apps.yaml , control communication from Predbat to GivTCP is via REST which bypasses some issues with MQTT. givtcp_rest - One entry per Inverter, sets the GivTCP REST API URL ( http://homeassistant.local:6345 is the normal address and port for the first inverter, and the same address but ending :6346 if you have a second inverter - if you don't have a second inverter (or if you have multiple AIO's that are controlled through the gateway), delete the second line. If you are using Docker then change 'homeassistant.local' to the Docker IP address. TIP: You can replace homeassistant.local with the IP address of your Home Assistant server if you have it set to a fixed IP address. This may improve reliability of the REST connection as it doesn't need to lookup the HA server IP address each time. To check your REST is working open up the readData API point in a Web browser e.g: http://homeassistant.local:6345/readData If you get a bunch of inverter information back then it's working! Note that Predbat will still retrieve inverter information via REST, this configuration only applies to how Predbat controls the inverter. givtcp_rest_power_ignore - Optional, defaults to False. When set to True for a given inverter, Predbat will use the configured sensor entities (load_power, pv_power, grid_power, battery_power) instead of reading power values from the GivTCP REST API. This can be useful if you want to use alternative sensors or if the REST API power readings are unreliable. Set this to False (or omit) to use REST API power readings (default behavior).","title":"REST Interface inverter control"},{"location":"apps-yaml/#service-api","text":"Some inverters have the Service API enabled, this allows the configuration to call an arbitrary Home Assistant service to start/stop charging and discharging charge_start_service - Should be set to a service that is called when charging starts charge_freeze_service - If your inverter supports charge freeze set to a service that starts this mode charge_stop_service - Should be set to a service that is called when charging/charge freeze stops discharge_start_service - Should be set to a service that is called when force export (discharge) starts discharge_freeze_service - If your inverter supports export freeze set to a service that starts this mode discharge_stop_service - Should be set to a service that is called when export/export freeze stops Services that are not configuration will not be called. Example service is below: charge_start_service: service: switch.turn_off entity_id: \"switch.sunsynk_inverter_use_timer\" See Service API for details. Note that device_id will be passed to the service automatically, or it can be set in apps.yaml .","title":"Service API"},{"location":"apps-yaml/#mqtt-api","text":"Some Inverters are enabled with an MQTT API, in this case certain MQTT messages are send via the HA MQTT service. The mqtt_topic in apps.yaml set in the root of the MQTT topic (shown as topic below).","title":"MQTT API"},{"location":"apps-yaml/#set-reserve","text":"Called when the reserve (discharge-to %) is changed topic: topic /set/reserve payload: reserve","title":"Set reserve"},{"location":"apps-yaml/#set-target-soc","text":"Called when the target (charge-to %) SoC is changed topic: topic /set/target_soc payload: soc","title":"Set target soc"},{"location":"apps-yaml/#set-charge-rate","text":"Called to change the charge rate in Watts topic: topic /set/charge_rate payload: charge_rate","title":"Set charge rate"},{"location":"apps-yaml/#set-discharge-rate","text":"Called to change the discharge rate in Watts topic: topic /set/discharge_rate payload: discharge_rate","title":"Set discharge rate"},{"location":"apps-yaml/#set-charge","text":"Called when a charge is started topic: topic /set/charge payload: charge_rate","title":"Set charge"},{"location":"apps-yaml/#set-discharge","text":"Called when a forced export (discharge) is started topic: topic /set/discharge payload: discharge_rate","title":"Set discharge"},{"location":"apps-yaml/#set-auto","text":"Called when a charge/discharge is cancelled and the inverter goes back to home demand mode. topic: topic /set/auto payload: true","title":"Set auto"},{"location":"apps-yaml/#solcast-solar-forecast","text":"As described in the Predbat installation instructions , Predbat needs a solar forecast in order to predict solar generation and battery charging which can be provided by the Solcast integration. By default, the template apps.yaml is pre-configured to use the Solcast forecast integration for Home Assistant. The apps.yaml contains regular expressions for the following configuration items that should auto-discover the Solcast forecast entity names. They are unlikely to need changing although a few people have reported their entity names don't contain 'solcast' so worth checking, or editing if you have non-standard names: pv_forecast_today - Entity name for today's Solcast forecast pv_forecast_tomorrow - Entity name for tomorrow's Solcast's forecast pv_forecast_d3 - Entity name for Solcast's forecast for the day after tomorrow pv_forecast_d4 - Entity name for Solcast's forecast for two days after tomorrow Sensors for d5, d6 & d7 are supported, but not that useful so are not pre-defined in the template. If you do not have a PV array then comment out or delete these Solcast lines from apps.yaml . Alternatively, Predbat can obtain the solar forecast directly from Solcast and the Solcast integration is thus not required. Uncomment the following Solcast cloud interface settings in apps.yaml and set the API key correctly: solcast_host: 'https://api.solcast.com.au/' solcast_api_key: 'xxxx' solcast_poll_hours: 8 NOTE: It's recommended to store solcast_api_key in secrets.yaml and reference it as solcast_api_key: !secret solcast_api_key - see Storing secrets . Note that by default the Solcast API will be used to download all sites (up to 2 for hobby accounts), if you want to override this set your sites manually using solcast_sites as an array of site IDs: solcast_sites: - 'xxxx' If you have more than 2 array orientations and thus more than one Solcast API key, enter each key in a list: solcast_api_key: - xxxx_API_key_1 - yyyy_API_key_2 Keep in mind hobbyist accounts only have 10 polls per day so you need to ensure that the solcast_poll_hours refresh period is set so that you do not exceed the 10 poll limit. If you have two arrays then each Solcast refresh will consume 2 polls so its suggested that you set solcast_poll_hours to 4.8 to maximise your polls over a 24 hour period (5 polls a day, 24/5=poll every 4.8 hours). If you use the same Solcast account for other automations the total polls need to be kept under the limit or you will experience failures. If you use the same Solcast account for other automations the poll frequency will need to be reduced to ensure the total polls is kept under your account daily poll limit or you will experience failures. If you have multiple PV arrays connected to hybrid inverters or you have AC-coupled inverters, then ensure your PV configuration in Solcast covers all arrays. If however, you have a mixed PV array setup with some PV that does not feed into the inverters that Predbat is managing (e.g. hybrid GE inverters with older firmware but a separate older FIT array that directly feeds AC into the house), then it's recommended that Solcast is only configured for the PV connected to the inverters that Predbat is managing. NB: Gen2, Gen3 and Gen1 hybrid inverters with the 'fast performance' firmware can charge their batteries from excess AC that would be exported, so for these inverters, you should configure Solcast with your total solar generation capability. Solcast produces 3 forecasted PV estimates, the 'central' (50% or most likely to occur) PV forecast, the '10%' (1 in 10 more cloud coverage 'worst case') PV forecast, and the '90%' (1 in 10 less cloud coverage 'best case') PV forecast. By default, Predbat will use the central (PV50) estimate and apply to it the input_number.predbat_pv_metric10_weight weighting of the 10% (worst case) estimate. You can thus adjust the metric10_weight to be more pessimistic about the solar forecast. Predbat models cloud coverage by using the difference between the PV and PV10 forecasts to work out a cloud factor, this modulates the PV output predictions up and down over the plan slot duration as if there were passing clouds. This can have an impact on planning, especially for things like freeze charging which could assume the PV will cover the house load but it might not due to clouds. pv_estimate in apps.yaml can be used to configure Predbat to always use the 10% forecast by setting the configuration item to '10', or '90' to always use the 90% PV estimate (not recommended!). Set to blank or delete / comment out the line to use the default central estimate. If pv_estimate is set to 10 then input_number.predbat_pv_metric10_weight in Home Assistant should be set to 1.0. See also PV configuration options in Home Assistant .","title":"Solcast Solar Forecast"},{"location":"apps-yaml/#forecastsolar-solar-forecast","text":"The Forecast.solar service can also be used in Predbat, the free version offer access without an API Key but is limited to hourly data and does not provide any 10% or 90% data. Predbat Solar calibration can use past data to improve this information and provide the 10% data. You can create one or more rooftops by providing a list of the data for each one, they will be summed up automatically. The latitude and longitude are your location in world, or for the UK you can set a postcode. The azimuth is the direction of the roof: 0=North, -90=East, 90=West, -180/180 = South The declination is the angle of the panels, e.g. 45 for a sloped roof or 20 for those on a flat roof The efficiency relates to the aging of your panels, 0.95 is for newer systems but they will lose around 1% each year. The optional forecast_solar_max_age setting sets the number of hours between updates to PV data, the default is 8. forecast_solar: - postcode: SW1A 2AB kwp: 3 azimuth: 45 declination: 45 efficiency: 0.95 forecast_solar_max_age: 4 or you can set longitude and latitude if you are not in the UK or postcode does not work: latitude: 51.5072 longitude: -0.1276 Optionally you can set an api_key for personal or professional accounts and you can also set 'days' to define how many future days of data the forecast includes (2 for free, 3 for personal or 6 for professional) forecast_solar: - postcode: SW1A 2AB api_key: 'xxxxx' days: 3 Note you can omit any of these settings for a default value. They do not have to be exact if you use Predbat auto calibration for PV to improve the data quality.","title":"Forecast.solar Solar Forecast"},{"location":"apps-yaml/#energy-rates","text":"There are a number of configuration items in apps.yaml for telling Predbat what your import and export rates are. These are described in detail in Energy Rates and are listed here just for completeness: metric_octopus_import - Import rates from the Octopus Energy integration metric_octopus_export - Export rates from the Octopus Energy integration metric_octopus_gas - Gas rates from the Octopus Energy integration octopus_intelligent_slot - Octopus Intelligent GO slot sensor from the Octopus Energy integration octopus_saving_session - Energy saving sessions sensor from the Octopus Energy integration octopus_saving_session_octopoints_per_penny - Sets the Octopoints per pence rates_import_octopus_url - Octopus pricing URL (over-rides metric_octopus_import) rates_export_octopus_url - Octopus export pricing URL (over-rides metric_octopus_export) metric_standing_charge - Standing charge in pounds rates_import - Import rates over a 24-hour period with start and end times rates_export - Export rates over a 24-hour period with start and end times rates_gas - Gas rates over a 24-hour period with start and end times rates_import_override - Over-ride import rate for specific date and time range, e.g. Octopus Power-up events rates_export_override - Over-ride export rate for specific date and time range futurerate_url - URL of future energy market prices for Agile users futurerate_adjust_import and futurerate_adjust_export - Whether tomorrow's predicted import or export prices should be adjusted based on market prices or not futurerate_peak_start and futurerate_peak_end - start/end times for peak-rate adjustment carbon_postcode - Postcode to retrieve Carbon intensity grid information for carbon_automatic - Retrieve Carbon intensity information automatically based upon postcode carbon_intensity - Carbon intensity of the grid in half-hour slots from an integration. octopus_api_key - Sets API key to communicate directly with octopus. Recommended: store in secrets.yaml and use !secret octopus_api_key octopus_account - Sets Octopus account number axle_api_key - API key to communicate with Axle Energy VPP (Virtual Power Plant) service. Recommended: store in secrets.yaml and use !secret axle_api_key axle_pence_per_kwh - Payment rate in pence per kWh for Axle Energy VPP events (default: 100) axle_automatic - Optional, whether to use the default entity name binary_sensor.predbat_axle_event for axle event details (default True, use the default entity name) axle_session - Optional, enables manual override of the Axle event entity name axle_control - Optional, whether to switch Predbat to read-only mode during active Axle VPP events (default: False) plan_interval_minutes - Sets time duration of the slots used by Predbat for planning Note that gas rates are only required if you have a gas boiler, and an iBoost, and are using Predbat to determine whether it's cheaper to heat your hot water with the iBoost or via gas","title":"Energy Rates"},{"location":"apps-yaml/#energy-comparison","text":"You can configure in apps.yaml a compare_list section to define a list of Energy tariffs for Predbat to compare based on your predicted load and solar generation. See the Predbat Compare feature for details of how to define the tariffs to be compared.","title":"Energy Comparison"},{"location":"apps-yaml/#car-charging-integration","text":"Predbat can include electric vehicle charging in its plan and manage the battery activity so that the battery isn't discharged into your car when the car is charging (although you can override this if you wish by setting the switch.predbat_car_charging_from_battery to True in Home Assistant). Details of configuring apps.yaml for EV charging are described in Configure apps.yaml for your car charging , and a list of these configuration items is included below for completeness: num_cars number of cars you want Predbat to plan for car_charging_exclusive for multiple EV's to indicate if they can be charged independently or not car_charging_energy - Energy consumed by your EV charger octopus_intelligent_slot - Octopus Energy integration 'intelligent dispatching' sensor that indicates whether you are within an Octopus Energy \"smart charge\" slot octopus_ready_time - Octopus Energy integration sensor for when the car charging will be completed by octopus_charge_limit - Octopus Energy integration sensor for car charging limit octopus_slot_low_rate - Whether Octopus Intelligent Slots reported will be at the lowest rate if at home octopus_slot_max - Maximum number of 30-minute cheap rate slots per 24-hour period car_charging_planned - Indicates when your EV is plugged in and planned to charge during low-rate slots. car_charging_planned_response - Values for the car_charging_planned sensor that indicate that the car is plugged in and will charge in the next low rate slot. car_charging_now - Sensor to indicate when the EV is charging car_charging_now_response - Responses for car_charging_now to indicate that the car is charging car_charging_battery_size - Car battery size in kWh car_charging_limit - Percentage limit the car is set to charge to car_charging_soc - Car's current charge level expressed as a percentage ohme_login - Ohme EV charger account login ohme_password - Password for above Ohme account ohme_automatic_octopus_intelligent - Controls whether Predbat talks directly to the above Ohme account","title":"Car Charging Integration"},{"location":"apps-yaml/#watch-list-automatically-start-predbat-execution","text":"By default Predbat will run automatically every 5 minute and to execute the plan, and re-evaluate the plan automatically every 10 minutes. You can manually force Predbat to start executing by turning switch.predbat_active on - see Predbat's output data . Additionally Predbat can 'watch' a number of Home Assistant entities and if one of those changes, Predbat will automatically start executing. This can be useful for EV owners such as to detect when you have plugged the EV in (for Predbat to stop the battery discharging), and with Intelligent Octopus Go if Octopus gives you additional charge slots. In apps.yaml , uncomment (or add) the following lines, customising to the list of configuration items you have setup in apps.yaml and want Predbat to watch for changes for: watch_list: - '{octopus_intelligent_slot}' - '{octopus_ready_time}' - '{octopus_charge_limit}' - '{octopus_saving_session}' - '+[car_charging_planned]' - '+[car_charging_soc]' - '{car_charging_now}' Note the notation for watch_list, a single value apps.yaml configuration item such as octopus_intelligent_slot is surrounded by curly bracket parenthesis {}, but for apps.yaml configuration items that can be a list such as car_charging_soc they are surrounded by +[ and ].","title":"Watch List - automatically start Predbat execution"},{"location":"apps-yaml/#load-forecast","text":"In addition to the historical house load data that Predbat uses by default, you can optionally provide a forecast of future load such as is produced by Predheat for Hot water and Heat Pump heating systems or via Predai load_forecast - this should be configured to point to a sensor and attribute. The attribute must be in either The format of 'last_updated' timestamp and 'energy' in incrementing kWh. The format of a dictionary of timestamps and energy data in incremental KWh. For example: Or apps.yaml should be configured to point to the forecast sensor and attribute (in the above formats) like this: load_forecast: - sensor_name$attribute_name So if using Predheat it would be configured as: load_forecast: - predheat.heat_energy$external Set load_forecast_only to True if you do not wish to use the Predbat forecast but instead want to use this as your only forecast data e.g using PredAi: load_forecast_only: True load_forecast: - sensor.givtcp_{geserial}_load_energy_today_kwh_prediction$results","title":"Load Forecast"},{"location":"apps-yaml/#balance-inverters","text":"When you have two or more inverters it's possible they get out of sync so they are at different charge levels or they start to cross-charge (one discharges into another). When enabled, balance inverters try to recover this situation by disabling either charging or discharging from one of the batteries until they re-align. Most of the Predbat configuration for balancing inverters is through a number of Home Assistant controls for Balancing Inverters , but there is one configuration item in apps.yaml : balance_inverters_seconds: seconds Defines how often to run the inverter balancing, 30 seconds is recommended if your machine is fast enough, but the default is 60 seconds.","title":"Balance Inverters"},{"location":"apps-yaml/#workarounds","text":"There are a number of different configuration items in apps.yaml that can be used to tweak the way Predbat operates and workaround weirdness you may have from your inverter and battery setup.","title":"Workarounds"},{"location":"apps-yaml/#base-load","text":"Sometimes the load predictions can yield near zero data due to inaccuracy of data (e.g. a second PV system not tracked, car data being unreliable, poor sensors). In order to not get unrealistically low values you can set a base load value (in watts) which Predbat will use as a minimum load for a slot duration. To set a base load set base_load as an integer value in watts. base_load: 300 The above example load forecasts will now not fall below 300 watts which would be 0.15 kWh in a (default) 30-minute period.","title":"Base load"},{"location":"apps-yaml/#clock-skew","text":"clock_skew: minutes Skews the local (computer) time that Predbat uses (from the computer that Predbat is running on). Set to 1 means add a minute to the Predbat computer time, set to -1 means take a minute off the Predbat computer time. This clock adjustment will be used by Predbat when real-time actions happen e.g. triggering a charge or discharge. If your inverter's time is different to the time on the computer running Home Assistant, you may need to skew the time settings made on the inverter when you trigger charging or discharging. Again 1 means the inverter is 1 minute fast and -1 means the inverter is 1 minute slow. Separate start and end options are applied to the start and end time windows, mostly as you want to start battery activity late (not early) and finish early (not late). You can adjust the charge and discharge times written to the inverter by setting the following in apps.yaml : inverter_clock_skew_start: minutes inverter_clock_skew_end: minutes Skews the setting of the charge slot registers vs the predicted start time inverter_clock_skew_discharge_start: minutes inverter_clock_skew_discharge_end: minutes Skews the setting of the discharge slot registers vs the predicted start time","title":"Clock skew"},{"location":"apps-yaml/#battery-size-scaling","text":"battery_scaling: - scale Default value 1.0. Multiple battery size scales can be entered, one per inverter on separate lines. This setting is used to scale the battery-reported SoC kWh to make it appear bigger or larger than it is. As the GivEnergy inverters treat all batteries attached to an inverter as in effect one giant battery, if you have multiple batteries on an inverter that need scaling you should enter a composite scaling value for all batteries attached to the inverter. TIP: If you have a GivEnergy 2.6 or 5.2kWh battery then it will have an 80% depth of discharge but it will falsely report its capacity as being the 100% size, so set battery_scaling to 0.8 to report the correct usable capacity figure to Predbat. TIP: Likewise, if you have one or multiple GivEnergy All-in-Ones (AIOs), it will incorrectly report the 13.5kWh usable capacity of each AIO as 15.9kWh, so set battery_scaling to 0.85 to correct this. If you are going to chart your battery SoC in Home Assistant then you may want to use predbat.soc_kw_h0 as your current SoC (as this will be scaled) rather than the usual givtcp_SERIAL_NUMBER_soc GivTCP entity so everything lines up.","title":"Battery size scaling"},{"location":"apps-yaml/#import-export-scaling","text":"import_export_scaling: scale Default value 1.0. Used to scale the import & export kWh data from GivTCP if the inverter information is incorrect.","title":"Import export scaling"},{"location":"apps-yaml/#inverter-rate-minimum","text":"inverter_battery_rate_min: watts One per inverter (optional), set in Watts, when set models a \"bug\" in the inverter firmware in some models where if charge or discharge rates are set to 0 you actually get a small amount of charge or discharge. The recommended setting is 200 for Gen 1 hybrids with this issue.","title":"Inverter rate minimum"},{"location":"apps-yaml/#inverter-reserve-maximum","text":"inverter_reserve_max: percent Global, sets the maximum reserve % that may be set to the inverter, the default is 98, as some Gen 2 & Gen 3 inverters and AIO firmware versions refuse to be set to 100. Comment the line out or set it to 100 if your inverter allows setting it to 100%.","title":"Inverter reserve maximum"},{"location":"apps-yaml/#savings-max-charge-slots","text":"Every day Predbat calculates the financial savings you have made by running Predbat vs not using Predbat to automate your battery activity. The are calculated by default by comparing Predbat's activity to you having one fixed nightly charge slot set to charge at the lowest import rate with a target of 100%. You can change the number of simulated charge slots for this comparison by setting: calculate_savings_max_charge_slots: 1 If set to 0 then Demand (Eco) mode will be used as the baseline, or if non-zero then the maximum number of charging slots can be set (e.g. 2).","title":"Savings Max Charge Slots"},{"location":"apps-yaml/#automatic-restarts","text":"If the app that is providing the inverter control stops functioning it can prevent Predbat from functioning correctly. In this case, you can tell Predbat how to restart the app using a service. Right now only communication loss with GE inverters is detectable but in the future other systems will be supported. When enabled if communication is lost then the service configured will be triggered and can cause a restart which may restart the connection. This may be useful with GivTCP if you have time sync errors or lose the REST service every now and again. The auto_restart itself is a list of commands to run to trigger a restart. The shell command will call a 'sh' shell and can be used to delete files and suchlike. The service command is used to call a service and can contain arguments of addon and/or entity_id . The configuration below is for GivTCP v3. auto_restart: - shell: 'rm -rf /homeassistant/GivTCP/*.pkl' - service: hassio/addon_restart addon: 533ea71a_givtcp NB: If you are running GivTCP v2 then the line '533ea71a_givtcp' must be replaced with 'a6a2857d_givtcp' as the slug-id (Home Assistant app identifier) is different between GivTCP v2 and v3.","title":"Automatic restarts"},{"location":"apps-yaml/#battery-chargedischarge-curves","text":"Some batteries tail off their charge rate at high SoC% or their discharge rate at low SoC%, and these optional configuration items enable you to model this tail-off in Predbat. Note that the charge/discharge curves only affect the accuracy of the charging/discharging model Predbat applies in the forward battery plan, Predbat will still instruct the inverter to charge/discharge at full rate regardless of the charging curve so not having these curves only has an impact on plan accuracy. If you know the battery charge or discharge curves (e.g. manufacturer info or your own testing) then you can manually configure this in apps.yaml , or Predbat can calculate the curves based on historical inverter charging/discharging data in Home Assistant. If the battery has not recently been fully charged or fully discharged at a charge/discharge rate that is at least 95% of your maximum charge/discharge rate then Predbat will not be able to calculate the curves and you'll get a warning in the logfile. For some inverters you may not be able to practically charge/discharge at full rates so you'll keep getting the curve warning every time Predbat starts. Simply create dummy curves to stop this warning, e.g: battery_charge_power_curve: 100 : 1.0 battery_discharge_power_curve: 1 : 1.0 battery_charge_power_curve - This optional configuration item enables you to model in Predbat a tail-off in charging at high SoC%. Enter the charging curve as a series of steps of % of max charge rate for each SoC percentage. The percentage steps can either be expressed as an integer number (e.g. 97) or as a string (e.g. \"97\"); the Percent symbol is not required (see example curve below). The default is 1.0 (full power) charge to 100%. Modelling the charge curve becomes important if you have limited charging slots (e.g. only a few hours a night) or you wish to make accurate use of the low power charging mode ( switch.predbat_set_charge_low_power ). If the battery_charge_power_curve option is not set in apps.yaml and Predbat performs an initial run (e.g. due to restarting the Predbat/AppDaemon app, or an edit being made to apps.yaml ), then Predbat will automatically calculate the charging curve for you from historical battery charging information. You should look at the Predbat logfile to find the predicted battery charging curve and copy/paste it into your apps.yaml file. The logfile will also include a recommendation for how to set your battery_rate_max_scaling setting in HA. The YouTube video charging curve and low power charging explains how the curve works and shows how Predbat automatically creates it. Setting this option to auto will cause the computed curve to be stored and used automatically. This is not recommended if you use low power charging mode as your history will eventually not contain any full power charging data to compute the curve, so in this case it's best to manually configure the charge curve in apps.yaml . NB: For Predbat to calculate your charging curve it needs to have access to historical Home Assistant data for status , battery_charge_rate , battery_power and soc_percent or soc_kw . These must be configured in apps.yaml to point to Home Assistant entities that have appropriate history data for your inverter/battery. Either soc_percent or soc_kw from apps.yaml can be used to generate the charge curve. If both are defined then soc_percent is used in preference. Predbat will search through the charge history of your inverter, looking for periods of where Predbat status is Charging, battery_charge_rate is at least 95% of the maximum inverter battery charge rate, and the battery charges to above 85% SoC. From the corresponding battery_power readings, Predbat determines the charge curve. If suitable charge history cannot be found then Predbat will report that it cannot create the charge curve. If you have a GivEnergy inverter and are using the recommended default REST mode to control your inverter then you will need to uncomment out the following entries in apps.yaml : charge_rate: - number.givtcp_{geserial}_battery_charge_rate battery_power: - sensor.givtcp_{geserial}_battery_power soc_kw: - sensor.givtcp_{geserial}_soc_kwh Example charging curve from a GivEnergy 9.5kWh battery with the latest firmware and Gen 1 inverter: battery_charge_power_curve: 91 : 0.91 92 : 0.81 93 : 0.71 94 : 0.62 95 : 0.52 96 : 0.43 97 : 0.33 98 : 0.24 99 : 0.24 100 : 0.24 battery_discharge_power_curve - This optional configuration item enables you to model in Predbat a tail-off in discharging at low SoC%. Enter the discharging curve as a series of steps of % of max discharge rate for each SoC percentage. The default is 1.0 (full power) discharge to 0%. If the battery_discharge_power_curve option is not set in apps.yaml and Predbat performs an initial run (e.g. due to restarting the Predbat/AppDaemon app, or an edit being made to apps.yaml ), then Predbat will automatically calculate the discharging curve for you from historical battery discharging information. You should look at the Predbat logfile to find the predicted battery discharging curve and copy/paste it into your apps.yaml file. Setting This option to auto will cause the computed curve to be stored and used automatically. This may not work very well if you don't do regular discharges to empty the battery. In the same way, as for the battery charge curve above, Predbat needs to have access to historical Home Assistant data for status , battery_discharge_rate , battery_power and soc_percent or soc_kw . These must be configured in apps.yaml to point to Home Assistant entities that have appropriate history data for your inverter/battery. Either soc_percent or soc_kw from apps.yaml can be used to generate the discharge curve. If both are defined then soc_percent is used in preference. Predbat will search through the discharge history of your inverter, looking for periods of where Predbat status is Exporting or Discharging, battery_discharge_rate is at least 95% of the maximum inverter battery discharge rate, and the battery discharges down below 20% SoC. From the corresponding battery_power readings, Predbat determines the discharge curve. If suitable discharge history cannot be found then Predbat will report that it cannot create the discharge curve. If you are using REST mode to control your GivEnergy inverter then the following entries in apps.yaml will need to be uncommented : discharge_rate: - number.givtcp_{geserial}_battery_discharge_rate battery_power: - sensor.givtcp_{geserial}_battery_power soc_kw: - sensor.givtcp_{geserial}_soc_kwh battery_charge_power_curve_default - This optional configuration item provides a fallback charging curve when Predbat cannot auto-detect the curve from your inverter. This is useful when: Your inverter doesn't provide historical charging data needed for auto-detection You've recently installed Predbat and don't have sufficient historical data yet Auto-detection fails but you know your battery's charging characteristics The default curve is only used if: You have not manually configured battery_charge_power_curve (i.e., it is not set, or is set to \"auto\" ) Auto-detection from inverter history fails or returns no curve Precedence: If you manually configure battery_charge_power_curve (with any value other than \"auto\" ), it will be used exclusively and neither auto-detection nor the default will be considered. Only if battery_charge_power_curve is set to \"auto\" or not configured at all will the system attempt auto-detection, with the default as a fallback if auto-detection fails. Example: battery_charge_power_curve_default: 91 : 0.91 92 : 0.81 93 : 0.71 94 : 0.62 95 : 0.52 96 : 0.43 97 : 0.33 98 : 0.24 99 : 0.24 100 : 0.24 battery_discharge_power_curve_default - This optional configuration item provides a fallback discharging curve when Predbat cannot auto-detect the curve from your inverter. Similar to the charge curve default above, this is used as a fallback, but only if you have not manually configured battery_discharge_power_curve (or have set it to \"auto\" ). Precedence: If you manually configure battery_discharge_power_curve , it takes absolute precedence and is always used. Only if battery_discharge_power_curve is set to \"auto\" or not configured at all will Predbat attempt to auto-detect the curve from inverter history; if that fails, the default battery_discharge_power_curve_default is used as a fallback. Example: battery_discharge_power_curve_default: 10 : 0.85 9 : 0.75 8 : 0.65 7 : 0.55 6 : 0.45 5 : 0.35 4 : 0.25 3 : 0.15 2 : 0.10 1 : 0.05","title":"Battery charge/discharge curves"},{"location":"apps-yaml/#battery-temperature-curves","text":"Your battery's maximum charge and discharge rate can be impacted by cold weather, Predbat can predict this if you provide a temperature sensor and define a curve. You must make sure battery_temperature is defined (one per inverter). Set battery_temperature_history to a sensor with history, this will be used to predict future temperatures based on past changes Set battery_temperature_charge_curve to define the maximum charge rate in C which is a percentage of your battery capacity. Set battery_temperature_discharge_curve to define the maximum discharge rate in C which is a percentage of your battery capacity. An example for GivEnergy Gen2 battery is below. Note You must adjust the curve for your system. gaps in the curve above 20 will use 20 degrees, and gaps below 0 will use 0 degrees. Do not leave gaps in the curve between 20 and 0. # Battery temperature charge adjustment curve # Specific in C which is a multiple of the battery capacity # e.g. 0.33 C is 33% of the battery capacity # values unspecified will be assumed to be 1.0 hence rate is capped by the max charge rate battery_temperature_history: sensor.givtcp_battery_stack_1_bms_temperature battery_temperature_charge_curve: 20: 0.50 19: 0.33 18: 0.33 17: 0.33 16: 0.33 15: 0.33 14: 0.33 13: 0.33 12: 0.33 11: 0.33 10: 0.25 9: 0.25 8: 0.25 7: 0.25 6: 0.25 5: 0.25 4: 0.25 3: 0.25 2: 0.25 1: 0.15 0: 0.00","title":"Battery temperature curves"},{"location":"apps-yaml/#weather-alert-system","text":"Predbat can take data directly from the Meteo-Alarm feed and use it to trigger keeping your battery charged so you have power in the event of a power cut. Please look at the Meteo Alarm for more details. The apps.yaml must be configured to select the URL for your country and the events you want Predbat to retain your battery level for.`` # Alert feeds - customise to your country, the alert types, severity and keep value # Customise to your needs, delete the ones you don't want to trigger on - e.g. remove Amber, Moderate and Possible. alerts: url: \"https://feeds.meteoalarm.org/feeds/meteoalarm-legacy-atom-united-kingdom\" event: \"(Amber|Yellow|Orange|Red).*(Wind|Snow|Fog|Rain|Thunderstorm|Avalanche|Frost|Heat|Coastal event|Flood|Forestfire|Ice|Low temperature|Storm|Tornado|Tsunami|Volcano|Wildfire)\" severity: \"Moderate|Severe|Extreme\" certainty: \"Possible|Likely|Expected\" keep: 40 The event severity and certainty are all regular expressions and can be set to one or multiple values using regular expression syntax. Any unset values are ignored. Your location (from Home Assistant) is used to filter alerts that apply only to your area. If this does not work or if you want to change the location, you can also set latitude and longitude in the alerts section of the apps.yaml . Events that match the given criteria will try to keep your battery at the percentage level specified by keep (default 100%) during the entire event period. This works by using a much stronger version of best_soc_keep but only for that time period. Your Predbat status will also have [Alert] in it during the alert time period and the triangle alert symbol will show on your HTML plan for the time period of the alert. Predbat records details of any weather alerts in the entity sensor.predbat_alertfeed_status which has a state value of the textual description of the alert. The entity has two attributes: keep - set to the SoC keep percentage figure specified in apps.yaml (or the default 100) during the alert time period so can be used in an automation trigger if you want to take additional actions in Home Assistant alerts - set to a list of dictionaries of details of any current or future alert events that match your alert criteria in apps.yaml . Each list entry contains event severity, certainty, urgency, area, time period, title, etc.","title":"Weather Alert System"},{"location":"apps-yaml/#triggers","text":"export_triggers - The export trigger feature is useful to help trigger your own automation based on Predbat predicting in the plan that you will have spare solar energy that would be exported - this could happen if the battery is full or there is more predicted solar generation than can be charged into the battery. You can use the trigger in an automation, for example, you could turn on an immersion heater or the washing machine to consume the excess solar power. The triggers count export energy until the next active charge slot only. For each trigger give a name, the minutes of export needed, and the energy required in that time. Multiple triggers can be enabled by Predbat at once so in total you could use too much energy if multiple triggered automations all run. Each trigger specified in apps.yaml will create a Home Assistant entity called 'binary_sensor.predbat_export_trigger_ name ' which will be turned on when the predicted trigger conditions are valid. Connect this binary sensor to your automation to start whatever you want to trigger. Set the name for each trigger, the number of minutes of solar export you need, and the amount of energy in kWh you will need available during that period in apps.yaml: For example: export_triggers: - name: \"large\" minutes: 60 energy: 1.0 - name: \"small\" minutes: 15 energy: 0.25 Note: Predbat will set an export trigger to True if in the plan it predicts that there will be more than the specified amount of excess solar energy over the specified time. In the example above, the 'large' trigger will be set to True for the 1-hour period where Predbat predicts that there will be a total of 1kWh of excess solar generation over that period . For clarity the trigger is not set based on actual excess solar generation or export. It should also be recognised that this prediction could be wrong; there could be less solar generation or more house load than was predicted in the plan. If you wish to trigger activities based on Predbat charging or discharging the battery rather than spare solar energy you can instead use the following binary sensors in Home Assistant: binary_sensor.predbat_charging - Will be True when the home battery is inside a charge slot (either being charged or being held at a level). Note that this does include charge freeze slots where the discharge rate is set to zero without charging the battery. binary_sensor.predbat_exporting - Will be True when the home battery is inside a force discharge slot. This does not include discharge freeze slots where the charge rate is set to zero to export excess solar only.","title":"Triggers"},{"location":"apps-yaml/#understanding-how-days_previous-works","text":"As described earlier, days_previous is a list of the previous days of historical house load that are averaged together to predict your future daily load. e.g., if you want the average of the same day for the last 2 weeks: days_previous: - 7 - 14 This section describes in more detail how days_previous is used by Predbat in creating the future battery plan, and gives some worked examples and a 'gotcha' to be aware of. When Predbat forecasts future home demand it counts backwards the days_previous number of days to find the appropriate historical home consumption. This is best explained through a worked example: In this example, days_previous is set to use history from 2 days ago: days_previous: - 2 If right now today it's Monday 3:15pm and Predbat is predicting the forward plan for the next 48 hours: For tomorrow's (Tuesday) 9am slot, Predbat will look backwards 2 days from Tuesday so will use the historical home consumption from Sunday 9am as being the predicted load for Tuesday 9am. For the day after (Wednesday) 9am slot, Predbat again looks backwards 2 days from that day, so will use historical home consumption from Monday 9am as being the Wednesday 9am prediction. This pattern of counting backwards days_previous days to find the appropriate time slot to load historical home consumption from requires Predbat to operate some additional special processing if days_previous is set to a low value or forecast_hours to a high value. Extending the previous example but this time days_previous is set to use history from just the previous day: days_previous: - 1 Today it's still Monday 3:15pm and Predbat is predicting the forward plan for the next 48 hours: For tomorrow's (Tuesday) 9am slot, Predbat will look backwards 1 day from Tuesday so will use the historical home consumption from today's (Monday) 9am as being the predicted load for Tuesday 9am. For the day after (Wednesday) 9am slot, Predbat again looks backwards 1 day from that day, so looks for historical home consumption from Tuesday 9am as being the Wednesday 9am prediction, but of course, it's still Monday, and Tuesday hasn't happened yet so we can't know what that historical consumption was! What Predbat does in this circumstance is to subtract a further day from days_previous and for Wednesday 9am's prediction, it will therefore use the historical load from Monday 9am. This issue of finding future historical load only occurs when days_previous is set to 1 and Predbat is forecasting more than 24 hours from 'now'. So to highlight this with some edge cases, today is still Monday 3:15pm, days_previous is still set to '1' and in the forward plan: For tomorrow's (Tuesday) 2:30pm slot, Predbat looks backwards 1 day from Tuesday and takes the historical home consumption from today's (Monday) 2:30pm slot. For tomorrow's (Tuesday) 3:00pm slot, Predbat looks backwards 1 day and takes the historical load from today's (Monday) 3:00pm slot - which we are only part way through so only 15 minutes of load will be predicted for tomorrow 3pm. For tomorrow's (Tuesday) 3:30pm slot, Predbat looks backwards 1 day but the 3:30pm slot today hasn't yet occurred so Predbat will take the historical load from the prior day and has to use Sunday's 3:30pm load for tomorrow's prediction. Ditto the predicted load for tomorrow's (Tuesday) 4:00pm slot comes from Sunday 4pm. As today rolls forward and Predbat keeps on updating the forward plan each time it runs, the prediction will be updated with the correct previous_day history as and when it exists. It's recommended therefore that days_previous isn't set to 1, or if it is, that you understand the way this has to work and the consequences. If you want to set days_previous to take an average of the house load over all the days of the last week it's suggested that it be set as: days_previous: - 2 - 3 - 4 - 5 - 6 - 7 - 8","title":"Understanding how days_previous works"},{"location":"car-charging/","text":"Car charging As a bare minimum, a HA-controllable smart plug with a granny charger could be used, but do consider there could be an electrical spike to the car if the smart plug is turned off when the car is charging. A proper car charger and HA integration are preferable. You will first need to have installed the appropriate Home Assistant integration for your car charger. Configure apps.yaml for your car charging Start by configuring the car charging settings in apps.yaml with the following car-charging related configuration items: num_cars should be set in apps.yaml to the number of cars you want Predbat to plan for. Set to 0 if you don't have an EV or don't want Predbat to plan for your EV charging (and the remaining car sensors in apps.yaml can safely be commented out or deleted as they won't be required). NB: num_cars must be set correctly regardless of whether you are using Octopus Intelligent Go to control your EV charging or Predbat to control the charging; or else Predbat could start discharging your battery when the EV is charging. car_charging_exclusive should be set to True for each car in apps.yaml if you have multiple cars configured in Predbat, but only one car charger. This indicates that only one car may charge at once (the first car reporting as plugged in will be considered as charging). If you set this to False for each car then it is assumed that the car can charge independently, and hence two or more cars could charge at once. One entry per car. car_charging_exclusive: - True - True Filtering Car Charging Energy from house load Depending upon how the CT clamps and your inverter and electric car charger have been wired, your inverter may 'see' your EV charging as being part of the house load. This means your house load is artificially raised whenever you charge your car. In this circumstance you might want to remove your electric car charging data from the historical house load data so as to not bias the calculations, otherwise you will get high battery charge levels when the car was charged previously (e.g. last week). TIP: Check the house load being reported by your inverter when your car is charging. If it doesn't include the car charging load then there is no need to follow these steps below (and if you do, you'll artificially deflate your house load). switch.predbat_car_charging_hold - A switch that when turned on (the default) tells Predbat to remove car charging data from your historical house load so that Predbat's battery prediction plan is not distorted by previous car charging. If you are getting erroneous house load predictions in your plan then check this setting and car_charging_energy or input_number.predbat_car_charging_threshold are set correctly. If you don't have an EV then turn switch.predbat_car_charging_hold Off as Predbat will by default still consider any house load in excess of input_number.predbat_car_charging_threshold to be car charging activity and will exclude it. car_charging_energy - Set in apps.yaml to point to an entity which is the daily incrementing kWh data for the car charger. This has been pre-defined as a regular expression that should auto-detect the appropriate Wallbox and Zappi car charger sensors, or edit as necessary in apps.yaml for your charger sensor. Note that this must be configured to point to an 'energy today' sensor in kWh not an instantaneous power sensor (in kW) from the car charger. IMPORTANT: Predbat will subtract all car_charging_energy from your historic house load so if car_charging_energy is not configured with the correct sensor, your car charging energy sensor does not accurately report your car charging data (e.g. it falsely reports charging data when not actually charging), or your house load sensor already excludes car charging, then this will really mess up your predbat plan as Predbat will exclude all car_charging_energy from your load predictions and you could end up with erroneous or zero house load predictions. Do check the entity! NOTE: The car charging energy sensor must be a daily incrementing kWh sensor. Check the history of your sensor in Home Assistant, that it increments through the day when your car is charging, resets to zero at midnight, and does not dip down in value or reset to zero other than at midnight. Some car charger energy sensors do not behave as Predbat requires them to do; for example, they may show cumulative energy per charge, not cumulative charge energy today. You may need to wrap the car charger energy sensor into a daily resetting utility meter to create a sensor that behaves correctly. TIP: You can also use car_charging_energy to remove other house load kWh from the data Predbat uses for the forecast, e.g. if you want to remove Mixergy hot water tank heating data from the forecast such as if you sometimes heat on gas, and sometimes electric depending upon import rates. car_charging_energy can be set to a list of energy sensors, one per line if you have multiple EV car chargers, or want to exclude multiple loads such as heat pump load, e.g.: car_charging_energy: - 're:(sensor.myenergi_zappi_[0-9a-z]+_charge_added_session|sensor.wallbox_portal_added_energy)' - sensor.mixergy_ID_energy - sensor.ashp_energy_today input_number.predbat_car_charging_energy_scale - Used to define a scaling factor (in the range of 0 to 1.0) to multiply the car_charging_energy sensor data by if required (e.g. set to 0.001 to convert Watts to kW). Default 1.0, i.e. no scaling. If you do not have a suitable car charging energy kWh sensor in Home Assistant then comment the car_charging_energy line out of apps.yaml and configure input_number.predbat_car_charging_threshold input_number.predbat_car_charging_threshold (default 6 = 6kW)- Sets the kW power threshold above which home consumption is assumed to be car charging and input_number.predbat_car_charging_rate (in kW) will be subtracted from the historical load data. Used to 'detect' EV charging if you have an EV charger but it does not have an energy today sensor that you can use. If you do not have an EV charger then ensure you set switch.predbat_car_charging_hold to Off otherwise Predbat will assume any house load in excess of car_charging_threshold is EV charging and remove it from your house load predictions! Planned Car Charging These features allow Predbat to know when you plan to charge your car. If you have an Intelligent Octopus tariff then planning of charging is done via the Octopus app and Predbat obtains this information through the Octopus Energy integration in Home Assistant. switch.predbat_octopus_intelligent_charging - When this Home Assistant switch is enabled, Predbat will plan charging around the Intelligent Octopus slots, taking it into account for battery load and generating the slot information The following apps.yaml configuration items are pre-defined with regular expressions to point to appropriate sensors in the Octopus Energy integration. You should not normally need to change these if you have the Octopus Intelligent tariff: octopus_intelligent_slot - Points to the Octopus Energy integration 'intelligent dispatching' sensor that indicates whether you are within an Octopus Energy \"smart charge\" slot, and provides the list of future planned charging activity. octopus_ready_time - Points to the Octopus Energy integration sensor that details when the car charging will be completed. Note: the Octopus Integration now provides Octopus Intelligent target time in two formats, either a 'select' entity or a 'time' entity. Predbat uses the time entity (time.octopus_energy_{{DEVICE_ID}}_intelligent_target_time) which is disabled by default, so you will need to enable the time entity and disable the matching select entity. octopus_charge_limit - Points to the Octopus Energy integration sensor that provides the car charging limit. octopus_slot_low_rate - Default is True, meaning any Octopus Intelligent Slot reported will be at the lowest rate if at home. If False the existing rates only will be used which is only suitable for tariffs other than IOG. octopus_slot_max - Default is 48 (disabled). Sets the maximum number of 30-minute cheap rate slots per 24-hour period. Octopus Intelligent users maybe from March 2026 limited to 6 hours of cheap charging per day. Slots beyond this limit will use standard rates. Its recommended you set this to 12 (for 6 hours) once Octopus enforce this Octopus Intelligent limit. If you don't use Intelligent Octopus then the above Octopus Intelligent configuration lines in apps.yaml can be commented out or deleted, and there are a number of other apps.yaml configuration items that should be set: car_charging_planned - Optional, can be set to a Home Assistant sensor (e.g. from your car charger integration) which lets Predbat know the car is plugged in and planned to charge during low-rate slots. Or manually set it to 'False' to disable this feature, or 'True' to always enable it. The apps.yaml template supplied with Predbat comes pre-configured with a regular expression that should automatically match Zappi or Wallbox car chargers. If you have a different type of charger you will need to configure it manually. car_charging_planned_response - An array of values for the above car_charging_planned sensor which indicate that the car is plugged in and will charge in the next low rate slot. The template apps.yaml comes with a set of pre-defined sensor values that should match most EV chargers. Customise for your car charger sensor if it sets sensor values that are not in the list. car_charging_now - For some cases finding details of planned car charging is difficult. The car_charging_now configuration item can be set to point to a Home Assistant sensor that tells you that the car is currently charging. Predbat will then assume this slot is used for charging regardless of the plan. If Octopus Intelligent Charging is enabled and car_charging_now indicates the car is charging then Predbat will also assume that this is a low rate slot for the car/house (and might therefore start charging the battery), otherwise electricity import rates are taken from the normal rate data. WARNING: Some cars will briefly start charging as soon as they are plugged in, which Predbat will detect and assume that this is a low rate slot even when it isn't. It is therefore recommended that you do NOT set car_charging_now unless you have problems with the Octopus Intelligent slots, and car_charging_now should be commented out in apps.yaml . CAUTION: It is strongly recommended to not use car_charging_now with Predbat-led charging unless you can't make it work any other way as Predbat will assume all car charging is at a low rate. car_charging_now_response - Set to the range of positive responses for car_charging_now to indicate that the car is charging. Useful if you have a sensor for your car charger that isn't binary. To make Predbat planned car charging more accurate, configure the following items in apps.yaml : car_charging_battery_size - Set this value in apps.yaml to the car's battery size in kWh which must be entered with one decimal place, e.g. 50.0. If not set, Predbat defaults to 100.0kWh. This will be used to predict when to stop car charging. car_charging_limit - You should configure this to point to a sensor that specifies the % limit the car is set to charge to. This could be a sensor on the EV charger integration or a Home Assistant helper entity you can set as you wish. If you don't specify a sensor Predbat will default to 100% - i.e. fill the car to full. car_charging_soc - You should configure this to point to a sensor (on the HA integration for your EV charger) that specifies the car's current charge level expressed as a percentage - it must NOT be set to a sensor that gives the car's current kWh value as this will cause Predbat to charge the car to an incorrect level. If you don't specify a sensor, Predbat will default to 0%. If you have multiple electric cars then car_charging_soc should be set to a list of sensors, e.g.: car_charging_soc: - 'sensor.tsunami_battery' - 'sensor.toyota_XXX_battery_level' Multiple Electric Cars Multiple cars can be planned with Predbat, in which case you should set num_cars in apps.yaml to the number of cars you want to plan. car_charging_limit , car_charging_planned , car_charging_battery_size and car_charging_soc must then be a list of values (i.e. 2 entries for 2 cars) If you have Intelligent Octopus then Car 0 will be managed by the Octopus Energy integration, if it's enabled. Each car will have its own Home Assistant slot sensor created e.g. binary_sensor.predbat_car_charging_slot_1 , SoC planning sensor e.g predbat.car_soc_1 and predbat.car_soc_best_1 for car 1 An excellent worked example of setting up multiple car charging with Predbat is in the 'Show and tell' part of Predbat's GitHub. Ohme car charger direct integration Predbat can talk directly to the Ohme charger by configuring your Ohme account details in apps.yaml . When ohme_automatic_octopus_intelligent is set to True then Predbat is automatically configured to take Octopus Intelligent car charging slots from Ohme (rather than from Octopus Intelligent directly). ohme_login: \"user@domain\" ohme_password: \"xxxxxxxxx\" ohme_automatic_octopus_intelligent: true NOTE: It's recommended to store ohme_password in secrets.yaml and reference it as ohme_password: !secret ohme_password - see Storing secrets . Car Charging Planning There are two ways that Predbat can plan the slots for charging your car: Octopus-led charging If you have the Intelligent Octopus import tariff, have completed enrollment of your car/charger to Intelligent Octopus (requires a compatible charger or car), and you have installed the Octopus Energy integration - in which case Predbat will use the car charging slots allocated by Octopus Energy in battery prediction. The Octopus Energy integration supports Octopus Intelligent , and through that, Predbat gets most of the information it needs. octopus_intelligent_slot in apps.yaml is pre-configured with a regular expression to point to the Intelligent Slot sensor in the Octopus Energy integration. You should not need to change this, but it is worth checking the Predbat logfile to confirm that it has found your EV charger details. If you are using the Octopus Energy direct method of Predbat directly connecting to your Octopus account then this configuration line is not required and should be commented out of apps.yaml . Set switch.predbat_octopus_intelligent_charging to On You should set the car's current SoC sensor, car_charging_soc in apps.yaml to point to a Home Assistant sensor that specifies the car's current % charge level to have accurate results. This should normally be a sensor provided by your car charger. If you don't have this available for your charger then Predbat will assume the car's current charge level is 0%. If you set car_charging_limit in apps.yaml then Predbat can also know if the car's limit is set lower than in Intelligent Octopus. If you don't set this Predbat will default to 100%. octopus_charge_limit and octopus_ready_time in apps.yaml are pre-configured with regular expressions to point to the appropriate sensors for your EV charger in the Octopus Energy integration. These retrieve details of the charge limit and when the car will finish charging from your Octopus app settings. Again, if you are using the Octopus Energy direct method for Predbat then these configuration lines are not required and should be commented out of apps.yaml . You can configure car_charging_now in apps.yaml to point a Home Assistant sensor that indicates that the car is currently charging as a workaround to indicate your car is charging, but the Intelligent API hasn't reported it. The switch switch.predbat_octopus_intelligent_consider_full ( expert mode ) (default is Off) when turned on will cause Predbat to predict when your car battery is full and assume no further charging will occur. This can be useful if Octopus does not know your car battery's state of charge but you have a sensor setup in Predbat ( car_charging_soc ) which does know the current charge level. Predbat will still assume all Octopus charging slots are low rates even if some are not used by your car. The switch switch.predbat_octopus_intelligent_ignore_unplugged ( expert mode ) (default value is off) can be used to prevent Predbat from assuming the car will be charging or that future extra low-rate slots apply when the car is unplugged. This will only work correctly if car_charging_planned is set correctly in apps.yaml to detect your car being plugged in Let the Octopus app control when your car charges. Predbat-led charging Here Predbat plans and can initiate the car charging based on the upcoming low import rate slots Ensure car_charging_limit , car_charging_soc and car_charging_planned are set correctly in apps.yaml to point to the appropriate sensors from your EV (see Car charging config in apps.yaml ) Check (and if necessary add) the sensor response value from the sensor configured in car_charging_planned that is returned when the car is 'plugged in and ready to charge' is in the list of car_charging_planned_response values configured in apps.yaml If your car does not have a state of charge (SoC) sensor you can set switch.predbat_car_charging_manual_soc (for car 0) to On to have Predbat create input_number.predbat_car_charging_manual_soc_kwh which will hold the car's SoC in kWh. For multiple cars, use switch.predbat_car_charging_manual_soc_1/2/3 and input_number.predbat_car_charging_manual_soc_kwh_1/2/3 for cars 1, 2, and 3 respectively. You will need to manually set this to the car's current charge level before charging, Predbat will increment it during charging sessions but will not reset it automatically. NB: input_number.predbat_car_charging_manual_soc_kwh must be set to the current kWh value of your car battery NOT a percentage SoC figure otherwise, Predbat won't know how much energy there currently is in the battery. NB2: If you have car_charging_soc set and working for your car SoC sensor in apps.yaml , switch.predbat_car_charging_manual_soc must be set to Off as otherwise the car SoC sensor will be ignored Ensure switch.predbat_octopus_intelligent_charging in Home Assistant is set to Off Set input_number.predbat_car_charging_rate to the car's charging rate in kW per hour (e.g. 7.5 for 7.5kWh) If you have more than one car then input_number.predbat_car_charging_rate_1 will be the second car etc. Set select.predbat_car_charging_plan_time to the time you want the car charging to be completed by Turn on switch.predbat_car_charging_plan_smart if you want to use the cheapest slots only. When disabled (turned off) all low-rate slots will be used in time order. Low-rate slots are time periods where the import rate is below the threshold determined by input_number.predbat_rate_low_threshold ( expert mode ). By default this threshold is calculated automatically based on future import rates - see Battery margins and metrics options for details on configuring this threshold. You can set input_number.predbat_car_charging_plan_max_price if you want to set a maximum price in pence per kWh to charge your car (e.g. 10p). If you set this to zero, this feature is disabled, and all low-rate slots will be used. This may mean you need to use expert mode and change your low-rate threshold ( input_number.predbat_rate_low_threshold ) to configure which slots should be considered if you have a tariff with more than 2 import rates (e.g. Flux) WARNING: Do not set car_charging_now in apps.yaml or you will create a circular dependency. Predbat will set binary_sensor.predbat_car_charging_slot when it determines the car can be charged; you will need to write a Home Assistant automation based on this sensor to control when your car charges. A sample automation to start/stop car charging using a Zappi car charger and the MyEnergi Zappi integration is as follows, this should be adapted for your charger type and how it controls starting/stopping car charging: alias: Car charging description: \"Start/stop car charging based on Predbat determined slots\" triggers: - trigger: state entity_id: - binary_sensor.predbat_car_charging_slot actions: - choose: - conditions: - condition: state entity_id: binary_sensor.predbat_car_charging_slot state: \"on\" sequence: <commands to turn on your car charger, e.g.> - service: select.select_option data: option: Eco+ target: entity_id: select.myenergi_zappi_charge_mode - conditions: - condition: state entity_id: binary_sensor.predbat_car_charging_slot state: \"off\" sequence: <commands to turn off your car charger, e.g.> - service: select.select_option data: option: Stopped target: entity_id: select.myenergi_zappi_charge_mode mode: single NOTE: Multiple cars can be planned with Predbat. Additional Car charging configurations If you have one charger and multiple cars configured in Predbat then set car_charging_exclusive in apps.yaml to True to indicate that only one car may charge at once (the first car reporting as plugged in will be considered as charging). If you set this to False then it is assumed each car can charge independently and hence two or more could charge at once car_charging_exclusive: - True - True See Car charging filtering and Planned car charging for further car charging setup details. switch.predbat_car_charging_from_battery - When set to On the car can drain the home battery, Predbat will manage the correct level of battery accordingly. When set to Off home battery discharge will be prevented when your car charges, and all load from the car and home will be from the grid. This is achieved by setting the battery discharge rate to 0 during car charging and to the maximum otherwise. The home battery can still charge from the grid/solar in either case. Only use this if Predbat knows your car charging plan, e.g. you are using Intelligent Octopus or you use the car slots in Predbat to control your car charging. input_number.predbat_car_charging_loss gives the percentage amount of energy lost when charging the car (load in the home vs energy added to the battery). A good setting is 0.08 which is 8%. switch.predbat_metric_dynamic_load_adjust (default False) - If turned off then Predbat won't export during times the car is planned to charge even if the car is not charging. Example EV and charger setup Sample setup and Predbat automation to use the cheapest charging slots with no/limited Home Assistant Integration. MG4 EV Vehicle with a Hypervolt Car Charger. There is no 3rd party integration with the MG (so no idea of the car's current SoC), and the Hypervolt car charger doesn't understand when an EV is plugged in. Yet it can be stopped and started with a 3rd party integration. In Home Assistant, create a helper entity (Settings / Devices & Services / Helpers) of type 'Number', check minimum value is set to 0, maximum value to 100, and under Advanced Settings, set 'Unit of Measurement' to '%': Car Max Charge - input_number.car_max_charge Create a 'Dropdown' helper entity that has two options 'true' and 'false' (in lowercase): Car Charger Plugged in - input_select.car_charger_plugged_in Within the apps.yaml configuration file specify the following configuration settings: Find the line for car_charger_battery_size and enter the Car Battery Size in kWh: Example car_charging_battery_size: - 61.7 Specify the Car Charging Limit to use the Car Max Charge helper entity created earlier: car_charging_limit: - 'input_number.car_max_charge' Find car_charging_planned and replace the template Wallbox and Zappi regular expression with your new dropdown helper entity: car_charging_planned: - 'input_select.car_charger_plugged_in' Find car_charging_planned_response and add 'true' to the list: car_charging_planned_response: - 'yes' - 'on' - 'true' If possible, add an entity keeping track of the kWh used for car charging to car_charging_energy . If your charging device doesn't keep track of kWh you can measure the power sent to the car charger (e.g. from the EV charger integration or an energy monitor/smart plug for the EV charger) then you can create another helper entity to convert kW power into kWh: Create a helper entity (Settings / Devices & Services / Helpers) of type 'Integration - Riemann Sum integral': Name : car_energy_used Input sensor : sensor that measures power consumed by the car charger Integration method : Right Riemann sum Metric prefix : k (kilo) Please look into Integration - Riemann sum integral to convert kW into kWh. And add your custom car charging energy sensor in apps.yaml in place of the template Wallbox and Zappi regular expression: Example car_charging_energy: 'sensor.car_energy_used' car_charging_now must be commented out (hashed out) in apps.yaml : #car_charging_now: # - off Save the apps.yaml file and exit. In Home Assistant, turn on the following Predbat control switches: switch.predbat_car_charging_hold switch.predbat_car_charging_manual_soc (for car 0, or switch.predbat_car_charging_manual_soc_1/2/3 for additional cars) switch.predbat_car_charging_plan_smart And turn off the Predbat control switch: switch.predbat_octopus_intelligent_charging HA Charging Slot Automation In Home Assistant (Settings / Automation & Scenes), create an automation to monitor the Predbat car charging slot sensor and turn the charger on and off according to the Predbat plan (the numeric entity id's below would need replacing with the appropriate sensor name for your car charger): alias: Car Charging Slot description: \"\" triggers: - trigger: state entity_id: - binary_sensor.predbat_car_charging_slot actions: - if: - condition: state entity_id: binary_sensor.predbat_car_charging_slot state: \"off\" then: - type: turn_off entity_id: f6de2df0758744aba60f6b5f domain: switch - if: - condition: state entity_id: binary_sensor.predbat_car_charging_slot state: \"on\" then: - type: turn_on entity_id: f6de2df0758744aba60f6b5f domain: switch mode: single Finally, for simplicity, add the below entities to your HA Dashboard so you can set them when needed: Car Max Charge - input_number.car_max_charge Car Manual SoC - input_number.predbat_car_charging_manual_soc_kwh (for car 0) For multiple cars, add input_number.predbat_car_charging_manual_soc_kwh_1/2/3 for cars 1/2/3 Car Charger Plugged in - input_select.car_charger_plugged_in Annoyingly, you have to calculate the kWh your vehicle has in total by taking the Percentage left in the car / 100 * Total Car Battery capacity. For example: 65/100*61.7=40.1 Enter '40.1' into 'Car Manual SoC' and '80%' into 'Car Max charge'. Once the charger is switched to true and your Car Max charge (target SoC) % is higher than the kWh currently in the car, Predbat will plan and charge the car with the kW that are needed to reach the target SoC. Example: Separating car charging costs for multiple cars Predbat provides predbat.cost_today_car and predbat.cost_total_car which give the cost today and total accumulated cost for all car charging. If you have multiple cars with a single EV charger then its not possible to segregate the cost per car. The following solution will accumulate individual charging costs for each car. Create two helper entities of type number to collect the cost per car: yaml input_number.car_car1_cost_today input_number.car_car2_cost_today Min = 0 Max = 10000 Step = 0.01 Predbat accumulates cost in pence/cents, etc so the Max value should be big enough to hold the maximum car charging cost per day (e.g. \u00a310/$10/\u20ac10). Create an automation that triggers when predbat.cost_today_car changes value. Then, based on which car is connected (sensor.car1_connected or sensor.car2_connected in this case), delta of predbat_cost to the appropriate car cost today sensor: yaml alias: Allocate EV Charging Cost description: \"\" triggers: - entity_id: - predbat.cost_today_car trigger: state actions: - variables: new_cost: \"{{ trigger.to_state.state | float }}\" old_cost: \"{{ trigger.from_state.state | float }}\" delta: \"{{ new_cost - old_cost }}\" - condition: template value_template: \"{{ delta > 0 }}\" - choose: - conditions: - condition: template value_template: \"{{ is_state('sensor.car1_connected', 'on') }}\" sequence: - target: entity_id: input_number.car_car1_cost_today data: value: > {{ (states('input_number.car_car1_cost_today') | float) + delta }} action: input_number.set_value - conditions: - condition: template value_template: \"{{ is_state('sensor.car2_connected', 'on') }}\" sequence: - target: entity_id: input_number.car_car2_cost_today data: value: > {{ (states('input_number.car_car2_cost_today') | float) + delta }} action: input_number.set_value mode: single Finally, create an automation that will reset the cost to 0 at midnight every day: yaml alias: Reset Daily EV Car Costs description: \"\" triggers: - at: \"00:00:00\" trigger: time actions: - target: entity_id: - input_number.car_car1_cost_today - input_number.car_car2_cost_today data: value: 0 action: input_number.set_value mode: single","title":"Car charging"},{"location":"car-charging/#car-charging","text":"As a bare minimum, a HA-controllable smart plug with a granny charger could be used, but do consider there could be an electrical spike to the car if the smart plug is turned off when the car is charging. A proper car charger and HA integration are preferable. You will first need to have installed the appropriate Home Assistant integration for your car charger.","title":"Car charging"},{"location":"car-charging/#configure-appsyaml-for-your-car-charging","text":"Start by configuring the car charging settings in apps.yaml with the following car-charging related configuration items: num_cars should be set in apps.yaml to the number of cars you want Predbat to plan for. Set to 0 if you don't have an EV or don't want Predbat to plan for your EV charging (and the remaining car sensors in apps.yaml can safely be commented out or deleted as they won't be required). NB: num_cars must be set correctly regardless of whether you are using Octopus Intelligent Go to control your EV charging or Predbat to control the charging; or else Predbat could start discharging your battery when the EV is charging. car_charging_exclusive should be set to True for each car in apps.yaml if you have multiple cars configured in Predbat, but only one car charger. This indicates that only one car may charge at once (the first car reporting as plugged in will be considered as charging). If you set this to False for each car then it is assumed that the car can charge independently, and hence two or more cars could charge at once. One entry per car. car_charging_exclusive: - True - True","title":"Configure apps.yaml for your car charging"},{"location":"car-charging/#filtering-car-charging-energy-from-house-load","text":"Depending upon how the CT clamps and your inverter and electric car charger have been wired, your inverter may 'see' your EV charging as being part of the house load. This means your house load is artificially raised whenever you charge your car. In this circumstance you might want to remove your electric car charging data from the historical house load data so as to not bias the calculations, otherwise you will get high battery charge levels when the car was charged previously (e.g. last week). TIP: Check the house load being reported by your inverter when your car is charging. If it doesn't include the car charging load then there is no need to follow these steps below (and if you do, you'll artificially deflate your house load). switch.predbat_car_charging_hold - A switch that when turned on (the default) tells Predbat to remove car charging data from your historical house load so that Predbat's battery prediction plan is not distorted by previous car charging. If you are getting erroneous house load predictions in your plan then check this setting and car_charging_energy or input_number.predbat_car_charging_threshold are set correctly. If you don't have an EV then turn switch.predbat_car_charging_hold Off as Predbat will by default still consider any house load in excess of input_number.predbat_car_charging_threshold to be car charging activity and will exclude it. car_charging_energy - Set in apps.yaml to point to an entity which is the daily incrementing kWh data for the car charger. This has been pre-defined as a regular expression that should auto-detect the appropriate Wallbox and Zappi car charger sensors, or edit as necessary in apps.yaml for your charger sensor. Note that this must be configured to point to an 'energy today' sensor in kWh not an instantaneous power sensor (in kW) from the car charger. IMPORTANT: Predbat will subtract all car_charging_energy from your historic house load so if car_charging_energy is not configured with the correct sensor, your car charging energy sensor does not accurately report your car charging data (e.g. it falsely reports charging data when not actually charging), or your house load sensor already excludes car charging, then this will really mess up your predbat plan as Predbat will exclude all car_charging_energy from your load predictions and you could end up with erroneous or zero house load predictions. Do check the entity! NOTE: The car charging energy sensor must be a daily incrementing kWh sensor. Check the history of your sensor in Home Assistant, that it increments through the day when your car is charging, resets to zero at midnight, and does not dip down in value or reset to zero other than at midnight. Some car charger energy sensors do not behave as Predbat requires them to do; for example, they may show cumulative energy per charge, not cumulative charge energy today. You may need to wrap the car charger energy sensor into a daily resetting utility meter to create a sensor that behaves correctly. TIP: You can also use car_charging_energy to remove other house load kWh from the data Predbat uses for the forecast, e.g. if you want to remove Mixergy hot water tank heating data from the forecast such as if you sometimes heat on gas, and sometimes electric depending upon import rates. car_charging_energy can be set to a list of energy sensors, one per line if you have multiple EV car chargers, or want to exclude multiple loads such as heat pump load, e.g.: car_charging_energy: - 're:(sensor.myenergi_zappi_[0-9a-z]+_charge_added_session|sensor.wallbox_portal_added_energy)' - sensor.mixergy_ID_energy - sensor.ashp_energy_today input_number.predbat_car_charging_energy_scale - Used to define a scaling factor (in the range of 0 to 1.0) to multiply the car_charging_energy sensor data by if required (e.g. set to 0.001 to convert Watts to kW). Default 1.0, i.e. no scaling. If you do not have a suitable car charging energy kWh sensor in Home Assistant then comment the car_charging_energy line out of apps.yaml and configure input_number.predbat_car_charging_threshold input_number.predbat_car_charging_threshold (default 6 = 6kW)- Sets the kW power threshold above which home consumption is assumed to be car charging and input_number.predbat_car_charging_rate (in kW) will be subtracted from the historical load data. Used to 'detect' EV charging if you have an EV charger but it does not have an energy today sensor that you can use. If you do not have an EV charger then ensure you set switch.predbat_car_charging_hold to Off otherwise Predbat will assume any house load in excess of car_charging_threshold is EV charging and remove it from your house load predictions!","title":"Filtering Car Charging Energy from house load"},{"location":"car-charging/#planned-car-charging","text":"These features allow Predbat to know when you plan to charge your car. If you have an Intelligent Octopus tariff then planning of charging is done via the Octopus app and Predbat obtains this information through the Octopus Energy integration in Home Assistant. switch.predbat_octopus_intelligent_charging - When this Home Assistant switch is enabled, Predbat will plan charging around the Intelligent Octopus slots, taking it into account for battery load and generating the slot information The following apps.yaml configuration items are pre-defined with regular expressions to point to appropriate sensors in the Octopus Energy integration. You should not normally need to change these if you have the Octopus Intelligent tariff: octopus_intelligent_slot - Points to the Octopus Energy integration 'intelligent dispatching' sensor that indicates whether you are within an Octopus Energy \"smart charge\" slot, and provides the list of future planned charging activity. octopus_ready_time - Points to the Octopus Energy integration sensor that details when the car charging will be completed. Note: the Octopus Integration now provides Octopus Intelligent target time in two formats, either a 'select' entity or a 'time' entity. Predbat uses the time entity (time.octopus_energy_{{DEVICE_ID}}_intelligent_target_time) which is disabled by default, so you will need to enable the time entity and disable the matching select entity. octopus_charge_limit - Points to the Octopus Energy integration sensor that provides the car charging limit. octopus_slot_low_rate - Default is True, meaning any Octopus Intelligent Slot reported will be at the lowest rate if at home. If False the existing rates only will be used which is only suitable for tariffs other than IOG. octopus_slot_max - Default is 48 (disabled). Sets the maximum number of 30-minute cheap rate slots per 24-hour period. Octopus Intelligent users maybe from March 2026 limited to 6 hours of cheap charging per day. Slots beyond this limit will use standard rates. Its recommended you set this to 12 (for 6 hours) once Octopus enforce this Octopus Intelligent limit. If you don't use Intelligent Octopus then the above Octopus Intelligent configuration lines in apps.yaml can be commented out or deleted, and there are a number of other apps.yaml configuration items that should be set: car_charging_planned - Optional, can be set to a Home Assistant sensor (e.g. from your car charger integration) which lets Predbat know the car is plugged in and planned to charge during low-rate slots. Or manually set it to 'False' to disable this feature, or 'True' to always enable it. The apps.yaml template supplied with Predbat comes pre-configured with a regular expression that should automatically match Zappi or Wallbox car chargers. If you have a different type of charger you will need to configure it manually. car_charging_planned_response - An array of values for the above car_charging_planned sensor which indicate that the car is plugged in and will charge in the next low rate slot. The template apps.yaml comes with a set of pre-defined sensor values that should match most EV chargers. Customise for your car charger sensor if it sets sensor values that are not in the list. car_charging_now - For some cases finding details of planned car charging is difficult. The car_charging_now configuration item can be set to point to a Home Assistant sensor that tells you that the car is currently charging. Predbat will then assume this slot is used for charging regardless of the plan. If Octopus Intelligent Charging is enabled and car_charging_now indicates the car is charging then Predbat will also assume that this is a low rate slot for the car/house (and might therefore start charging the battery), otherwise electricity import rates are taken from the normal rate data. WARNING: Some cars will briefly start charging as soon as they are plugged in, which Predbat will detect and assume that this is a low rate slot even when it isn't. It is therefore recommended that you do NOT set car_charging_now unless you have problems with the Octopus Intelligent slots, and car_charging_now should be commented out in apps.yaml . CAUTION: It is strongly recommended to not use car_charging_now with Predbat-led charging unless you can't make it work any other way as Predbat will assume all car charging is at a low rate. car_charging_now_response - Set to the range of positive responses for car_charging_now to indicate that the car is charging. Useful if you have a sensor for your car charger that isn't binary. To make Predbat planned car charging more accurate, configure the following items in apps.yaml : car_charging_battery_size - Set this value in apps.yaml to the car's battery size in kWh which must be entered with one decimal place, e.g. 50.0. If not set, Predbat defaults to 100.0kWh. This will be used to predict when to stop car charging. car_charging_limit - You should configure this to point to a sensor that specifies the % limit the car is set to charge to. This could be a sensor on the EV charger integration or a Home Assistant helper entity you can set as you wish. If you don't specify a sensor Predbat will default to 100% - i.e. fill the car to full. car_charging_soc - You should configure this to point to a sensor (on the HA integration for your EV charger) that specifies the car's current charge level expressed as a percentage - it must NOT be set to a sensor that gives the car's current kWh value as this will cause Predbat to charge the car to an incorrect level. If you don't specify a sensor, Predbat will default to 0%. If you have multiple electric cars then car_charging_soc should be set to a list of sensors, e.g.: car_charging_soc: - 'sensor.tsunami_battery' - 'sensor.toyota_XXX_battery_level'","title":"Planned Car Charging"},{"location":"car-charging/#multiple-electric-cars","text":"Multiple cars can be planned with Predbat, in which case you should set num_cars in apps.yaml to the number of cars you want to plan. car_charging_limit , car_charging_planned , car_charging_battery_size and car_charging_soc must then be a list of values (i.e. 2 entries for 2 cars) If you have Intelligent Octopus then Car 0 will be managed by the Octopus Energy integration, if it's enabled. Each car will have its own Home Assistant slot sensor created e.g. binary_sensor.predbat_car_charging_slot_1 , SoC planning sensor e.g predbat.car_soc_1 and predbat.car_soc_best_1 for car 1 An excellent worked example of setting up multiple car charging with Predbat is in the 'Show and tell' part of Predbat's GitHub.","title":"Multiple Electric Cars"},{"location":"car-charging/#ohme-car-charger-direct-integration","text":"Predbat can talk directly to the Ohme charger by configuring your Ohme account details in apps.yaml . When ohme_automatic_octopus_intelligent is set to True then Predbat is automatically configured to take Octopus Intelligent car charging slots from Ohme (rather than from Octopus Intelligent directly). ohme_login: \"user@domain\" ohme_password: \"xxxxxxxxx\" ohme_automatic_octopus_intelligent: true NOTE: It's recommended to store ohme_password in secrets.yaml and reference it as ohme_password: !secret ohme_password - see Storing secrets .","title":"Ohme car charger direct integration"},{"location":"car-charging/#car-charging-planning","text":"There are two ways that Predbat can plan the slots for charging your car:","title":"Car Charging Planning"},{"location":"car-charging/#octopus-led-charging","text":"If you have the Intelligent Octopus import tariff, have completed enrollment of your car/charger to Intelligent Octopus (requires a compatible charger or car), and you have installed the Octopus Energy integration - in which case Predbat will use the car charging slots allocated by Octopus Energy in battery prediction. The Octopus Energy integration supports Octopus Intelligent , and through that, Predbat gets most of the information it needs. octopus_intelligent_slot in apps.yaml is pre-configured with a regular expression to point to the Intelligent Slot sensor in the Octopus Energy integration. You should not need to change this, but it is worth checking the Predbat logfile to confirm that it has found your EV charger details. If you are using the Octopus Energy direct method of Predbat directly connecting to your Octopus account then this configuration line is not required and should be commented out of apps.yaml . Set switch.predbat_octopus_intelligent_charging to On You should set the car's current SoC sensor, car_charging_soc in apps.yaml to point to a Home Assistant sensor that specifies the car's current % charge level to have accurate results. This should normally be a sensor provided by your car charger. If you don't have this available for your charger then Predbat will assume the car's current charge level is 0%. If you set car_charging_limit in apps.yaml then Predbat can also know if the car's limit is set lower than in Intelligent Octopus. If you don't set this Predbat will default to 100%. octopus_charge_limit and octopus_ready_time in apps.yaml are pre-configured with regular expressions to point to the appropriate sensors for your EV charger in the Octopus Energy integration. These retrieve details of the charge limit and when the car will finish charging from your Octopus app settings. Again, if you are using the Octopus Energy direct method for Predbat then these configuration lines are not required and should be commented out of apps.yaml . You can configure car_charging_now in apps.yaml to point a Home Assistant sensor that indicates that the car is currently charging as a workaround to indicate your car is charging, but the Intelligent API hasn't reported it. The switch switch.predbat_octopus_intelligent_consider_full ( expert mode ) (default is Off) when turned on will cause Predbat to predict when your car battery is full and assume no further charging will occur. This can be useful if Octopus does not know your car battery's state of charge but you have a sensor setup in Predbat ( car_charging_soc ) which does know the current charge level. Predbat will still assume all Octopus charging slots are low rates even if some are not used by your car. The switch switch.predbat_octopus_intelligent_ignore_unplugged ( expert mode ) (default value is off) can be used to prevent Predbat from assuming the car will be charging or that future extra low-rate slots apply when the car is unplugged. This will only work correctly if car_charging_planned is set correctly in apps.yaml to detect your car being plugged in Let the Octopus app control when your car charges.","title":"Octopus-led charging"},{"location":"car-charging/#predbat-led-charging","text":"Here Predbat plans and can initiate the car charging based on the upcoming low import rate slots Ensure car_charging_limit , car_charging_soc and car_charging_planned are set correctly in apps.yaml to point to the appropriate sensors from your EV (see Car charging config in apps.yaml ) Check (and if necessary add) the sensor response value from the sensor configured in car_charging_planned that is returned when the car is 'plugged in and ready to charge' is in the list of car_charging_planned_response values configured in apps.yaml If your car does not have a state of charge (SoC) sensor you can set switch.predbat_car_charging_manual_soc (for car 0) to On to have Predbat create input_number.predbat_car_charging_manual_soc_kwh which will hold the car's SoC in kWh. For multiple cars, use switch.predbat_car_charging_manual_soc_1/2/3 and input_number.predbat_car_charging_manual_soc_kwh_1/2/3 for cars 1, 2, and 3 respectively. You will need to manually set this to the car's current charge level before charging, Predbat will increment it during charging sessions but will not reset it automatically. NB: input_number.predbat_car_charging_manual_soc_kwh must be set to the current kWh value of your car battery NOT a percentage SoC figure otherwise, Predbat won't know how much energy there currently is in the battery. NB2: If you have car_charging_soc set and working for your car SoC sensor in apps.yaml , switch.predbat_car_charging_manual_soc must be set to Off as otherwise the car SoC sensor will be ignored Ensure switch.predbat_octopus_intelligent_charging in Home Assistant is set to Off Set input_number.predbat_car_charging_rate to the car's charging rate in kW per hour (e.g. 7.5 for 7.5kWh) If you have more than one car then input_number.predbat_car_charging_rate_1 will be the second car etc. Set select.predbat_car_charging_plan_time to the time you want the car charging to be completed by Turn on switch.predbat_car_charging_plan_smart if you want to use the cheapest slots only. When disabled (turned off) all low-rate slots will be used in time order. Low-rate slots are time periods where the import rate is below the threshold determined by input_number.predbat_rate_low_threshold ( expert mode ). By default this threshold is calculated automatically based on future import rates - see Battery margins and metrics options for details on configuring this threshold. You can set input_number.predbat_car_charging_plan_max_price if you want to set a maximum price in pence per kWh to charge your car (e.g. 10p). If you set this to zero, this feature is disabled, and all low-rate slots will be used. This may mean you need to use expert mode and change your low-rate threshold ( input_number.predbat_rate_low_threshold ) to configure which slots should be considered if you have a tariff with more than 2 import rates (e.g. Flux) WARNING: Do not set car_charging_now in apps.yaml or you will create a circular dependency. Predbat will set binary_sensor.predbat_car_charging_slot when it determines the car can be charged; you will need to write a Home Assistant automation based on this sensor to control when your car charges. A sample automation to start/stop car charging using a Zappi car charger and the MyEnergi Zappi integration is as follows, this should be adapted for your charger type and how it controls starting/stopping car charging: alias: Car charging description: \"Start/stop car charging based on Predbat determined slots\" triggers: - trigger: state entity_id: - binary_sensor.predbat_car_charging_slot actions: - choose: - conditions: - condition: state entity_id: binary_sensor.predbat_car_charging_slot state: \"on\" sequence: <commands to turn on your car charger, e.g.> - service: select.select_option data: option: Eco+ target: entity_id: select.myenergi_zappi_charge_mode - conditions: - condition: state entity_id: binary_sensor.predbat_car_charging_slot state: \"off\" sequence: <commands to turn off your car charger, e.g.> - service: select.select_option data: option: Stopped target: entity_id: select.myenergi_zappi_charge_mode mode: single NOTE: Multiple cars can be planned with Predbat.","title":"Predbat-led charging"},{"location":"car-charging/#additional-car-charging-configurations","text":"If you have one charger and multiple cars configured in Predbat then set car_charging_exclusive in apps.yaml to True to indicate that only one car may charge at once (the first car reporting as plugged in will be considered as charging). If you set this to False then it is assumed each car can charge independently and hence two or more could charge at once car_charging_exclusive: - True - True See Car charging filtering and Planned car charging for further car charging setup details. switch.predbat_car_charging_from_battery - When set to On the car can drain the home battery, Predbat will manage the correct level of battery accordingly. When set to Off home battery discharge will be prevented when your car charges, and all load from the car and home will be from the grid. This is achieved by setting the battery discharge rate to 0 during car charging and to the maximum otherwise. The home battery can still charge from the grid/solar in either case. Only use this if Predbat knows your car charging plan, e.g. you are using Intelligent Octopus or you use the car slots in Predbat to control your car charging. input_number.predbat_car_charging_loss gives the percentage amount of energy lost when charging the car (load in the home vs energy added to the battery). A good setting is 0.08 which is 8%. switch.predbat_metric_dynamic_load_adjust (default False) - If turned off then Predbat won't export during times the car is planned to charge even if the car is not charging.","title":"Additional Car charging configurations"},{"location":"car-charging/#example-ev-and-charger-setup","text":"Sample setup and Predbat automation to use the cheapest charging slots with no/limited Home Assistant Integration. MG4 EV Vehicle with a Hypervolt Car Charger. There is no 3rd party integration with the MG (so no idea of the car's current SoC), and the Hypervolt car charger doesn't understand when an EV is plugged in. Yet it can be stopped and started with a 3rd party integration. In Home Assistant, create a helper entity (Settings / Devices & Services / Helpers) of type 'Number', check minimum value is set to 0, maximum value to 100, and under Advanced Settings, set 'Unit of Measurement' to '%': Car Max Charge - input_number.car_max_charge Create a 'Dropdown' helper entity that has two options 'true' and 'false' (in lowercase): Car Charger Plugged in - input_select.car_charger_plugged_in Within the apps.yaml configuration file specify the following configuration settings: Find the line for car_charger_battery_size and enter the Car Battery Size in kWh: Example car_charging_battery_size: - 61.7 Specify the Car Charging Limit to use the Car Max Charge helper entity created earlier: car_charging_limit: - 'input_number.car_max_charge' Find car_charging_planned and replace the template Wallbox and Zappi regular expression with your new dropdown helper entity: car_charging_planned: - 'input_select.car_charger_plugged_in' Find car_charging_planned_response and add 'true' to the list: car_charging_planned_response: - 'yes' - 'on' - 'true' If possible, add an entity keeping track of the kWh used for car charging to car_charging_energy . If your charging device doesn't keep track of kWh you can measure the power sent to the car charger (e.g. from the EV charger integration or an energy monitor/smart plug for the EV charger) then you can create another helper entity to convert kW power into kWh: Create a helper entity (Settings / Devices & Services / Helpers) of type 'Integration - Riemann Sum integral': Name : car_energy_used Input sensor : sensor that measures power consumed by the car charger Integration method : Right Riemann sum Metric prefix : k (kilo) Please look into Integration - Riemann sum integral to convert kW into kWh. And add your custom car charging energy sensor in apps.yaml in place of the template Wallbox and Zappi regular expression: Example car_charging_energy: 'sensor.car_energy_used' car_charging_now must be commented out (hashed out) in apps.yaml : #car_charging_now: # - off Save the apps.yaml file and exit. In Home Assistant, turn on the following Predbat control switches: switch.predbat_car_charging_hold switch.predbat_car_charging_manual_soc (for car 0, or switch.predbat_car_charging_manual_soc_1/2/3 for additional cars) switch.predbat_car_charging_plan_smart And turn off the Predbat control switch: switch.predbat_octopus_intelligent_charging HA Charging Slot Automation In Home Assistant (Settings / Automation & Scenes), create an automation to monitor the Predbat car charging slot sensor and turn the charger on and off according to the Predbat plan (the numeric entity id's below would need replacing with the appropriate sensor name for your car charger): alias: Car Charging Slot description: \"\" triggers: - trigger: state entity_id: - binary_sensor.predbat_car_charging_slot actions: - if: - condition: state entity_id: binary_sensor.predbat_car_charging_slot state: \"off\" then: - type: turn_off entity_id: f6de2df0758744aba60f6b5f domain: switch - if: - condition: state entity_id: binary_sensor.predbat_car_charging_slot state: \"on\" then: - type: turn_on entity_id: f6de2df0758744aba60f6b5f domain: switch mode: single Finally, for simplicity, add the below entities to your HA Dashboard so you can set them when needed: Car Max Charge - input_number.car_max_charge Car Manual SoC - input_number.predbat_car_charging_manual_soc_kwh (for car 0) For multiple cars, add input_number.predbat_car_charging_manual_soc_kwh_1/2/3 for cars 1/2/3 Car Charger Plugged in - input_select.car_charger_plugged_in Annoyingly, you have to calculate the kWh your vehicle has in total by taking the Percentage left in the car / 100 * Total Car Battery capacity. For example: 65/100*61.7=40.1 Enter '40.1' into 'Car Manual SoC' and '80%' into 'Car Max charge'. Once the charger is switched to true and your Car Max charge (target SoC) % is higher than the kWh currently in the car, Predbat will plan and charge the car with the kW that are needed to reach the target SoC.","title":"Example EV and charger setup"},{"location":"car-charging/#example-separating-car-charging-costs-for-multiple-cars","text":"Predbat provides predbat.cost_today_car and predbat.cost_total_car which give the cost today and total accumulated cost for all car charging. If you have multiple cars with a single EV charger then its not possible to segregate the cost per car. The following solution will accumulate individual charging costs for each car. Create two helper entities of type number to collect the cost per car: yaml input_number.car_car1_cost_today input_number.car_car2_cost_today Min = 0 Max = 10000 Step = 0.01 Predbat accumulates cost in pence/cents, etc so the Max value should be big enough to hold the maximum car charging cost per day (e.g. \u00a310/$10/\u20ac10). Create an automation that triggers when predbat.cost_today_car changes value. Then, based on which car is connected (sensor.car1_connected or sensor.car2_connected in this case), delta of predbat_cost to the appropriate car cost today sensor: yaml alias: Allocate EV Charging Cost description: \"\" triggers: - entity_id: - predbat.cost_today_car trigger: state actions: - variables: new_cost: \"{{ trigger.to_state.state | float }}\" old_cost: \"{{ trigger.from_state.state | float }}\" delta: \"{{ new_cost - old_cost }}\" - condition: template value_template: \"{{ delta > 0 }}\" - choose: - conditions: - condition: template value_template: \"{{ is_state('sensor.car1_connected', 'on') }}\" sequence: - target: entity_id: input_number.car_car1_cost_today data: value: > {{ (states('input_number.car_car1_cost_today') | float) + delta }} action: input_number.set_value - conditions: - condition: template value_template: \"{{ is_state('sensor.car2_connected', 'on') }}\" sequence: - target: entity_id: input_number.car_car2_cost_today data: value: > {{ (states('input_number.car_car2_cost_today') | float) + delta }} action: input_number.set_value mode: single Finally, create an automation that will reset the cost to 0 at midnight every day: yaml alias: Reset Daily EV Car Costs description: \"\" triggers: - at: \"00:00:00\" trigger: time actions: - target: entity_id: - input_number.car_car1_cost_today - input_number.car_car2_cost_today data: value: 0 action: input_number.set_value mode: single","title":"Example: Separating car charging costs for multiple cars"},{"location":"caution/","text":"Some words of caution Predbat is a powerful hobbyist system that can control many home battery and solar systems. While every attempt has been made to make it as easy to use as possible, it does require a certain amount of technical skill. Increased energy costs While Predbat will normally save you money, an incorrectly configured system can cause your battery to be poorly managed and may increase your electricity bills. I recommend carefully reviewing what your installation is doing once you have enabled it for the first time. Flash memory Some inverters use flash memory with a limited lifespan. Depending on how register writes are managed, the controller can reduce this lifespan. In normal operation, this should not be an issue, but if your setup performs a large number of register writes continuously, you could eventually encounter problems. For example, on a current GivEnergy inverter, it's estimated that the usable limit is around 1 million register writes (although firmware changes may increase this limit). This would allow approximately 270 writes per day, or one every 5 minutes. Each change of inverter mode requires multiple register writes \u2014 e.g. charge start time, end time, scheduled charge enable, set battery pause mode, etc. \u2014 which could total around 6 registers. This means one change of mode every slot, (by default) every 30 minutes, on average, would be acceptable. However, as most plans include longer intervals (often hours) where the battery is in Demand mode, Charging, or Exporting \u2014 during which registers are not updated \u2014 it is unlikely that this limit will be exceeded. As different inverter designs may have different limits, it's wise to avoid making your plan too complex if it doesn't result in meaningful gains. Things you can do to have a less complex plan include: Keep 'calculate export within charge slots' off Set metric battery cycle to a small non-zero value e.g. 0.5 Set a metric min improvement export to a small value e.g. 5p Ensure inverter losses are set to a representative value Turn off charge_low_power mode Avoid using balance inverters ('switch.predbat_balance_inverters_enable') which can make register changes once or twice a minute unless you are sure this is not an issue Predbat creates an entity called predbat.inverter_register_writes which can be used to check the total number of writes across all inverters. If you divide this by the period of use and by the number of inverters, you will be able to figure out the actual rate of register writes - see the Simple inverter writes dashboard . If you do use Predbat's balance inverters function, then you are strongly recommended to turn on \"real time registers\" using switch.givtcp_xxxx_real_time_control for GivEnergy inverters controlled via GivTCP, or an equivalent function for your inverter.","title":"Words of caution"},{"location":"caution/#some-words-of-caution","text":"Predbat is a powerful hobbyist system that can control many home battery and solar systems. While every attempt has been made to make it as easy to use as possible, it does require a certain amount of technical skill.","title":"Some words of caution"},{"location":"caution/#increased-energy-costs","text":"While Predbat will normally save you money, an incorrectly configured system can cause your battery to be poorly managed and may increase your electricity bills. I recommend carefully reviewing what your installation is doing once you have enabled it for the first time.","title":"Increased energy costs"},{"location":"caution/#flash-memory","text":"Some inverters use flash memory with a limited lifespan. Depending on how register writes are managed, the controller can reduce this lifespan. In normal operation, this should not be an issue, but if your setup performs a large number of register writes continuously, you could eventually encounter problems. For example, on a current GivEnergy inverter, it's estimated that the usable limit is around 1 million register writes (although firmware changes may increase this limit). This would allow approximately 270 writes per day, or one every 5 minutes. Each change of inverter mode requires multiple register writes \u2014 e.g. charge start time, end time, scheduled charge enable, set battery pause mode, etc. \u2014 which could total around 6 registers. This means one change of mode every slot, (by default) every 30 minutes, on average, would be acceptable. However, as most plans include longer intervals (often hours) where the battery is in Demand mode, Charging, or Exporting \u2014 during which registers are not updated \u2014 it is unlikely that this limit will be exceeded. As different inverter designs may have different limits, it's wise to avoid making your plan too complex if it doesn't result in meaningful gains. Things you can do to have a less complex plan include: Keep 'calculate export within charge slots' off Set metric battery cycle to a small non-zero value e.g. 0.5 Set a metric min improvement export to a small value e.g. 5p Ensure inverter losses are set to a representative value Turn off charge_low_power mode Avoid using balance inverters ('switch.predbat_balance_inverters_enable') which can make register changes once or twice a minute unless you are sure this is not an issue Predbat creates an entity called predbat.inverter_register_writes which can be used to check the total number of writes across all inverters. If you divide this by the period of use and by the number of inverters, you will be able to figure out the actual rate of register writes - see the Simple inverter writes dashboard . If you do use Predbat's balance inverters function, then you are strongly recommended to turn on \"real time registers\" using switch.givtcp_xxxx_real_time_control for GivEnergy inverters controlled via GivTCP, or an equivalent function for your inverter.","title":"Flash memory"},{"location":"compare/","text":"Comparing Energy Tariffs While it is quite easy to go off and compare your historical usage against various energy tariffs with existing apps, it is much harder to perform a what-if analysis as the way you control your battery would be different depending on the tariff. For this reason, Predbat offers an energy rate comparison to allow you to know if you are on the best available tariff or when it might be time to switch. Once you have given Predbat a list of tariffs that you want to compare then it will update its predictions daily and keep a history of these over time. If you do decide to switch to Octopus Energy after using this feature please consider using my referral link so we can both save some money: https://share.octopus.energy/jolly-eel-176 Its recommended to watch the YouTube video on Energy tariff comparison as this explains the feature in more detail and what the different columns of the comparison mean. Limitations Keep in mind this is an approximation of costs for the following 24-hour period and the reality could be different. In particular, car charging costs are unlikely to reflect the true picture as it will only be planned after you plug in. Smart tariffs like Octopus Intelligent Go can give you extra cheap car slots, and Octopus Intelligent Flux where Octopus controls the charging/discharging, mean these tariffs cannot be predicted as accurately. When changing tariffs, you should use your judgment, the Predbat Compare data is only a helpful guide. Configuring the tariff's to compare First, you need to tell Predbat in apps.yaml which tariffs you want to compare, you should list all the tariffs you realistically might want to switch between, including your current tariff to act as a baseline. Below is a suggestion of various Octopus tariff combinations (valid October 2025) against region A. You will need to change dno_region to match your region code if you decide to use this template - see list of Electricity region codes . From time to time Octopus change and withdraw their tariffs so the URL's the compare function uses might stop working. A full list of available Octopus products is at https://api.octopus.energy/v1/products/ . If you view this page, search for the tariff by name, then copy the URL it shows into a new tab. E.g. https://api.octopus.energy/v1/products/GO-VAR-22-10-14/ Look through that page to find the right URL for usage charges in your DNO area https://api.octopus.energy/v1/products/GO-VAR-22-10-14/electricity-tariffs/E-1R-GO-VAR-22-10-14-A/standard-unit-rates (For area A) As well as Octopus rate URLs (rates_import_octopus_url/rates_export_octopus_url) you can use manual rates (rates_import/rates_export), Octopus integration rates (metric_octopus_import/metric_octopus_export) and Energi Data service rates (metric_energidataservice_import/metric_energidataservice_export). Each tariff must be given an ID which will be used to create a sensor to track predicted cost over time, the full name is used in the description of that sensor and on the web page. The ID can contain alphanumeric characters or underscores; do not use slashes, commas, spaces or other special characters in the ID or predbat will crash when running the compare! If you do not set an import or export rate for a particular tariff then your existing energy rates will be used. # Tariff comparison feature # # Adjust this list to the tariffs you want to compare, include your current tariff also # DNO region code (see https://energy-stats.uk/dno-region-codes-explained/) dno_region: \"A\" compare_list: - id: 'current' name: 'Current Tariff' - id: 'cap_seg' name: 'Price cap import/SEG export' rates_import: - rate: 24.86 rates_export: - rate: 4.1 - id: 'eon_next_drive' name: 'Eon Next Drive import/Fixed export' rates_import: - rate: 6.7 start: \"00:00:00\" end: \"07:00:00\" - rate: 24.86 start: \"07:00:00\" end: \"00:00:00\" rates_export: - rate: 16.5 - id: 'igo_fixed' name: 'Intelligent GO import/Fixed export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/INTELLI-VAR-24-10-29/electricity-tariffs/E-1R-INTELLI-VAR-24-10-29-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/OUTGOING-VAR-24-10-26/electricity-tariffs/E-1R-OUTGOING-VAR-24-10-26-{dno_region}/standard-unit-rates/' - id: 'igo_agile' name: 'Intelligent GO import/Agile export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/INTELLI-VAR-24-10-29/electricity-tariffs/E-1R-INTELLI-VAR-24-10-29-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-OUTGOING-19-05-13/electricity-tariffs/E-1R-AGILE-OUTGOING-19-05-13-{dno_region}/standard-unit-rates/' - id: 'go_fixed' name: 'GO import/Fixed export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/GO-VAR-22-10-14/electricity-tariffs/E-1R-GO-VAR-22-10-14-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/OUTGOING-VAR-24-10-26/electricity-tariffs/E-1R-OUTGOING-VAR-24-10-26-{dno_region}/standard-unit-rates/' - id: 'go_agile' name: 'GO import/Agile export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/GO-VAR-22-10-14/electricity-tariffs/E-1R-GO-VAR-22-10-14-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-OUTGOING-19-05-13/electricity-tariffs/E-1R-AGILE-OUTGOING-19-05-13-{dno_region}/standard-unit-rates/' - id: 'agile_fixed' name: 'Agile import/Fixed export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-24-10-01/electricity-tariffs/E-1R-AGILE-24-10-01-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/OUTGOING-VAR-24-10-26/electricity-tariffs/E-1R-OUTGOING-VAR-24-10-26-{dno_region}/standard-unit-rates/' - id: 'agile_agile' name: 'Agile import/Agile export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-24-10-01/electricity-tariffs/E-1R-AGILE-24-10-01-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-OUTGOING-19-05-13/electricity-tariffs/E-1R-AGILE-OUTGOING-19-05-13-{dno_region}/standard-unit-rates/' - id: 'flux' name: 'Flux import/Export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/FLUX-IMPORT-23-02-14/electricity-tariffs/E-1R-FLUX-IMPORT-23-02-14-{dno_region}/standard-unit-rates' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/FLUX-EXPORT-23-02-14/electricity-tariffs/E-1R-FLUX-EXPORT-23-02-14-{dno_region}/standard-unit-rates' - id: 'cosy_fixed' name: 'Cosy import/Fixed export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/COSY-22-12-08/electricity-tariffs/E-1R-COSY-22-12-08-{dno_region}/standard-unit-rates' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/OUTGOING-VAR-24-10-26/electricity-tariffs/E-1R-OUTGOING-VAR-24-10-26-{dno_region}/standard-unit-rates/' - id: 'cosy_agile' name: 'Cosy import/Agile export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/COSY-22-12-08/electricity-tariffs/E-1R-COSY-22-12-08-{dno_region}/standard-unit-rates' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-OUTGOING-19-05-13/electricity-tariffs/E-1R-AGILE-OUTGOING-19-05-13-{dno_region}/standard-unit-rates/' - id: 'snug_fixed' name: 'Snug import/Fixed export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/SNUG-24-11-07/electricity-tariffs/E-1R-SNUG-24-11-07-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/OUTGOING-VAR-24-10-26/electricity-tariffs/E-1R-OUTGOING-VAR-24-10-26-{dno_region}/standard-unit-rates/' - id: 'iflux' name: 'Intelligent Flux import/export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/INTELLI-FLUX-IMPORT-23-07-14/electricity-tariffs/E-1R-INTELLI-FLUX-IMPORT-23-07-14-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/INTELLI-FLUX-EXPORT-23-07-14/electricity-tariffs/E-1R-INTELLI-FLUX-EXPORT-23-07-14-{dno_region}/standard-unit-rates/' Running a comparison By default, the comparison will be run at Midnight every night and saved for the entire day. You can view the comparison on the Predbat web interface under the 'Compare' view. You can manually trigger a new comparison by hitting the 'Compare now' button, or by turning on switch.predbat_compare_active . When a compare is running switch.predbat_compare_active will be turned on, otherwise it will be off. Predbat will highlight which tariff may be the best cost-wise for the next 24-hour period based on the plan optimisation metrics you have defined. The metric includes the value of the contents of your battery and iBoost that has been diverted during this period. The predicted cost is also shown, but keep in mind ending the day with an empty battery may be cheaper today but cost more tomorrow. Comparison sensors For each tariff a new sensor is created in Home Assistant called predbat.compare_tariff_id where id is the ID name you entered above in apps.yaml. This sensor will track the cost as its main value and many details about the prediction in its attributes. You can create charts from these sensors to show how the different tariffs compare on a daily basis.","title":"Comparing Energy Tariffs"},{"location":"compare/#comparing-energy-tariffs","text":"While it is quite easy to go off and compare your historical usage against various energy tariffs with existing apps, it is much harder to perform a what-if analysis as the way you control your battery would be different depending on the tariff. For this reason, Predbat offers an energy rate comparison to allow you to know if you are on the best available tariff or when it might be time to switch. Once you have given Predbat a list of tariffs that you want to compare then it will update its predictions daily and keep a history of these over time. If you do decide to switch to Octopus Energy after using this feature please consider using my referral link so we can both save some money: https://share.octopus.energy/jolly-eel-176 Its recommended to watch the YouTube video on Energy tariff comparison as this explains the feature in more detail and what the different columns of the comparison mean.","title":"Comparing Energy Tariffs"},{"location":"compare/#limitations","text":"Keep in mind this is an approximation of costs for the following 24-hour period and the reality could be different. In particular, car charging costs are unlikely to reflect the true picture as it will only be planned after you plug in. Smart tariffs like Octopus Intelligent Go can give you extra cheap car slots, and Octopus Intelligent Flux where Octopus controls the charging/discharging, mean these tariffs cannot be predicted as accurately. When changing tariffs, you should use your judgment, the Predbat Compare data is only a helpful guide.","title":"Limitations"},{"location":"compare/#configuring-the-tariffs-to-compare","text":"First, you need to tell Predbat in apps.yaml which tariffs you want to compare, you should list all the tariffs you realistically might want to switch between, including your current tariff to act as a baseline. Below is a suggestion of various Octopus tariff combinations (valid October 2025) against region A. You will need to change dno_region to match your region code if you decide to use this template - see list of Electricity region codes . From time to time Octopus change and withdraw their tariffs so the URL's the compare function uses might stop working. A full list of available Octopus products is at https://api.octopus.energy/v1/products/ . If you view this page, search for the tariff by name, then copy the URL it shows into a new tab. E.g. https://api.octopus.energy/v1/products/GO-VAR-22-10-14/ Look through that page to find the right URL for usage charges in your DNO area https://api.octopus.energy/v1/products/GO-VAR-22-10-14/electricity-tariffs/E-1R-GO-VAR-22-10-14-A/standard-unit-rates (For area A) As well as Octopus rate URLs (rates_import_octopus_url/rates_export_octopus_url) you can use manual rates (rates_import/rates_export), Octopus integration rates (metric_octopus_import/metric_octopus_export) and Energi Data service rates (metric_energidataservice_import/metric_energidataservice_export). Each tariff must be given an ID which will be used to create a sensor to track predicted cost over time, the full name is used in the description of that sensor and on the web page. The ID can contain alphanumeric characters or underscores; do not use slashes, commas, spaces or other special characters in the ID or predbat will crash when running the compare! If you do not set an import or export rate for a particular tariff then your existing energy rates will be used. # Tariff comparison feature # # Adjust this list to the tariffs you want to compare, include your current tariff also # DNO region code (see https://energy-stats.uk/dno-region-codes-explained/) dno_region: \"A\" compare_list: - id: 'current' name: 'Current Tariff' - id: 'cap_seg' name: 'Price cap import/SEG export' rates_import: - rate: 24.86 rates_export: - rate: 4.1 - id: 'eon_next_drive' name: 'Eon Next Drive import/Fixed export' rates_import: - rate: 6.7 start: \"00:00:00\" end: \"07:00:00\" - rate: 24.86 start: \"07:00:00\" end: \"00:00:00\" rates_export: - rate: 16.5 - id: 'igo_fixed' name: 'Intelligent GO import/Fixed export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/INTELLI-VAR-24-10-29/electricity-tariffs/E-1R-INTELLI-VAR-24-10-29-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/OUTGOING-VAR-24-10-26/electricity-tariffs/E-1R-OUTGOING-VAR-24-10-26-{dno_region}/standard-unit-rates/' - id: 'igo_agile' name: 'Intelligent GO import/Agile export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/INTELLI-VAR-24-10-29/electricity-tariffs/E-1R-INTELLI-VAR-24-10-29-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-OUTGOING-19-05-13/electricity-tariffs/E-1R-AGILE-OUTGOING-19-05-13-{dno_region}/standard-unit-rates/' - id: 'go_fixed' name: 'GO import/Fixed export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/GO-VAR-22-10-14/electricity-tariffs/E-1R-GO-VAR-22-10-14-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/OUTGOING-VAR-24-10-26/electricity-tariffs/E-1R-OUTGOING-VAR-24-10-26-{dno_region}/standard-unit-rates/' - id: 'go_agile' name: 'GO import/Agile export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/GO-VAR-22-10-14/electricity-tariffs/E-1R-GO-VAR-22-10-14-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-OUTGOING-19-05-13/electricity-tariffs/E-1R-AGILE-OUTGOING-19-05-13-{dno_region}/standard-unit-rates/' - id: 'agile_fixed' name: 'Agile import/Fixed export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-24-10-01/electricity-tariffs/E-1R-AGILE-24-10-01-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/OUTGOING-VAR-24-10-26/electricity-tariffs/E-1R-OUTGOING-VAR-24-10-26-{dno_region}/standard-unit-rates/' - id: 'agile_agile' name: 'Agile import/Agile export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-24-10-01/electricity-tariffs/E-1R-AGILE-24-10-01-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-OUTGOING-19-05-13/electricity-tariffs/E-1R-AGILE-OUTGOING-19-05-13-{dno_region}/standard-unit-rates/' - id: 'flux' name: 'Flux import/Export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/FLUX-IMPORT-23-02-14/electricity-tariffs/E-1R-FLUX-IMPORT-23-02-14-{dno_region}/standard-unit-rates' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/FLUX-EXPORT-23-02-14/electricity-tariffs/E-1R-FLUX-EXPORT-23-02-14-{dno_region}/standard-unit-rates' - id: 'cosy_fixed' name: 'Cosy import/Fixed export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/COSY-22-12-08/electricity-tariffs/E-1R-COSY-22-12-08-{dno_region}/standard-unit-rates' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/OUTGOING-VAR-24-10-26/electricity-tariffs/E-1R-OUTGOING-VAR-24-10-26-{dno_region}/standard-unit-rates/' - id: 'cosy_agile' name: 'Cosy import/Agile export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/COSY-22-12-08/electricity-tariffs/E-1R-COSY-22-12-08-{dno_region}/standard-unit-rates' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/AGILE-OUTGOING-19-05-13/electricity-tariffs/E-1R-AGILE-OUTGOING-19-05-13-{dno_region}/standard-unit-rates/' - id: 'snug_fixed' name: 'Snug import/Fixed export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/SNUG-24-11-07/electricity-tariffs/E-1R-SNUG-24-11-07-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/OUTGOING-VAR-24-10-26/electricity-tariffs/E-1R-OUTGOING-VAR-24-10-26-{dno_region}/standard-unit-rates/' - id: 'iflux' name: 'Intelligent Flux import/export' rates_import_octopus_url: 'https://api.octopus.energy/v1/products/INTELLI-FLUX-IMPORT-23-07-14/electricity-tariffs/E-1R-INTELLI-FLUX-IMPORT-23-07-14-{dno_region}/standard-unit-rates/' rates_export_octopus_url: 'https://api.octopus.energy/v1/products/INTELLI-FLUX-EXPORT-23-07-14/electricity-tariffs/E-1R-INTELLI-FLUX-EXPORT-23-07-14-{dno_region}/standard-unit-rates/'","title":"Configuring the tariff's to compare"},{"location":"compare/#running-a-comparison","text":"By default, the comparison will be run at Midnight every night and saved for the entire day. You can view the comparison on the Predbat web interface under the 'Compare' view. You can manually trigger a new comparison by hitting the 'Compare now' button, or by turning on switch.predbat_compare_active . When a compare is running switch.predbat_compare_active will be turned on, otherwise it will be off. Predbat will highlight which tariff may be the best cost-wise for the next 24-hour period based on the plan optimisation metrics you have defined. The metric includes the value of the contents of your battery and iBoost that has been diverted during this period. The predicted cost is also shown, but keep in mind ending the day with an empty battery may be cheaper today but cost more tomorrow.","title":"Running a comparison"},{"location":"compare/#comparison-sensors","text":"For each tariff a new sensor is created in Home Assistant called predbat.compare_tariff_id where id is the ID name you entered above in apps.yaml. This sensor will track the cost as its main value and many details about the prediction in its attributes. You can create charts from these sensors to show how the different tariffs compare on a daily basis.","title":"Comparison sensors"},{"location":"components/","text":"Predbat Components This document provides a comprehensive overview of all Predbat components, their purposes, and configuration options. Table of Contents Overview Component List Database Manager (db) Home Assistant Interface (ha) Home Assistant History (ha_history) Web Interface (web) MCP Server (mcp) GivEnergy Cloud Direct (gecloud) GivEnergy Cloud Data (gecloud_data) Octopus Energy Direct (octopus) Axle Energy VPP (axle) Ohme Charger (ohme) Fox ESS API (fox) Solax Cloud API (Solax) Solis Cloud API (Solis) Alert Feed (alert_feed) Carbon Intensity API (carbon) Temperature API (temperature) ML Load Prediction (load_ml) Managing Components Checking Component Status Restarting Components Editing Component Configuration Component Health Overview Predbat uses a modular component architecture where each component provides specific functionality such as database management, cloud API integration, web interfaces, and energy provider integrations. Each component can be enabled or disabled independently through your apps.yaml configuration file. Component List Database Manager (db) Can be restarted: No What it does (db) Stores and manages all historical data for Predbat, including energy usage, sensor values, and system states. This allows Predbat to keep its own database of historical information independent of Home Assistant. When to enable (db) You want to retain data longer than Home Assistant keeps or you want to run Predbat without Home Assistant. Under normal use you should not need to configure DB manager and the component will be disabled. Configuration Options (db) Option Type Required Default Config Key Description db_enable Boolean Yes - db_enable Set to true to enable the database, false to disable db_days Integer No 30 db_days Number of days of historical data to keep in the database Home Assistant Interface (ha) Can be restarted: No What it does (ha) Provides the connection between Predbat and Home Assistant. This is the core communication channel that allows Predbat to read sensor data, control devices, and update its status in Home Assistant. If you are using Predbat without Home Assistant then this interface layer just talks directly to the Database Manager. When to enable (ha) This component is always enabled and required for Predbat to function. Configuration Options (ha) Option Type Required Default Config Key Description ha_url String No http://supervisor/core ha_url Home Assistant API URL (the default is for when using an HA app) ha_key String No Auto-detected ha_key Home Assistant access token (auto-detected when running as app) db_enable Boolean No False db_enable Enable database integration db_mirror_ha Boolean No False db_mirror_ha Copy Home Assistant data into Predbat's database db_primary Boolean No False db_primary Use Predbat's database instead of Home Assistant for the primary data source Home Assistant History (ha_history) Can be restarted: No What it does (ha_history) Retrieves and processes historical sensor data from Home Assistant's database (or from the Predbat database). This component handles all lookups of past energy usage, battery levels, and other historical information. When to enable (ha_history) This component is always enabled. Configuration Options (ha_history) No configuration required. This component automatically uses your Home Assistant connection. Web Interface (web) Can be restarted: Yes What it does (web) Provides a built-in web server that lets you view and manage Predbat through your web browser. Access dashboards, view battery plans, check logs, and edit configuration all from an easy-to-use web interface. Configuration Options (web) Option Type Required Default Config Key Description port Integer No 5052 web_port Port number for the web server How to access (web) If you use Predbat as a Home Assistant app then click 'Open Web UI' from the app or add Predbat Web UI to your side bar. If you run Predbat outside then you can access it from the port as configured: http://homename:5052 MCP Server (mcp) Can be restarted: Yes What it does (mcp) Provides a programmatic API that allows AI assistants (like ChatGPT, Claude, or other MCP-compatible tools) to read and control Predbat. This enables you to use natural language commands to check status, adjust settings, or override plans. When to enable (mcp) You want to control Predbat through AI assistants You're building custom integrations or tools You want programmatic access to Predbat data Security note (mcp) The MCP server requires a secret key for authentication. Keep this secret secure and don't share it publicly. CAUTION Predbat WebUI does not support https currently, so exposing this MCP port externally to your home network would be unwise. Configuration Options (mcp) Option Type Required Default Config Key Description mcp_enable Boolean Yes False mcp_enable Set to true to enable the MCP server mcp_secret String No predbat_mcp_secret mcp_secret Secret key for authentication - change this! mcp_port Integer No 8199 mcp_port Port number for the MCP server How to configure your MCP client (mcp) Below is an example MCP configuration inside VSCode, but it will be similar in Cline/Claude/Cursor etc. Example usage in VSCode { \"servers\": { \"predbat-mcp\": { \"url\": \"http://homeassistant.local:8199/mcp\", \"type\": \"http\", \"description\": \"Predbat Model Context Protocol Server\", \"headers\": { \"Authorization\" : \"Bearer predbat_mcp_secret\", }, } }, \"inputs\": [] } Available commands (mcp) Get current system status View and update configuration settings Browse all entities Retrieve battery plan data Override plan for specific time periods Access apps.yaml configuration GivEnergy Cloud Direct (gecloud) Can be restarted: Yes What it does (gecloud) Connects directly to the GivEnergy Cloud to control your GivEnergy inverter and battery. This allows Predbat to automatically set charge/discharge times, power limits, and read real-time data from your inverter without relying on Home Assistant integrations. When to enable (gecloud) You have a GivEnergy inverter You want direct cloud-based control (more reliable than local control) You have your GivEnergy Cloud API key You want automatic control of your battery Important notes (gecloud) Requires a GivEnergy Cloud account and API key Can also control GivEnergy EV chargers and smart devices Configuration Options (gecloud) Option Type Required Default Config Key Description ge_cloud_direct Boolean Yes - ge_cloud_direct Set to true to enable GivEnergy Cloud control api_key String Yes - ge_cloud_key Your GivEnergy Cloud API key automatic Boolean No False ge_cloud_automatic Set to true to automatically configured Predbat to use GivEnergy Cloud direct (no additional apps.yaml changes required) How to get your API key (gecloud) Log in to your GivEnergy account at https://www.givenergy.cloud Go to Settings \u2192 API Keys Generate a new API key Copy the key into your apps.yaml configuration GivEnergy Cloud Data (gecloud_data) Can be restarted: Yes What it does (gecloud_data) Downloads historical energy data from GivEnergy Cloud including consumption, generation, battery usage, and grid import/export. This provides accurate historical data for Predbat's calculations and predictions. When to enable (gecloud_data) You have a GivEnergy system You want Predbat to use historical data from GivEnergy Cloud instead of from Home Assistant. Configuration Options (gecloud_data) Option Type Required Default Config Key Description ge_cloud_data Boolean Yes - ge_cloud_data Set to true to enable historical data download ge_cloud_key String Yes - ge_cloud_key Your GivEnergy Cloud API key (same as Cloud Direct) ge_cloud_serial String No Auto-detected ge_cloud_serial Your inverter serial number (usually auto-detected) days_previous List No [7] days_previous List of days to download data for, e.g., [7] for last week Octopus Energy Direct (octopus) Can be restarted: Yes What it does (octopus) Connects to your Octopus Energy account to automatically download your tariff rates, including support for dynamic tariffs like Agile and Intelligent Octopus. This ensures Predbat always has the most accurate and up-to-date energy pricing. When to enable (octopus) You're an Octopus Energy customer You want automatic tariff updates You're on a variable tariff (Agile, Intelligent Octopus, etc.) You want to see your actual consumption data Important notes (octopus) Works with all Octopus tariffs including Agile and Intelligent Octopus Automatically manages Intelligent Octopus smart charging slots Updates rates automatically, no manual intervention needed Configuration Options (octopus) Option Type Required Default Config Key Description key String Yes - octopus_api_key Your Octopus Energy API key account_id String Yes - octopus_api_account Your Octopus Energy account number (starts with A-) automatic Boolean No True octopus_automatic Set to true to automatically configure Predbat to use this Component (no need to update apps.yaml) How to get your API credentials (octopus) Log in to your Octopus Energy account at https://octopus.energy Go to your account dashboard Find your API key (usually in Developer settings) Your account number is shown on your dashboard (format: A-XXXXXXXX) Axle Energy VPP (axle) Can be restarted: Yes What it does (axle) Connects to Axle Energy's Virtual Power Plant (VPP) [UK] service to receive and track demand response events. When Axle schedules export events, this component will track them and store the history for up to 7 days. The component publishes a binary sensor that turns on when an event is currently active. If configured in Predbat's apps.yaml Predbat will control your inverter to export in response to the Axle event and adjusts the export energy rate to account for the extra payment from Axle. Sign up with my referral code here: https://vpp.axle.energy/landing/grid?ref=R-VWIICRSA Please note you are not allowed to be on Octoplus at the same time, so contact Octopus if you need to be removed from this scheme. Select control my battery for 'Events Only'. When to enable (axle) You're enrolled in Axle Energy's VPP program and want Predbat to be aware of the scheduled events and plan for them. Important notes (axle) Polls the Axle API every 10 minutes for updates Stores event history for up to 7 days Events are added to history as soon as they start (become active) Binary sensor (default name binary_sensor.predbat_axle_event ) is on when an event is currently active, off otherwise Current event details and event history are available as sensor attributes ('event_current' and 'event_history') Alert notification sent when Predbat adds a new Axle VPP event to the Predbat plan When axle_control is enabled (set to True in apps.yaml ), Predbat will enter read-only mode during active VPP events (default is False) Read-only mode prevents Predbat from controlling the inverter while VPP events are running Status will show as \"Read-Only (Axle)\" when this feature is active Configuration Options (axle) Option Type Required Default Config Key Description api_key String Yes - axle_api_key Your Axle Energy API key from the VPP portal pence_per_kwh Integer No 100 axle_pence_per_kwh Payment rate in pence per kWh for VPP events automatic Bool No True axle_automatic When enabled use the default Axle event entity name ( binary_sensor.predbat_axle_event ) control Bool No False axle_control When enabled puts Predbat into Read-Only mode during Axle events How to get your API credentials (axle) Log in to your Axle Energy VPP portal at https://vpp.axle.energy Navigate to the Home Assistant integration section Copy your API key Paste it into axle_api_key in apps.yaml Sensor Attributes (axle) The binary sensor binary_sensor.predbat_axle_event provides the following attributes: event_current : List containing the current event (if any), with fields: start_time : Event start time (timezone-aware datetime) end_time : Event end time (timezone-aware datetime) import_export : Event type (\"import\" or \"export\") updated_at : Last update timestamp pence_per_kwh : Payment rate for this event event_history : List of past events (up to 7 days) with the same fields as above SolaX Cloud API (solax) Can be restarted: Yes What it does (solax) Connects directly to the SolaX Cloud API to control SolaX inverters and batteries. This allows Predbat to automatically set charge/discharge schedules, power limits, target SOC, and read real-time data from your inverter without requiring local Home Assistant integrations. The component polls your SolaX Cloud account every minute for real-time data and every 30 minutes for device and plant information. It publishes comprehensive sensors for battery status, energy totals, and provides full control over charging and discharging schedules. When to enable (solax) You have a SolaX inverter (X1, X3, X3-Hybrid, or other cloud-connected models) You want cloud-based control without local integrations You have SolaX Cloud API credentials (client ID and secret) You want automatic battery charge/discharge optimization You want Predbat to read historical energy data directly from SolaX Cloud Important notes (solax) Requires valid SolaX Cloud API credentials (client ID and client secret) Supports multiple plants/inverters with automatic discovery when solax_automatic: true Region-specific API endpoints: EU, US, or CN Authentication tokens are automatically managed (30-day expiry with auto-refresh) Supports both residential and commercial installations Control commands use time-window based scheduling (similar to GivEnergy) Read-only mode available with solax_enable_controls: false Compatible with Predbat's standard optimization algorithms Configuration Options (solax) Option Type Required Default Config Key Description client_id String Yes - solax_client_id Your SolaX Cloud API client ID client_secret String Yes - solax_client_secret Your SolaX Cloud API client secret region String No 'eu' solax_region API region: 'eu', 'us', or 'cn' plant_id String No None solax_plant_id Optional: Filter to specific plant ID automatic Boolean No False solax_automatic Auto-configure all entities and inverters enable_controls Boolean No True solax_enable_controls Enable inverter control (false for read-only) Security Note: Store solax_client_id and especially solax_client_secret in secrets.yaml : solax_client_id: !secret solax_client_id solax_client_secret: !secret solax_client_secret How to get your API credentials (solax) Log in to your SolaX Cloud account: - EU: https://www.solaxcloud.com - US: https://www.solaxcloud.us - CN: https://www.solaxcloud.com.cn Navigate to Settings \u2192 API Management (or Developer Settings) Create a new API application or view existing credentials Copy your Client ID and Client Secret Add to your secrets.yaml file Reference in apps.yaml using !secret notation Published Entities (solax) For each plant (replace {plant_id} with your actual plant ID), the component creates: Battery Sensors: Battery SOC (kWh) Battery capacity (kWh) Battery temperature (\u00b0C) Battery max power (W) System Sensors: Inverter max power (W) PV capacity (kWp) Total PV yield (kWh) Total battery charged (kWh) Total battery discharged (kWh) Total grid imported (kWh) Total grid exported (kWh) Total load (kWh, calculated) Total earnings (currency) Power Sensors (per inverter): Charge/discharge power (W) Grid power (W) PV power (W) AC load power (W) Control Entities: Battery reserve SOC (number, %) Charge start/end times (select, HH:MM:SS format) Charge target SOC (number, %) Charge rate (number, W) Charge enable (switch) Export start/end times (select, HH:MM:SS format) Export target SOC (number, %) Export rate (number, W) Export enable (switch) Testing your configuration (solax) You can test your SolaX Cloud API connection independently: cd /config/appdaemon/apps/predbat python3 solax.py --client-id YOUR_CLIENT_ID --client-secret YOUR_CLIENT_SECRET --region eu This will authenticate, fetch all plants, devices, and real-time data, helping diagnose any connection or configuration issues. Ohme Charger (ohme) Can be restarted: Yes What it does (ohme) Integrates with Ohme EV chargers to monitor charging sessions and coordinate charging with your energy tariff. Works particularly well with Intelligent Octopus to optimize charging times and costs. When to enable (ohme) You have an Ohme EV charger You want Predbat to factor in the charging plan within Ohme, this is mostly used with Octopus Intelligent GO. Important notes (ohme) Requires your Ohme account credentials Can automatically manage Intelligent Octopus charging slots Monitors real-time charging status and energy consumption Configuration Options (ohme) Option Type Required Default Config Key Description email String Yes - ohme_login Your Ohme account email address password String Yes - ohme_password Your Ohme account password ohme_automatic_octopus_intelligent Boolean No - ohme_automatic_octopus_intelligent Set to true to automatically sync with Intelligent Octopus Fox ESS API (fox) Can be restarted: Yes What it does (fox) Integrates with Fox ESS inverters for monitoring and controlling Fox ESS battery systems. Similar to GivEnergy Cloud Direct, but for Fox ESS equipment. When to enable (fox) You have a Fox ESS inverter You want direct API control of your Fox system You have your Fox ESS API key Important notes (fox) Requires Fox ESS Cloud account and API key Configuration Options (fox) Option Type Required Default Config Key Description key String Yes - fox_key Your Fox ESS API key automatic Boolean No False fox_automatic Set to true to automatically configured Predbat to use the Fox inverter (no manual apps.yaml updates required) Solis Cloud API (solis) Can be restarted: Yes What it does (solis) Integrates with Solis inverters for monitoring and controlling Solis battery systems via the Solis Cloud API. Provides direct control of charge/discharge schedules, storage modes, and battery parameters. When to enable (solis) You have a Solis hybrid inverter with battery storage You want direct API control of your Solis system You have your Solis Cloud API credentials Important notes (solis) EXPERIMENTAL : This is a new integration and may have issues Requires Solis Cloud account with API access Battery size configuration : The Solis Cloud integration cannot automatically determine your battery size from the inverter. You can either: Manually set soc_max in apps.yaml with your battery capacity in kWh (recommended), or Leave soc_max unset and allow Predbat to automatically detect battery size from historical charging data (requires several days of data) Supports both V1 (older firmware) and V2 (newer firmware) time window formats Automatic configuration available - sets up all required Predbat sensors automatically Configuration Options (solis) Option Type Required Default Config Key Description api_key String Yes - solis_api_key Your Solis Cloud API Key (KeyId) api_secret String Yes - solis_api_secret Your Solis Cloud API Secret (KeySecret) inverter_sn String/List No - solis_inverter_sn Inverter serial number(s) - Leave unset to see all. Single string or list of strings for multiple inverters automatic Boolean No False solis_automatic Set to true to automatically configure Predbat to use the Solis inverter (no manual apps.yaml sensor updates required) base_url String No Auto-detected solis_base_url Solis Cloud API base URL (automatically selects correct region) control_enable Boolean No True solis_control_enable Enable/disable control commands (set to false for monitoring only) Alert Feed (alert_feed) Can be restarted: Yes What it does (alert_feed) Monitors weather alert feeds (MeteoAlarm) for severe weather warnings that might impact your energy usage or solar generation. Predbat can use this information to adjust its planning accordingly. When to enable (alert_feed) You want Predbat to be aware of weather alerts You want to adjust battery strategy based on weather warnings You're in an area with frequent severe weather How it works (alert_feed) Checks for alerts every 30 minutes Processes weather warnings for your area Can be configured with custom alert URLs and filters in apps.yaml Configuration Options (alert_feed) Option Type Required Default Config Key Description alert_config Dictionary Yes {} alerts Alert configuration including URL and filters Configuration example See the Weather Alert for more details Carbon Intensity API (carbon) Can be restarted: Yes What it does (carbon) Retrieves current and forecast carbon intensity data for the UK electricity grid. This allows Predbat to make environmentally-conscious decisions, charging your battery when grid electricity is greener and discharging when it's more carbon-intensive. When to enable (carbon) You want to minimize your carbon footprint You're interested in carbon-aware energy management You're in the UK (uses UK National Grid data) You want to see carbon intensity alongside cost optimization How it works (carbon) Uses your postcode to get regional carbon intensity data Provides both current intensity and forecasts Updates automatically throughout the day Note: To use the carbon data in Predbat you also have to turn on switch.predbat_carbon_enable . If you want to optimise your plan for carbon then you also need to adjust the carbon weighting. Configuration Options (carbon) Option Type Required Default Config Key Description postcode String Yes - carbon_postcode Your UK postcode for regional carbon intensity data automatic Boolean No False carbon_automatic Set to true to automatically point Predbat to the carbon data Temperature API (temperature) Can be restarted: Yes What it does (temperature) Fetches temperature forecasts from the Open-Meteo API to provide accurate temperature predictions for the next 48+ hours. This temperature data is used by the ML Load Prediction component to improve load forecasting accuracy, especially for homes with electric heating or air conditioning systems. When to enable (temperature) You are using ML Load Prediction and want improved accuracy Your energy consumption is significantly affected by temperature (heating/cooling) You want temperature forecasts available for other automations How it works (temperature) Fetches temperature data from Open-Meteo API every hour Uses your location coordinates (from temperature_latitude / temperature_longitude or defaults to zone.home ) Provides current temperature and hourly forecasts Publishes data to sensor.predbat_temperature with forecasts in the results attribute Automatically retries on API failures with exponential backoff Important : This component is recommended when using ML Load Prediction, as temperature data cam improve prediction accuracy for households with electric/heat-pump heating. Configuration Options (temperature) Option Type Required Default Config Key Description temperature_enable Boolean Yes False temperature_enable Set to true to enable temperature forecasts temperature_url String No Open-Meteo API URL temperature_url API URL with LATITUDE/LONGITUDE placeholders temperature_latitude Float No Uses zone.home temperature_latitude Latitude for temperature forecast location temperature_longitude Float No Uses zone.home temperature_longitude Longitude for temperature forecast location Configuration example (temperature) predbat: # Enable temperature forecasts (recommended for ML load prediction) temperature_enable: true # Optional: specify location (defaults to zone.home) # temperature_latitude: 51.5074 # temperature_longitude: -0.1278 Accessing temperature data (temperature) Temperature data is published to: sensor.predbat_temperature - Current temperature with forecast in results attribute The results attribute contains a dictionary of timestamp strings (ISO format with timezone) to temperature values in \u00b0C. ML Load Prediction (load_ml) Can be restarted: Yes What it does (load_ml) Uses a neural network to predict your household energy consumption for the next 48 hours based on historical patterns, time-of-day, day-of-week, and optionally temperature and PV generation data. This provides more accurate load predictions than simple averaging, especially for households with variable usage patterns. When to enable (load_ml) You want more accurate load predictions than historical averages Your energy consumption has regular daily/weekly patterns You have at least 1 day of historical load data (7+ days recommended) You want Predbat to automatically adapt to changing consumption patterns How it works (load_ml) Fetches historical load data from your configured load_today sensor Optionally incorporates PV generation and temperature forecast data Trains a multi-layer neural network on your historical patterns Makes autoregressive predictions for 48 hours ahead in 5-minute intervals Fine-tunes periodically (every 2 hours) to adapt to changing patterns Validates predictions and falls back gracefully if accuracy is poor Publishes predictions to sensor.predbat_load_ml_forecast Important : For best results, enable the Temperature component ( temperature_enable: true ) as temperature data significantly improves prediction accuracy. For a detailed explanation of how the neural network works and comprehensive configuration guidance, see the ML Load Prediction documentation . Configuration Options (load_ml) Option Type Required Default Config Key Description load_ml_enable Boolean Yes False load_ml_enable Set to True to enable ML load prediction load_ml_source Boolean Yes False load_ml_source Set to True to use the ML load prediction in Predbat Note: load_today, pv_today and car_charging_energy apps.yaml configuration items are also used, but these should already be set in Predbat. Configuration example (load_ml) predbat: # Enable ML load prediction load_ml_enable: True # Use the data in Predbat, can be false while exploring the predictions but not using them load_ml_source: True # Optional but recommended: enable temperature forecasts temperature_enable: true Understanding model status (load_ml) The ML component tracks several status indicators: not_initialized : Model has not been created yet training : Model is currently training on historical data active : Model is trained and making predictions validation_failed : Predictions are disabled due to high validation error stale : Model hasn't been trained in 48+ hours and needs retraining Check Predbat logs for training progress and validation metrics: ML Component: Starting initial training ML Predictor: Training complete, final val_mae=0.3245 kWh ML Component: Model status: active Accessing predictions (load_ml) ML load predictions are published to: sensor.predbat_load_ml_forecast - Contains 48-hour prediction in results attribute Predbat automatically uses these predictions when making battery charge/discharge decisions. For more information (load_ml) See the comprehensive ML Load Prediction documentation for: Detailed explanation of neural network architecture Training process and parameters Expected accuracy metrics Troubleshooting guide Advanced configuration options Managing Components Checking Component Status You can check the status of all components through the web interface: Open the web interface (default: http://your-ha-ip:5052 ) Navigate to the Components page ( /components ) View the status of each component: - Enabled/Disabled - Whether the component is configured - Running/Stopped - Current operational status - Healthy/Unhealthy - Whether the component is working correctly - Last Updated - When the component last successfully updated Restarting Components Most components can be restarted if they encounter problems: Use the 'Restart' button on the Components page in the web interface Or restart Predbat entirely to restart all components Note: Core components (Database Manager, Home Assistant Interface, and Home Assistant History) cannot be restarted individually and require a full Predbat restart. Editing Component Configuration Click the Pencil icon next to a component to change the component configuration, e.g.: Once you save the component configuration the changes will be written to apps.yaml and Predbat and all components will be restarted. Component Health A component is considered healthy when: Its task is running It has updated within the last 60 minutes It reports no errors If a component becomes unhealthy: Check your configuration in apps.yaml Verify API keys and credentials are correct Check network connectivity Review Predbat logs for error messages Try restarting the component","title":"Predbat Components"},{"location":"components/#predbat-components","text":"This document provides a comprehensive overview of all Predbat components, their purposes, and configuration options.","title":"Predbat Components"},{"location":"components/#table-of-contents","text":"Overview Component List Database Manager (db) Home Assistant Interface (ha) Home Assistant History (ha_history) Web Interface (web) MCP Server (mcp) GivEnergy Cloud Direct (gecloud) GivEnergy Cloud Data (gecloud_data) Octopus Energy Direct (octopus) Axle Energy VPP (axle) Ohme Charger (ohme) Fox ESS API (fox) Solax Cloud API (Solax) Solis Cloud API (Solis) Alert Feed (alert_feed) Carbon Intensity API (carbon) Temperature API (temperature) ML Load Prediction (load_ml) Managing Components Checking Component Status Restarting Components Editing Component Configuration Component Health","title":"Table of Contents"},{"location":"components/#overview","text":"Predbat uses a modular component architecture where each component provides specific functionality such as database management, cloud API integration, web interfaces, and energy provider integrations. Each component can be enabled or disabled independently through your apps.yaml configuration file.","title":"Overview"},{"location":"components/#component-list","text":"","title":"Component List"},{"location":"components/#database-manager-db","text":"Can be restarted: No","title":"Database Manager (db)"},{"location":"components/#what-it-does-db","text":"Stores and manages all historical data for Predbat, including energy usage, sensor values, and system states. This allows Predbat to keep its own database of historical information independent of Home Assistant.","title":"What it does (db)"},{"location":"components/#when-to-enable-db","text":"You want to retain data longer than Home Assistant keeps or you want to run Predbat without Home Assistant. Under normal use you should not need to configure DB manager and the component will be disabled.","title":"When to enable (db)"},{"location":"components/#configuration-options-db","text":"Option Type Required Default Config Key Description db_enable Boolean Yes - db_enable Set to true to enable the database, false to disable db_days Integer No 30 db_days Number of days of historical data to keep in the database","title":"Configuration Options (db)"},{"location":"components/#home-assistant-interface-ha","text":"Can be restarted: No","title":"Home Assistant Interface (ha)"},{"location":"components/#what-it-does-ha","text":"Provides the connection between Predbat and Home Assistant. This is the core communication channel that allows Predbat to read sensor data, control devices, and update its status in Home Assistant. If you are using Predbat without Home Assistant then this interface layer just talks directly to the Database Manager.","title":"What it does (ha)"},{"location":"components/#when-to-enable-ha","text":"This component is always enabled and required for Predbat to function.","title":"When to enable (ha)"},{"location":"components/#configuration-options-ha","text":"Option Type Required Default Config Key Description ha_url String No http://supervisor/core ha_url Home Assistant API URL (the default is for when using an HA app) ha_key String No Auto-detected ha_key Home Assistant access token (auto-detected when running as app) db_enable Boolean No False db_enable Enable database integration db_mirror_ha Boolean No False db_mirror_ha Copy Home Assistant data into Predbat's database db_primary Boolean No False db_primary Use Predbat's database instead of Home Assistant for the primary data source","title":"Configuration Options (ha)"},{"location":"components/#home-assistant-history-ha_history","text":"Can be restarted: No","title":"Home Assistant History (ha_history)"},{"location":"components/#what-it-does-ha_history","text":"Retrieves and processes historical sensor data from Home Assistant's database (or from the Predbat database). This component handles all lookups of past energy usage, battery levels, and other historical information.","title":"What it does (ha_history)"},{"location":"components/#when-to-enable-ha_history","text":"This component is always enabled.","title":"When to enable (ha_history)"},{"location":"components/#configuration-options-ha_history","text":"No configuration required. This component automatically uses your Home Assistant connection.","title":"Configuration Options (ha_history)"},{"location":"components/#web-interface-web","text":"Can be restarted: Yes","title":"Web Interface (web)"},{"location":"components/#what-it-does-web","text":"Provides a built-in web server that lets you view and manage Predbat through your web browser. Access dashboards, view battery plans, check logs, and edit configuration all from an easy-to-use web interface.","title":"What it does (web)"},{"location":"components/#configuration-options-web","text":"Option Type Required Default Config Key Description port Integer No 5052 web_port Port number for the web server","title":"Configuration Options (web)"},{"location":"components/#how-to-access-web","text":"If you use Predbat as a Home Assistant app then click 'Open Web UI' from the app or add Predbat Web UI to your side bar. If you run Predbat outside then you can access it from the port as configured: http://homename:5052","title":"How to access (web)"},{"location":"components/#mcp-server-mcp","text":"Can be restarted: Yes","title":"MCP Server (mcp)"},{"location":"components/#what-it-does-mcp","text":"Provides a programmatic API that allows AI assistants (like ChatGPT, Claude, or other MCP-compatible tools) to read and control Predbat. This enables you to use natural language commands to check status, adjust settings, or override plans.","title":"What it does (mcp)"},{"location":"components/#when-to-enable-mcp","text":"You want to control Predbat through AI assistants You're building custom integrations or tools You want programmatic access to Predbat data","title":"When to enable (mcp)"},{"location":"components/#security-note-mcp","text":"The MCP server requires a secret key for authentication. Keep this secret secure and don't share it publicly. CAUTION Predbat WebUI does not support https currently, so exposing this MCP port externally to your home network would be unwise.","title":"Security note (mcp)"},{"location":"components/#configuration-options-mcp","text":"Option Type Required Default Config Key Description mcp_enable Boolean Yes False mcp_enable Set to true to enable the MCP server mcp_secret String No predbat_mcp_secret mcp_secret Secret key for authentication - change this! mcp_port Integer No 8199 mcp_port Port number for the MCP server","title":"Configuration Options (mcp)"},{"location":"components/#how-to-configure-your-mcp-client-mcp","text":"Below is an example MCP configuration inside VSCode, but it will be similar in Cline/Claude/Cursor etc. Example usage in VSCode { \"servers\": { \"predbat-mcp\": { \"url\": \"http://homeassistant.local:8199/mcp\", \"type\": \"http\", \"description\": \"Predbat Model Context Protocol Server\", \"headers\": { \"Authorization\" : \"Bearer predbat_mcp_secret\", }, } }, \"inputs\": [] }","title":"How to configure your MCP client (mcp)"},{"location":"components/#available-commands-mcp","text":"Get current system status View and update configuration settings Browse all entities Retrieve battery plan data Override plan for specific time periods Access apps.yaml configuration","title":"Available commands (mcp)"},{"location":"components/#givenergy-cloud-direct-gecloud","text":"Can be restarted: Yes","title":"GivEnergy Cloud Direct (gecloud)"},{"location":"components/#what-it-does-gecloud","text":"Connects directly to the GivEnergy Cloud to control your GivEnergy inverter and battery. This allows Predbat to automatically set charge/discharge times, power limits, and read real-time data from your inverter without relying on Home Assistant integrations.","title":"What it does (gecloud)"},{"location":"components/#when-to-enable-gecloud","text":"You have a GivEnergy inverter You want direct cloud-based control (more reliable than local control) You have your GivEnergy Cloud API key You want automatic control of your battery","title":"When to enable (gecloud)"},{"location":"components/#important-notes-gecloud","text":"Requires a GivEnergy Cloud account and API key Can also control GivEnergy EV chargers and smart devices","title":"Important notes (gecloud)"},{"location":"components/#configuration-options-gecloud","text":"Option Type Required Default Config Key Description ge_cloud_direct Boolean Yes - ge_cloud_direct Set to true to enable GivEnergy Cloud control api_key String Yes - ge_cloud_key Your GivEnergy Cloud API key automatic Boolean No False ge_cloud_automatic Set to true to automatically configured Predbat to use GivEnergy Cloud direct (no additional apps.yaml changes required)","title":"Configuration Options (gecloud)"},{"location":"components/#how-to-get-your-api-key-gecloud","text":"Log in to your GivEnergy account at https://www.givenergy.cloud Go to Settings \u2192 API Keys Generate a new API key Copy the key into your apps.yaml configuration","title":"How to get your API key (gecloud)"},{"location":"components/#givenergy-cloud-data-gecloud_data","text":"Can be restarted: Yes","title":"GivEnergy Cloud Data (gecloud_data)"},{"location":"components/#what-it-does-gecloud_data","text":"Downloads historical energy data from GivEnergy Cloud including consumption, generation, battery usage, and grid import/export. This provides accurate historical data for Predbat's calculations and predictions.","title":"What it does (gecloud_data)"},{"location":"components/#when-to-enable-gecloud_data","text":"You have a GivEnergy system You want Predbat to use historical data from GivEnergy Cloud instead of from Home Assistant.","title":"When to enable (gecloud_data)"},{"location":"components/#configuration-options-gecloud_data","text":"Option Type Required Default Config Key Description ge_cloud_data Boolean Yes - ge_cloud_data Set to true to enable historical data download ge_cloud_key String Yes - ge_cloud_key Your GivEnergy Cloud API key (same as Cloud Direct) ge_cloud_serial String No Auto-detected ge_cloud_serial Your inverter serial number (usually auto-detected) days_previous List No [7] days_previous List of days to download data for, e.g., [7] for last week","title":"Configuration Options (gecloud_data)"},{"location":"components/#octopus-energy-direct-octopus","text":"Can be restarted: Yes","title":"Octopus Energy Direct (octopus)"},{"location":"components/#what-it-does-octopus","text":"Connects to your Octopus Energy account to automatically download your tariff rates, including support for dynamic tariffs like Agile and Intelligent Octopus. This ensures Predbat always has the most accurate and up-to-date energy pricing.","title":"What it does (octopus)"},{"location":"components/#when-to-enable-octopus","text":"You're an Octopus Energy customer You want automatic tariff updates You're on a variable tariff (Agile, Intelligent Octopus, etc.) You want to see your actual consumption data","title":"When to enable (octopus)"},{"location":"components/#important-notes-octopus","text":"Works with all Octopus tariffs including Agile and Intelligent Octopus Automatically manages Intelligent Octopus smart charging slots Updates rates automatically, no manual intervention needed","title":"Important notes (octopus)"},{"location":"components/#configuration-options-octopus","text":"Option Type Required Default Config Key Description key String Yes - octopus_api_key Your Octopus Energy API key account_id String Yes - octopus_api_account Your Octopus Energy account number (starts with A-) automatic Boolean No True octopus_automatic Set to true to automatically configure Predbat to use this Component (no need to update apps.yaml)","title":"Configuration Options (octopus)"},{"location":"components/#how-to-get-your-api-credentials-octopus","text":"Log in to your Octopus Energy account at https://octopus.energy Go to your account dashboard Find your API key (usually in Developer settings) Your account number is shown on your dashboard (format: A-XXXXXXXX)","title":"How to get your API credentials (octopus)"},{"location":"components/#axle-energy-vpp-axle","text":"Can be restarted: Yes","title":"Axle Energy VPP (axle)"},{"location":"components/#what-it-does-axle","text":"Connects to Axle Energy's Virtual Power Plant (VPP) [UK] service to receive and track demand response events. When Axle schedules export events, this component will track them and store the history for up to 7 days. The component publishes a binary sensor that turns on when an event is currently active. If configured in Predbat's apps.yaml Predbat will control your inverter to export in response to the Axle event and adjusts the export energy rate to account for the extra payment from Axle. Sign up with my referral code here: https://vpp.axle.energy/landing/grid?ref=R-VWIICRSA Please note you are not allowed to be on Octoplus at the same time, so contact Octopus if you need to be removed from this scheme. Select control my battery for 'Events Only'.","title":"What it does (axle)"},{"location":"components/#when-to-enable-axle","text":"You're enrolled in Axle Energy's VPP program and want Predbat to be aware of the scheduled events and plan for them.","title":"When to enable (axle)"},{"location":"components/#important-notes-axle","text":"Polls the Axle API every 10 minutes for updates Stores event history for up to 7 days Events are added to history as soon as they start (become active) Binary sensor (default name binary_sensor.predbat_axle_event ) is on when an event is currently active, off otherwise Current event details and event history are available as sensor attributes ('event_current' and 'event_history') Alert notification sent when Predbat adds a new Axle VPP event to the Predbat plan When axle_control is enabled (set to True in apps.yaml ), Predbat will enter read-only mode during active VPP events (default is False) Read-only mode prevents Predbat from controlling the inverter while VPP events are running Status will show as \"Read-Only (Axle)\" when this feature is active","title":"Important notes (axle)"},{"location":"components/#configuration-options-axle","text":"Option Type Required Default Config Key Description api_key String Yes - axle_api_key Your Axle Energy API key from the VPP portal pence_per_kwh Integer No 100 axle_pence_per_kwh Payment rate in pence per kWh for VPP events automatic Bool No True axle_automatic When enabled use the default Axle event entity name ( binary_sensor.predbat_axle_event ) control Bool No False axle_control When enabled puts Predbat into Read-Only mode during Axle events","title":"Configuration Options (axle)"},{"location":"components/#how-to-get-your-api-credentials-axle","text":"Log in to your Axle Energy VPP portal at https://vpp.axle.energy Navigate to the Home Assistant integration section Copy your API key Paste it into axle_api_key in apps.yaml","title":"How to get your API credentials (axle)"},{"location":"components/#sensor-attributes-axle","text":"The binary sensor binary_sensor.predbat_axle_event provides the following attributes: event_current : List containing the current event (if any), with fields: start_time : Event start time (timezone-aware datetime) end_time : Event end time (timezone-aware datetime) import_export : Event type (\"import\" or \"export\") updated_at : Last update timestamp pence_per_kwh : Payment rate for this event event_history : List of past events (up to 7 days) with the same fields as above","title":"Sensor Attributes (axle)"},{"location":"components/#solax-cloud-api-solax","text":"Can be restarted: Yes","title":"SolaX Cloud API (solax)"},{"location":"components/#what-it-does-solax","text":"Connects directly to the SolaX Cloud API to control SolaX inverters and batteries. This allows Predbat to automatically set charge/discharge schedules, power limits, target SOC, and read real-time data from your inverter without requiring local Home Assistant integrations. The component polls your SolaX Cloud account every minute for real-time data and every 30 minutes for device and plant information. It publishes comprehensive sensors for battery status, energy totals, and provides full control over charging and discharging schedules.","title":"What it does (solax)"},{"location":"components/#when-to-enable-solax","text":"You have a SolaX inverter (X1, X3, X3-Hybrid, or other cloud-connected models) You want cloud-based control without local integrations You have SolaX Cloud API credentials (client ID and secret) You want automatic battery charge/discharge optimization You want Predbat to read historical energy data directly from SolaX Cloud","title":"When to enable (solax)"},{"location":"components/#important-notes-solax","text":"Requires valid SolaX Cloud API credentials (client ID and client secret) Supports multiple plants/inverters with automatic discovery when solax_automatic: true Region-specific API endpoints: EU, US, or CN Authentication tokens are automatically managed (30-day expiry with auto-refresh) Supports both residential and commercial installations Control commands use time-window based scheduling (similar to GivEnergy) Read-only mode available with solax_enable_controls: false Compatible with Predbat's standard optimization algorithms","title":"Important notes (solax)"},{"location":"components/#configuration-options-solax","text":"Option Type Required Default Config Key Description client_id String Yes - solax_client_id Your SolaX Cloud API client ID client_secret String Yes - solax_client_secret Your SolaX Cloud API client secret region String No 'eu' solax_region API region: 'eu', 'us', or 'cn' plant_id String No None solax_plant_id Optional: Filter to specific plant ID automatic Boolean No False solax_automatic Auto-configure all entities and inverters enable_controls Boolean No True solax_enable_controls Enable inverter control (false for read-only) Security Note: Store solax_client_id and especially solax_client_secret in secrets.yaml : solax_client_id: !secret solax_client_id solax_client_secret: !secret solax_client_secret","title":"Configuration Options (solax)"},{"location":"components/#how-to-get-your-api-credentials-solax","text":"Log in to your SolaX Cloud account: - EU: https://www.solaxcloud.com - US: https://www.solaxcloud.us - CN: https://www.solaxcloud.com.cn Navigate to Settings \u2192 API Management (or Developer Settings) Create a new API application or view existing credentials Copy your Client ID and Client Secret Add to your secrets.yaml file Reference in apps.yaml using !secret notation","title":"How to get your API credentials (solax)"},{"location":"components/#published-entities-solax","text":"For each plant (replace {plant_id} with your actual plant ID), the component creates: Battery Sensors: Battery SOC (kWh) Battery capacity (kWh) Battery temperature (\u00b0C) Battery max power (W) System Sensors: Inverter max power (W) PV capacity (kWp) Total PV yield (kWh) Total battery charged (kWh) Total battery discharged (kWh) Total grid imported (kWh) Total grid exported (kWh) Total load (kWh, calculated) Total earnings (currency) Power Sensors (per inverter): Charge/discharge power (W) Grid power (W) PV power (W) AC load power (W) Control Entities: Battery reserve SOC (number, %) Charge start/end times (select, HH:MM:SS format) Charge target SOC (number, %) Charge rate (number, W) Charge enable (switch) Export start/end times (select, HH:MM:SS format) Export target SOC (number, %) Export rate (number, W) Export enable (switch)","title":"Published Entities (solax)"},{"location":"components/#testing-your-configuration-solax","text":"You can test your SolaX Cloud API connection independently: cd /config/appdaemon/apps/predbat python3 solax.py --client-id YOUR_CLIENT_ID --client-secret YOUR_CLIENT_SECRET --region eu This will authenticate, fetch all plants, devices, and real-time data, helping diagnose any connection or configuration issues.","title":"Testing your configuration (solax)"},{"location":"components/#ohme-charger-ohme","text":"Can be restarted: Yes","title":"Ohme Charger (ohme)"},{"location":"components/#what-it-does-ohme","text":"Integrates with Ohme EV chargers to monitor charging sessions and coordinate charging with your energy tariff. Works particularly well with Intelligent Octopus to optimize charging times and costs.","title":"What it does (ohme)"},{"location":"components/#when-to-enable-ohme","text":"You have an Ohme EV charger You want Predbat to factor in the charging plan within Ohme, this is mostly used with Octopus Intelligent GO.","title":"When to enable (ohme)"},{"location":"components/#important-notes-ohme","text":"Requires your Ohme account credentials Can automatically manage Intelligent Octopus charging slots Monitors real-time charging status and energy consumption","title":"Important notes (ohme)"},{"location":"components/#configuration-options-ohme","text":"Option Type Required Default Config Key Description email String Yes - ohme_login Your Ohme account email address password String Yes - ohme_password Your Ohme account password ohme_automatic_octopus_intelligent Boolean No - ohme_automatic_octopus_intelligent Set to true to automatically sync with Intelligent Octopus","title":"Configuration Options (ohme)"},{"location":"components/#fox-ess-api-fox","text":"Can be restarted: Yes","title":"Fox ESS API (fox)"},{"location":"components/#what-it-does-fox","text":"Integrates with Fox ESS inverters for monitoring and controlling Fox ESS battery systems. Similar to GivEnergy Cloud Direct, but for Fox ESS equipment.","title":"What it does (fox)"},{"location":"components/#when-to-enable-fox","text":"You have a Fox ESS inverter You want direct API control of your Fox system You have your Fox ESS API key","title":"When to enable (fox)"},{"location":"components/#important-notes-fox","text":"Requires Fox ESS Cloud account and API key","title":"Important notes (fox)"},{"location":"components/#configuration-options-fox","text":"Option Type Required Default Config Key Description key String Yes - fox_key Your Fox ESS API key automatic Boolean No False fox_automatic Set to true to automatically configured Predbat to use the Fox inverter (no manual apps.yaml updates required)","title":"Configuration Options (fox)"},{"location":"components/#solis-cloud-api-solis","text":"Can be restarted: Yes","title":"Solis Cloud API (solis)"},{"location":"components/#what-it-does-solis","text":"Integrates with Solis inverters for monitoring and controlling Solis battery systems via the Solis Cloud API. Provides direct control of charge/discharge schedules, storage modes, and battery parameters.","title":"What it does (solis)"},{"location":"components/#when-to-enable-solis","text":"You have a Solis hybrid inverter with battery storage You want direct API control of your Solis system You have your Solis Cloud API credentials","title":"When to enable (solis)"},{"location":"components/#important-notes-solis","text":"EXPERIMENTAL : This is a new integration and may have issues Requires Solis Cloud account with API access Battery size configuration : The Solis Cloud integration cannot automatically determine your battery size from the inverter. You can either: Manually set soc_max in apps.yaml with your battery capacity in kWh (recommended), or Leave soc_max unset and allow Predbat to automatically detect battery size from historical charging data (requires several days of data) Supports both V1 (older firmware) and V2 (newer firmware) time window formats Automatic configuration available - sets up all required Predbat sensors automatically","title":"Important notes (solis)"},{"location":"components/#configuration-options-solis","text":"Option Type Required Default Config Key Description api_key String Yes - solis_api_key Your Solis Cloud API Key (KeyId) api_secret String Yes - solis_api_secret Your Solis Cloud API Secret (KeySecret) inverter_sn String/List No - solis_inverter_sn Inverter serial number(s) - Leave unset to see all. Single string or list of strings for multiple inverters automatic Boolean No False solis_automatic Set to true to automatically configure Predbat to use the Solis inverter (no manual apps.yaml sensor updates required) base_url String No Auto-detected solis_base_url Solis Cloud API base URL (automatically selects correct region) control_enable Boolean No True solis_control_enable Enable/disable control commands (set to false for monitoring only)","title":"Configuration Options (solis)"},{"location":"components/#alert-feed-alert_feed","text":"Can be restarted: Yes","title":"Alert Feed (alert_feed)"},{"location":"components/#what-it-does-alert_feed","text":"Monitors weather alert feeds (MeteoAlarm) for severe weather warnings that might impact your energy usage or solar generation. Predbat can use this information to adjust its planning accordingly.","title":"What it does (alert_feed)"},{"location":"components/#when-to-enable-alert_feed","text":"You want Predbat to be aware of weather alerts You want to adjust battery strategy based on weather warnings You're in an area with frequent severe weather","title":"When to enable (alert_feed)"},{"location":"components/#how-it-works-alert_feed","text":"Checks for alerts every 30 minutes Processes weather warnings for your area Can be configured with custom alert URLs and filters in apps.yaml","title":"How it works (alert_feed)"},{"location":"components/#configuration-options-alert_feed","text":"Option Type Required Default Config Key Description alert_config Dictionary Yes {} alerts Alert configuration including URL and filters","title":"Configuration Options (alert_feed)"},{"location":"components/#configuration-example","text":"See the Weather Alert for more details","title":"Configuration example"},{"location":"components/#carbon-intensity-api-carbon","text":"Can be restarted: Yes","title":"Carbon Intensity API (carbon)"},{"location":"components/#what-it-does-carbon","text":"Retrieves current and forecast carbon intensity data for the UK electricity grid. This allows Predbat to make environmentally-conscious decisions, charging your battery when grid electricity is greener and discharging when it's more carbon-intensive.","title":"What it does (carbon)"},{"location":"components/#when-to-enable-carbon","text":"You want to minimize your carbon footprint You're interested in carbon-aware energy management You're in the UK (uses UK National Grid data) You want to see carbon intensity alongside cost optimization","title":"When to enable (carbon)"},{"location":"components/#how-it-works-carbon","text":"Uses your postcode to get regional carbon intensity data Provides both current intensity and forecasts Updates automatically throughout the day Note: To use the carbon data in Predbat you also have to turn on switch.predbat_carbon_enable . If you want to optimise your plan for carbon then you also need to adjust the carbon weighting.","title":"How it works (carbon)"},{"location":"components/#configuration-options-carbon","text":"Option Type Required Default Config Key Description postcode String Yes - carbon_postcode Your UK postcode for regional carbon intensity data automatic Boolean No False carbon_automatic Set to true to automatically point Predbat to the carbon data","title":"Configuration Options (carbon)"},{"location":"components/#temperature-api-temperature","text":"Can be restarted: Yes","title":"Temperature API (temperature)"},{"location":"components/#what-it-does-temperature","text":"Fetches temperature forecasts from the Open-Meteo API to provide accurate temperature predictions for the next 48+ hours. This temperature data is used by the ML Load Prediction component to improve load forecasting accuracy, especially for homes with electric heating or air conditioning systems.","title":"What it does (temperature)"},{"location":"components/#when-to-enable-temperature","text":"You are using ML Load Prediction and want improved accuracy Your energy consumption is significantly affected by temperature (heating/cooling) You want temperature forecasts available for other automations","title":"When to enable (temperature)"},{"location":"components/#how-it-works-temperature","text":"Fetches temperature data from Open-Meteo API every hour Uses your location coordinates (from temperature_latitude / temperature_longitude or defaults to zone.home ) Provides current temperature and hourly forecasts Publishes data to sensor.predbat_temperature with forecasts in the results attribute Automatically retries on API failures with exponential backoff Important : This component is recommended when using ML Load Prediction, as temperature data cam improve prediction accuracy for households with electric/heat-pump heating.","title":"How it works (temperature)"},{"location":"components/#configuration-options-temperature","text":"Option Type Required Default Config Key Description temperature_enable Boolean Yes False temperature_enable Set to true to enable temperature forecasts temperature_url String No Open-Meteo API URL temperature_url API URL with LATITUDE/LONGITUDE placeholders temperature_latitude Float No Uses zone.home temperature_latitude Latitude for temperature forecast location temperature_longitude Float No Uses zone.home temperature_longitude Longitude for temperature forecast location","title":"Configuration Options (temperature)"},{"location":"components/#configuration-example-temperature","text":"predbat: # Enable temperature forecasts (recommended for ML load prediction) temperature_enable: true # Optional: specify location (defaults to zone.home) # temperature_latitude: 51.5074 # temperature_longitude: -0.1278","title":"Configuration example (temperature)"},{"location":"components/#accessing-temperature-data-temperature","text":"Temperature data is published to: sensor.predbat_temperature - Current temperature with forecast in results attribute The results attribute contains a dictionary of timestamp strings (ISO format with timezone) to temperature values in \u00b0C.","title":"Accessing temperature data (temperature)"},{"location":"components/#ml-load-prediction-load_ml","text":"Can be restarted: Yes","title":"ML Load Prediction (load_ml)"},{"location":"components/#what-it-does-load_ml","text":"Uses a neural network to predict your household energy consumption for the next 48 hours based on historical patterns, time-of-day, day-of-week, and optionally temperature and PV generation data. This provides more accurate load predictions than simple averaging, especially for households with variable usage patterns.","title":"What it does (load_ml)"},{"location":"components/#when-to-enable-load_ml","text":"You want more accurate load predictions than historical averages Your energy consumption has regular daily/weekly patterns You have at least 1 day of historical load data (7+ days recommended) You want Predbat to automatically adapt to changing consumption patterns","title":"When to enable (load_ml)"},{"location":"components/#how-it-works-load_ml","text":"Fetches historical load data from your configured load_today sensor Optionally incorporates PV generation and temperature forecast data Trains a multi-layer neural network on your historical patterns Makes autoregressive predictions for 48 hours ahead in 5-minute intervals Fine-tunes periodically (every 2 hours) to adapt to changing patterns Validates predictions and falls back gracefully if accuracy is poor Publishes predictions to sensor.predbat_load_ml_forecast Important : For best results, enable the Temperature component ( temperature_enable: true ) as temperature data significantly improves prediction accuracy. For a detailed explanation of how the neural network works and comprehensive configuration guidance, see the ML Load Prediction documentation .","title":"How it works (load_ml)"},{"location":"components/#configuration-options-load_ml","text":"Option Type Required Default Config Key Description load_ml_enable Boolean Yes False load_ml_enable Set to True to enable ML load prediction load_ml_source Boolean Yes False load_ml_source Set to True to use the ML load prediction in Predbat Note: load_today, pv_today and car_charging_energy apps.yaml configuration items are also used, but these should already be set in Predbat.","title":"Configuration Options (load_ml)"},{"location":"components/#configuration-example-load_ml","text":"predbat: # Enable ML load prediction load_ml_enable: True # Use the data in Predbat, can be false while exploring the predictions but not using them load_ml_source: True # Optional but recommended: enable temperature forecasts temperature_enable: true","title":"Configuration example (load_ml)"},{"location":"components/#understanding-model-status-load_ml","text":"The ML component tracks several status indicators: not_initialized : Model has not been created yet training : Model is currently training on historical data active : Model is trained and making predictions validation_failed : Predictions are disabled due to high validation error stale : Model hasn't been trained in 48+ hours and needs retraining Check Predbat logs for training progress and validation metrics: ML Component: Starting initial training ML Predictor: Training complete, final val_mae=0.3245 kWh ML Component: Model status: active","title":"Understanding model status (load_ml)"},{"location":"components/#accessing-predictions-load_ml","text":"ML load predictions are published to: sensor.predbat_load_ml_forecast - Contains 48-hour prediction in results attribute Predbat automatically uses these predictions when making battery charge/discharge decisions.","title":"Accessing predictions (load_ml)"},{"location":"components/#for-more-information-load_ml","text":"See the comprehensive ML Load Prediction documentation for: Detailed explanation of neural network architecture Training process and parameters Expected accuracy metrics Troubleshooting guide Advanced configuration options","title":"For more information (load_ml)"},{"location":"components/#managing-components","text":"","title":"Managing Components"},{"location":"components/#checking-component-status","text":"You can check the status of all components through the web interface: Open the web interface (default: http://your-ha-ip:5052 ) Navigate to the Components page ( /components ) View the status of each component: - Enabled/Disabled - Whether the component is configured - Running/Stopped - Current operational status - Healthy/Unhealthy - Whether the component is working correctly - Last Updated - When the component last successfully updated","title":"Checking Component Status"},{"location":"components/#restarting-components","text":"Most components can be restarted if they encounter problems: Use the 'Restart' button on the Components page in the web interface Or restart Predbat entirely to restart all components Note: Core components (Database Manager, Home Assistant Interface, and Home Assistant History) cannot be restarted individually and require a full Predbat restart.","title":"Restarting Components"},{"location":"components/#editing-component-configuration","text":"Click the Pencil icon next to a component to change the component configuration, e.g.: Once you save the component configuration the changes will be written to apps.yaml and Predbat and all components will be restarted.","title":"Editing Component Configuration"},{"location":"components/#component-health","text":"A component is considered healthy when: Its task is running It has updated within the last 60 minutes It reports no errors If a component becomes unhealthy: Check your configuration in apps.yaml Verify API keys and credentials are correct Check network connectivity Review Predbat logs for error messages Try restarting the component","title":"Component Health"},{"location":"configuration-guide/","text":"Configuration guide First, get the basics set up, ensure you have the inverter controls configured , you have configured apps.yaml to your setup, and the solar forecast is in place. Make sure your energy rates are configured correctly for import and export. If you have an EV try to set up the car charging sensor correctly so Predbat can tell what part of your historical load is EV charging. You might want to also set the car charging plan so you can predict when your car is plugged in and how much it will charge. It is recommended that you create a dashboard page with all the required entities to control Predbat. This page gives a summary of some of the key configuration settings you should consider in Predbat for different energy tariffs; the Predbat customisation guide details all the Predbat customisation options. You should try to tune input_number.predbat_inverter_loss , input_number.predbat_battery_loss and input_number.predbat_battery_loss_discharge to the correct % loss for your system to get more accurate predictions. Around 4% for each is good for a hybrid inverter. For a Hybrid inverter, the inverter loss includes the loss on inverting PV as well as going from AC to DC when importing. Battery loss charge and discharge are factors to account for the loss in charging and discharging the battery as DC. For an AC coupled inverter the inverter loss is just the loss of the battery inverter, if you need to model the loss of your PV inverter then use input_number.predbat_pv_scaling or adjust your Solar forecast output. Battery loss charge and discharge are factors to account for the loss in charging and discharging the battery as DC. Also, set switch.predbat_inverter_hybrid to True or False depending upon if you have a Hybrid or AC-Coupled battery. The setting input_number.predbat_metric_battery_cycle ( expert mode ) can be used to put a 'virtual cost' in pence per kWh on using your battery for charging and discharging. If you configure this number higher then more expensive plans will be selected which avoids charging and discharging your battery as much. The default is 0.5p (meaning charging and discharging the battery would effectively cost an extra 1p per kWh) but can be set to 0 if you want to turn this feature off. Below is a guide to some of the electricity tariff options and a set of recommended Predbat settings for each tariff type. In theory, most tariffs will work out of the box but still, it's worth reviewing your settings. Fixed daily rates With a fixed daily rate tariff you will just be predicting the battery levels, no charging or discharging is required although it won't hurt if you leave these options enabled. You should set select.predbat_mode to 'Monitor'. Cheap night rate with a bad export rate (e.g. Economy 7 with SEG) In this scenario, you will want to charge overnight based on the next day's solar forecast and don't want Predbat to force export (discharge) your battery. Recommended settings - these must be changed in Home Assistant once Predbat is running: Item Value Comment select.predbat_mode Control Charge You want Predbat to calculate and control charging input_number.predbat_best_soc_keep 2.0 Tweak this to control what battery level you want to keep as a backup in case you use more energy If you are using expert mode then these options may be worth reviewing: Item Value Comment input_number.predbat_forecast_plan_hours 24 If you set this to 24 then you will have quicker updates, the cycle repeats itself anyhow input_number.predbat_metric_min_improvement 0 Charge less if it's cost neutral input_number.predbat_metric_min_improvement_export 3 Export only if there is a profit You should set select.predbat_mode to 'Control charge' Cheap night rate, with a good export rate (e.g. Go or Intelligent Octopus Go with Octopus Outgoing) Follow the instructions from the Cheap Night rate above, but you will also want to have automatic export occurring when the export rates are profitable. Item Value Comment select.predbat_mode Control Charge & Discharge You want Predbat to calculate and control charging and discharging input_number.predbat_best_soc_keep 2.0 Tweak this to control what battery level you want to keep as a backup in case you use more energy If you are using expert mode then these options may be worth reviewing, otherwise, ignore this: Item Value Comment input_number.predbat_forecast_plan_hours 24 If you set this to 24 then you will have quicker updates, the cycle repeats itself anyhow input_number.predbat_metric_min_improvement 0 Charge less if it's cost neutral input_number.predbat_metric_min_improvement_export 3 Export only if there is a profit input_number.predbat_metric_battery_cycle 0-2 Higher numbers mean less charging and discharging but higher costs input_number.predbat_best_soc_min 0 Can be set to non-zero if you want to force a minimum charge level You should set select.predbat_mode to 'Control charge & discharge' You may wish to use rates_export_override to override the night export rate to zero or turn off calculate_export_during_charge and turn on combine_charge . Either of these options will prevent charge / discharge cycling within the cheap period, which Predbat would see as economically sensible but may not be within terms of use for some tariffs. With the overnight charging rate being cheaper than your export rate, you probably want to charge your EV overnight and export all your solar; and not charge the EV from Solar during the day. Settings for doing this vary by charger manufacturer, but for the Zappi charger, set export margin to a value higher than your inverter can output (e.g. 6000W) to ensure that all solar is exported and not used to charge the EV. Multiple rates for import and export (e.g. Octopus Flux & Cozy) Follow the instructions from the Cheap Night rate above, but also you will want to have automatic export when the export rates are profitable. Recommended settings - these must be changed in Home Assistant once Predbat is running: Item Value Comment select.predbat_mode Control Charge & Discharge You want Predbat to calculate and control charging and discharging input_number.predbat_best_soc_keep 0 Use the full battery If you are using expert mode then these options may be worth reviewing, otherwise, ignore this: Item Value Comment input_number.predbat_forecast_plan_hours 24 If you set this to 24 then you will have quicker updates, the cycle repeats itself anyhow input_number.predbat_metric_min_improvement 0 Charge less if it's cost neutral input_number.predbat_metric_min_improvement_export 3 Export only if there is a profit input_number.predbat_metric_battery_cycle 0-2 Higher numbers mean less charging and discharging but higher costs input_number.predbat_best_soc_min 0 Don't use non-zero otherwise all slots will be force charging You should set select.predbat_mode to 'Control charge & discharge' Half hourly variable rates (e.g. Octopus Agile) Recommended settings - these must be changed in Home Assistant once Predbat is running: Item Value Comment select.predbat_mode Control Charge & Discharge You want Predbat to calculate and control charging and discharging input_number.predbat_best_soc_keep 0 Use the full battery If you are using expert mode then these options may be worth reviewing, otherwise, ignore this: Item Value Comment input_number.predbat_forecast_plan_hours 24-48 If you set this to 24 then you will have quicker updates, going to 36/48 for a longer plan input_number.predbat_metric_min_improvement 0 Charge less if it's cost neutral input_number.predbat_metric_min_improvement_export 3 Export only if there is a profit input_number.predbat_metric_battery_cycle 0-2 Higher numbers mean less charging and discharging but higher costs input_number.predbat_best_soc_min 0 Don't use non-zero otherwise all slots will be force charging You should set select.predbat_mode to 'Control charge & discharge'","title":"Configuration guide"},{"location":"configuration-guide/#configuration-guide","text":"First, get the basics set up, ensure you have the inverter controls configured , you have configured apps.yaml to your setup, and the solar forecast is in place. Make sure your energy rates are configured correctly for import and export. If you have an EV try to set up the car charging sensor correctly so Predbat can tell what part of your historical load is EV charging. You might want to also set the car charging plan so you can predict when your car is plugged in and how much it will charge. It is recommended that you create a dashboard page with all the required entities to control Predbat. This page gives a summary of some of the key configuration settings you should consider in Predbat for different energy tariffs; the Predbat customisation guide details all the Predbat customisation options. You should try to tune input_number.predbat_inverter_loss , input_number.predbat_battery_loss and input_number.predbat_battery_loss_discharge to the correct % loss for your system to get more accurate predictions. Around 4% for each is good for a hybrid inverter. For a Hybrid inverter, the inverter loss includes the loss on inverting PV as well as going from AC to DC when importing. Battery loss charge and discharge are factors to account for the loss in charging and discharging the battery as DC. For an AC coupled inverter the inverter loss is just the loss of the battery inverter, if you need to model the loss of your PV inverter then use input_number.predbat_pv_scaling or adjust your Solar forecast output. Battery loss charge and discharge are factors to account for the loss in charging and discharging the battery as DC. Also, set switch.predbat_inverter_hybrid to True or False depending upon if you have a Hybrid or AC-Coupled battery. The setting input_number.predbat_metric_battery_cycle ( expert mode ) can be used to put a 'virtual cost' in pence per kWh on using your battery for charging and discharging. If you configure this number higher then more expensive plans will be selected which avoids charging and discharging your battery as much. The default is 0.5p (meaning charging and discharging the battery would effectively cost an extra 1p per kWh) but can be set to 0 if you want to turn this feature off. Below is a guide to some of the electricity tariff options and a set of recommended Predbat settings for each tariff type. In theory, most tariffs will work out of the box but still, it's worth reviewing your settings.","title":"Configuration guide"},{"location":"configuration-guide/#fixed-daily-rates","text":"With a fixed daily rate tariff you will just be predicting the battery levels, no charging or discharging is required although it won't hurt if you leave these options enabled. You should set select.predbat_mode to 'Monitor'.","title":"Fixed daily rates"},{"location":"configuration-guide/#cheap-night-rate-with-a-bad-export-rate-eg-economy-7-with-seg","text":"In this scenario, you will want to charge overnight based on the next day's solar forecast and don't want Predbat to force export (discharge) your battery. Recommended settings - these must be changed in Home Assistant once Predbat is running: Item Value Comment select.predbat_mode Control Charge You want Predbat to calculate and control charging input_number.predbat_best_soc_keep 2.0 Tweak this to control what battery level you want to keep as a backup in case you use more energy If you are using expert mode then these options may be worth reviewing: Item Value Comment input_number.predbat_forecast_plan_hours 24 If you set this to 24 then you will have quicker updates, the cycle repeats itself anyhow input_number.predbat_metric_min_improvement 0 Charge less if it's cost neutral input_number.predbat_metric_min_improvement_export 3 Export only if there is a profit You should set select.predbat_mode to 'Control charge'","title":"Cheap night rate with a bad export rate (e.g. Economy 7 with SEG)"},{"location":"configuration-guide/#cheap-night-rate-with-a-good-export-rate-eg-go-or-intelligent-octopus-go-with-octopus-outgoing","text":"Follow the instructions from the Cheap Night rate above, but you will also want to have automatic export occurring when the export rates are profitable. Item Value Comment select.predbat_mode Control Charge & Discharge You want Predbat to calculate and control charging and discharging input_number.predbat_best_soc_keep 2.0 Tweak this to control what battery level you want to keep as a backup in case you use more energy If you are using expert mode then these options may be worth reviewing, otherwise, ignore this: Item Value Comment input_number.predbat_forecast_plan_hours 24 If you set this to 24 then you will have quicker updates, the cycle repeats itself anyhow input_number.predbat_metric_min_improvement 0 Charge less if it's cost neutral input_number.predbat_metric_min_improvement_export 3 Export only if there is a profit input_number.predbat_metric_battery_cycle 0-2 Higher numbers mean less charging and discharging but higher costs input_number.predbat_best_soc_min 0 Can be set to non-zero if you want to force a minimum charge level You should set select.predbat_mode to 'Control charge & discharge' You may wish to use rates_export_override to override the night export rate to zero or turn off calculate_export_during_charge and turn on combine_charge . Either of these options will prevent charge / discharge cycling within the cheap period, which Predbat would see as economically sensible but may not be within terms of use for some tariffs. With the overnight charging rate being cheaper than your export rate, you probably want to charge your EV overnight and export all your solar; and not charge the EV from Solar during the day. Settings for doing this vary by charger manufacturer, but for the Zappi charger, set export margin to a value higher than your inverter can output (e.g. 6000W) to ensure that all solar is exported and not used to charge the EV.","title":"Cheap night rate, with a good export rate (e.g. Go or Intelligent Octopus Go with Octopus Outgoing)"},{"location":"configuration-guide/#multiple-rates-for-import-and-export-eg-octopus-flux-cozy","text":"Follow the instructions from the Cheap Night rate above, but also you will want to have automatic export when the export rates are profitable. Recommended settings - these must be changed in Home Assistant once Predbat is running: Item Value Comment select.predbat_mode Control Charge & Discharge You want Predbat to calculate and control charging and discharging input_number.predbat_best_soc_keep 0 Use the full battery If you are using expert mode then these options may be worth reviewing, otherwise, ignore this: Item Value Comment input_number.predbat_forecast_plan_hours 24 If you set this to 24 then you will have quicker updates, the cycle repeats itself anyhow input_number.predbat_metric_min_improvement 0 Charge less if it's cost neutral input_number.predbat_metric_min_improvement_export 3 Export only if there is a profit input_number.predbat_metric_battery_cycle 0-2 Higher numbers mean less charging and discharging but higher costs input_number.predbat_best_soc_min 0 Don't use non-zero otherwise all slots will be force charging You should set select.predbat_mode to 'Control charge & discharge'","title":"Multiple rates for import and export (e.g. Octopus Flux &amp; Cozy)"},{"location":"configuration-guide/#half-hourly-variable-rates-eg-octopus-agile","text":"Recommended settings - these must be changed in Home Assistant once Predbat is running: Item Value Comment select.predbat_mode Control Charge & Discharge You want Predbat to calculate and control charging and discharging input_number.predbat_best_soc_keep 0 Use the full battery If you are using expert mode then these options may be worth reviewing, otherwise, ignore this: Item Value Comment input_number.predbat_forecast_plan_hours 24-48 If you set this to 24 then you will have quicker updates, going to 36/48 for a longer plan input_number.predbat_metric_min_improvement 0 Charge less if it's cost neutral input_number.predbat_metric_min_improvement_export 3 Export only if there is a profit input_number.predbat_metric_battery_cycle 0-2 Higher numbers mean less charging and discharging but higher costs input_number.predbat_best_soc_min 0 Don't use non-zero otherwise all slots will be force charging You should set select.predbat_mode to 'Control charge & discharge'","title":"Half hourly variable rates (e.g. Octopus Agile)"},{"location":"creating-charts/","text":"Creating the charts There are a number of fancy Apex charts that can be produced from Predbat data - things like Home Battery SoC prediction, Cost prediction, Energy Rates, etc. There's a Video Guide to the different charts available on YouTube. To install the charts: Install Apex Charts https://github.com/RomRider/apexcharts-card : In HACS, click on Frontend Click the blue Explore and download repositories button and type 'apex' Click on 'apexcharts-card', then click the blue 'Download', then 'Download' again to install it When prompted to 'reload your browser', click 'Reload' Next, on a Home Assistant dashboard you create the charts you want. There are multiple charts, for each section of the example chart yaml file , create a new apexcharts card and copy the YAML into it: Click the blue 'Add card', scroll down the list of cards to the bottom and click 'Custom: ApexCharts card' Delete the template card configuration and copy/paste ONE Apex chart from the example file Click 'Save' Repeat (adding Apex chart card, copy paste card config) for all of the charts you want to see Customise as you like If you get an error 'Custom element doesn't exist: apexcharts-card' then you've not installed the Apex Charts card correctly from HACS. See the video guides for a walkthrough of what the different charts show. Example charts:","title":"Creating the charts"},{"location":"creating-charts/#creating-the-charts","text":"There are a number of fancy Apex charts that can be produced from Predbat data - things like Home Battery SoC prediction, Cost prediction, Energy Rates, etc. There's a Video Guide to the different charts available on YouTube. To install the charts: Install Apex Charts https://github.com/RomRider/apexcharts-card : In HACS, click on Frontend Click the blue Explore and download repositories button and type 'apex' Click on 'apexcharts-card', then click the blue 'Download', then 'Download' again to install it When prompted to 'reload your browser', click 'Reload' Next, on a Home Assistant dashboard you create the charts you want. There are multiple charts, for each section of the example chart yaml file , create a new apexcharts card and copy the YAML into it: Click the blue 'Add card', scroll down the list of cards to the bottom and click 'Custom: ApexCharts card' Delete the template card configuration and copy/paste ONE Apex chart from the example file Click 'Save' Repeat (adding Apex chart card, copy paste card config) for all of the charts you want to see Customise as you like If you get an error 'Custom element doesn't exist: apexcharts-card' then you've not installed the Apex Charts card correctly from HACS. See the video guides for a walkthrough of what the different charts show. Example charts:","title":"Creating the charts"},{"location":"customisation/","text":"Customisation This document describes the Predbat configuration items in Home Assistant that you can modify to customise Predbat to fit your needs. All of these settings are entities that can be configured directly in Home Assistant (unlike the ' apps.yaml ' configuration items that have to be edited with a file editor). Note the default values of the settings inside Home Assistant are set inside Predbat, but the default can be overridden by setting its value in apps.yaml prior to starting Predbat for the first time. See Displaying output data for information on how to view and edit these entities within Home Assistant. Saving and restoring Predbat settings The selector select.predbat_saverestore can be used to save your current Predbat settings to a YAML file (kept in the directory /config/predbat_save/ ) and to restore the settings from one of these files. Selecting the selector option save current will cause the settings to be saved to a date/time-stamped file. You can rename this file yourself in the Home Assistant filesystem to give it a more human-readable name or delete it if you no longer want to keep it. This is normally best done in an SSH window or via a Samba mount. Selecting the option restore default will put all your settings back to the Predbat defaults. Before the restore, the current Predbat settings will be saved to the file previous.yaml - should you have made a mistake you can restore them quickly again. Selecting any of the .yaml files you have created will restore your settings from this file. Predbat mode The mode that Predbat operates in will change the operation, this can be configured with select.predbat_mode drop-down menu as follows: Monitor Control SoC only Control charge Control charge & discharge If the switch.predbat_set_read_only is set to On then this prevents Predbat from making modifications to the inverter settings (regardless of the configuration). Predbat will continue making and updating its prediction plan every 10 minutes (by default), but no inverter changes will be made. This is useful if you want to override what Predbat is planning to do (e.g. your own automation), or whilst you are learning how Predbat works before turning it on 'in anger'. NOTE: Changing the Predbat mode or the read-only switch will cause Predbat to reset the inverter settings to default, this will disable both charge and discharge, reset charge and discharge rates to full power and reset the reserve to the default setting Predbat Monitor mode In Monitor mode Predbat will not control or Plan any charging or discharging, inverter balancing will take place if enabled, and the plan will show just what is expected based on the current inverter configuration alone. Predbat Control SoC only mode In Control SoC only mode Predbat will adjust the target charge percentage (SoC target) according to the Best plan, but the charge window will not be modified. This mode can be useful if you just have one fixed charge slot per day and you only want Predbat to control the percentage the battery is charged based on solar generation and predicted house load. CAUTION: You must manually set any charging required on the inverter and if the charge window is disabled then no charging will take place. Predbat Control charge mode In Control charge mode Predbat will set the charge times and charge percentages according to the Best plan, charging can be enabled and disabled by Predbat. Predbat will set the inverter into Eco mode when required to enable the battery to support house load, but it will not plan any forced discharging of the battery for export purposes. This mode can be useful if you don't have an export rate, you have a 'no export' limitation from your electricity supplier, or if you want to preserve the battery for home demand. Predbat Control charge & discharge mode In Control charge & discharge mode Predbat will set both charge and force export (discharge) times and control charge and force export percentages. If you have set the switch.predbat_set_export_freeze_only set to On then forced export won't occur but Predbat can force the export of solar power to the grid when desired. Expert mode Predbat has a toggle switch called switch.predbat_expert_mode which is set to Off by default for new installs (On by default for upgraded installs). A lot of Predbat's more advanced configuration options will not be available unless expert mode is turned On. It's recommended for new users to start without expert mode and then maybe turn it on later once you become more confident with the tool. Performance related Predbat controls the inverter every 5 minutes it runs, and by default, updates and recalculates the plan every 10 minutes. This can however use a lot of CPU power especially on more complex tariffs like Agile when run on lower power machines such as Raspberry PIs and some thin clients. You can tweak input_number.predbat_calculate_plan_every ( expert mode ) (default 10 minutes) to reduce the frequency of replanning while keeping the inverter control in the fixed 5-minute slots. E.g. a value of 10 or 15 minutes should also give good results. If you have performance problems leave switch.predbat_calculate_second_pass ( expert mode ) turned Off as it's quite CPU intensive and provides very little improvement for most systems. You can turn on switch.predbat_combine_charge_slots and switch.predbat_combine_export_slots ( expert mode ) to speed up planning. Note: Combining export slots may prevent optimal forced export. Combining charge slots is usually fine for tariffs with longer periods of fixed rates but can limit the planning ability in some cases. The number of CPU threads you use can change your performance, you can set threads in apps.yaml to 0 to disable threading if you don't have multiple CPUs available, or set it to 'auto' (the default) to use one thread per CPU. It is recommended you don't set this to an odd number of threads. Battery loss options input_number.predbat_battery_loss is an assumed percentage figure for energy lost when charging the battery, the default 0.03 is 3%. input_number.predbat_battery_loss_discharge is an assumed percentage figure for energy lost whilst discharging the battery, the default 0.03 is 3%. input_number.predbat_inverter_loss is an assumed percentage figure for energy lost during the conversion within the inverter from DC to AC or AC to DC, the default 0.04 is 4%. TIP: Make sure you set the losses correctly, they are decimal percentages, so don't set them to '4' thinking it'll be 4%, Predbat will take this as being 400% and your plan will be very strange! switch.predbat_inverter_hybrid Set to On (the default) if you have a hybrid inverter so no inverter losses will be applied for DC charging from Solar generation. You should set it to Off if you have an AC-coupled battery and inverter losses will be applied when the battery is charging from solar. NB: This switch only applies when Predbat is modelling solar charging. All grid charging (regardless of inverter type) has to undergo an AC to DC conversion so the inverter_loss % will be included in Predbat's model when charging from the grid. input_number.predbat_metric_battery_cycle ( expert mode ) This sets a 'virtual cost' in pence per kWh on using your battery for charging and discharging. Higher numbers will reduce battery cycles at the expense of using higher energy costs. In theory, if you have a 9.5kWh battery and think it will last say 6000 complete cycles and it cost you \u00a34000, then each full charge and discharge cycle is 19kWh and so the cost per complete cycle is \u00a34000 / 19 / 6000 = 3.5p. Taking the 3.5p per cycle example, if you set predbat_metric_battery_cycle to 1.75 (half of 3.5) then Predbat will apply the \"virtual cost\" of 1.75p to every kWh of charge and discharge of the battery. This cost will be included in Predbat's cost optimisation plan when it decides whether to charge, discharge the battery or let the house run on grid import. NB: For clarity and to re-emphasise, the \"virtual cost\" will be applied to BOTH the cost calculation for charging AND for discharging the battery. If you configure this number higher then more expensive plans will be selected which avoids charging and discharging your battery as much. Note that the cycle cost will not be included in the cost predictions that Predbat produces such as the Predbat HTML plan or Apex charts, it's just a cost taken into account by Predbat at the planning stage when the plan is calculated. NB: Setting this to a non-zero value will increase your daily cost, but will reduce your home battery usage. Figures of around 0p-2p are recommended, the default is 0p per kWh. input_number.predbat_metric_battery_value_scaling ( expert mode ) A percentage value that can be used to scale the value of the energy in the battery at the end of the plan. The battery value is accounted for in the optimisations at the lowest future import rate including charging and inverter losses. A value of 1.0 (the default) means no change to this, while lower than 1.0 means to value future battery levels less, greater than 1.0 will value it more (and hence hold more charge at the end of the plan). input_number.metric_self_sufficiency ( expert mode ) A price in pence per kWh used to skew the calculations towards self-sufficiency. Defaults to 0.0p/kWh. Effectively saying to Predbat to account for imports at a higher price than reality in the calculation and thus selecting plans with less import. If you want to be as self-sufficient as possible then set this to the difference between your lowest import rate and the highest export rate to take exports that require additional import appear unprofitable. This setting will not impact the real calculated costs and is only used for plan selection. Values of 5-10p may be worth trying if you prefer to avoid importing even if it saves you money. Scaling and weight options switch.predbat_metric_dynamic_load_adjust (default False) is a toggle that when enabled allows Predbat to take into account your energy consumption within the last 5 minutes. If the load is above what your battery can deliver the plan is updated to predict this load will continue during the current slot, thus preventing forced export in the plan. If car charging is planned but the load indicates that the car is not charging then Predbat will assume the car will no longer charge during this slot thus allowing the plan to include potential export. input_number.predbat_battery_rate_max_scaling is a percentage factor to adjust your maximum charge rate from that reported by the inverter. For example, a value of 0.95 would be 95% and indicate charging at 5% slower than reported. For GivEnergy inverters the charge rate reports the max AC rate and thus needs to be reduced by inverter losses. You can try computing your charge curve and check recommendations for changing this figure in the logfile. The default is 1.0, i.e. no scaling. input_number.predbat_battery_rate_max_scaling_discharge is a percentage factor to adjust your maximum discharge rate from that reported by the inverter. You can try computing your discharge curve and check recommendations for changing this figure in the logfile. The default is 1.05, i.e. battery discharges at 5% more power than the inverter reports. input_number.predbat_charge_scaling10 ( expert mode ) is a percentage factor applied to the battery charge rate specifically for the PV10% pessimistic scenario. This allows the PV10% prediction to model a slower battery charge rate to account for worst-case conditions (e.g. cold weather, battery degradation). For example, a value of 0.8 (the default) means the PV10% scenario assumes the battery will only charge at 80% of its normal rate. This setting only affects the PV10% scenario calculations and does not change the actual charge rate commands sent to your inverter. Use a lower value to be more pessimistic about charging capability in the worst-case scenario. The valid range is 0.1 to 1.0. switch.predbat_battery_capacity_nominal - When set to On, Predbat uses the reported battery size from the GivTCP 'Battery Nominal Capacity' field rather than from the normal GivTCP reported 'Battery Capacity kWh' size. If your battery size is reported wrongly maybe try turning this on and see if it helps. Defaults to Off. input_number.predbat_load_scaling is a percentage Scaling factor applied to the historical load, increase this if you want to be more pessimistic on future consumption. Use 1.0 to use exactly the previous load data. A value of 1.1 for example would add 10% to the historical load. The default value is 1.05 to add 5% scaling. Note that the output data entity predbat.load_energy_h0 will be scaled accordingly. input_number.predbat_load_scaling10 is a percentage Scaling factor applied to historical load only for the PV10% scenario (this is in addition to load_scaling above). This can be used to make the PV10% scenario take into account extra load usage and hence be more pessimistic while leaving the central scenario unchanged. The default is 1.1 meaning an extra 10% load is added. This will only have an impact if the PV 10% weighting is non-zero. input_number.predbat_load_scaling_saving is a percentage Scaling factor applied to historical load only during Octopus Saving sessions. This can be used to model your household cutting down on energy use inside a saving session (e.g. turning off a heat pump, deferring cooking until after the session, etc). The default is 1.0, i.e. no change to load in saving sessions. input_number.predbat_load_scaling_free is a percentage Scaling factor applied to historical load only during Free electricity sessions. This can be used to model your household increasing house load in a free electricity session (e.g. extra washing, cooking, tumble dryer, etc). The default is 1.2, i.e. 20% extra load in free electricity sessions. Solar PV adjustment options See also PV configuration options in apps.yaml including an explanation of PV10, PV50 and PV90 terminology. input_number.predbat_pv_scaling is a percentage scaling factor applied to PV data, decrease this if you want to be more pessimistic on PV production vs Solcast. Use 1.0 to accurately apply the Solcast forecast generation data. A value of 0.9, for instance, would reduce 10% from the Solcast generation forecast. input_number.predbat_pv_metric10_weight is the percentage weighting given to the Solcast 10% PV scenario in calculating solar generation. Use 0.0 to disable using the PV 10% in Predbat's forecast of solar generation. A value of 0.1 assumes that 1 in every 10 times we will get the Solcast 10% scenario, and 9 in every 10 times we will get the 'median' Solcast forecast. Predbat estimates solar generation for each half-hour slot to be a pv_metric10_weight weighting of the Solcast 10% PV forecast to the Solcast Median forecast. A value of 0.15 (the default) is recommended. switch.predbat_metric_pv_calibration_enable When turned On (the default), Predbat will use your historical solar generation data to calibrate your PV production estimates on a slot duration (default 30 minute) basis. This can be useful to adjust for your systems real performance. Do not use if you are using the Solcast integration and have turned on the integration's auto dampening . Predbat relies upon your solar generation being accurate so if your export generation can be curtailed by your solar inverter or your electricity supplier in periods when there is excess electricity in the grid, then you must turn PV calibration Off as otherwise Predbat will model the chopped solar generation as a PV calibration factor and will significantly reduce your forecast PV generation, leading to a very inaccurate plan. Historical load data The historical load data is taken from the load sensor as configured in apps.yaml with the days are selected using days_previous , and weighted using days_previous_weight in apps.yaml . switch.predbat_load_filter_modal ( expert mode ) when turned On (the default) will automatically discard the lowest daily consumption day from the list of days to use (provided you have more than 1 day selected in days_previous). This can be used to ignore a single low usage day in your average calculation. By default is feature is On but can be turned Off only in expert mode. switch.predbat_predheat_enable when turned On, uses the Predheat model to predict your home heating system. Outputs include predicted temperature and energy usage and costs. See Predheat documentation for details. Off by default. Car Charging There are a number of configuration items in Home Assistant for Predbat to control your car charging. These are described in detail in Car Charging and are listed here just for completeness: switch.predbat_car_charging_hold - remove the historical car charging load from the house load input_number.predbat_car_charging_threshold - power threshold above which Predbat assumes the car is being charged input_number.predbat_car_charging_energy_scale - used to scale the car_charging_energy sensor in apps.yaml input_number.predbat_car_charging_rate - car's charging rate in kW per hour input_number.predbat_car_charging_loss - percentage energy lost when charging the car switch.predbat_octopus_intelligent_charging - controls whether Octopus Intelligent (via the Octopus Energy integration) controls the car charging or Predbat plans the car charging switch.predbat_octopus_intelligent_ignore_unplugged ( expert mode ) - used with Octopus Intelligent to prevent Predbat from assuming the car will be charging when the car is unplugged binary_sensor.predbat_car_charging_slot - set to On by Predbat when the car should be charged (Predbat-led charging) select.predbat_car_charging_plan_time - the time you want the car to be charged by switch.predbat_car_charging_plan_smart - allows Predbat to allocate car charging slots to the cheapest times rather than all low-rate slots input_number.predbat_car_charging_plan_max_price - maximum price per kWh to pay when charging your car switch.predbat_car_charging_from_battery - prevent the car from draining the home battery when charging switch.predbat_car_charging_manual_soc - ignore the car_charging_soc car SoC sensor set in apps.yaml (car 0) switch.predbat_car_charging_manual_soc_1/2/3 - ignore the car_charging_soc car SoC sensor for cars 1/2/3 input_number.predbat_car_charging_manual_soc_kwh - manually maintained car SoC in kWh (car 0, used if car SoC sensor is not available) input_number.predbat_car_charging_manual_soc_kwh_1/2/3 - manually maintained car SoC in kWh for cars 1/2/3 Calculation options See the Predbat mode setting above for basic calculation options input_number.predbat_forecast_plan_hours is the minimum length of the Predbat charge plan, and is the number of hours after the first charge slot to include in the plan. The default of 24 hours is the recommended value (to match energy rate cycles). Note that the actual length of the Predbat plan will vary depending upon when the first charge slot is. switch.predbat_calculate_export_oncharge ( expert mode ) When turned On, calculated export slots will disable or move charge slots, allowing them to intermix in the plan. When Off (the default) export slots will never be placed into charge slots. switch.predbat_set_discharge_during_charge - When turned On disables inverter discharge during charge slots, useful for multi-inverter setups to avoid cross-charging when batteries are out of balance. Default is On. switch.predbat_inverter_set_charge_before - ( expert_mode ) When turned On (the default), charge slots will be programmed before their start time, when Off they will only be configured when the charging time starts. switch.predbat_calculate_tweak_plan ( expert mode ) When turned On causes Predbat to perform a second pass optimisation across the next 8 charge and export windows in time order. Turned Off by default. This can help to slightly improve the plan for tariffs like Agile but can make it worse in some fixed rate tariffs which you want to force export late. switch.predbat_calculate_second_pass ( expert mode ) When turned On causes Predbat to perform a second pass optimisation across all the charge and export windows in time order. NOTE: This feature is quite slow so may need a higher-performance machine so is turned Off by default. This can help to slightly improve the plan for tariffs like Agile but can make it worse in some fixed rate tariffs in which you want to force export late. switch.predbat_calculate_import_low_export ( expert_mode ) When turned On (the default), import slots of the same value are sorted by export price. When turned Off they are sorted just by price and then time. By default with this option turned On, if there are multiple charge slots of the same price Predbat will try to charge when the export rates are the lowest thus leaving the higher export slots available. switch.predbat_calculate_export_high_import ( expert_mode ) When turned On (the default) export slots of the same value are sorted by import price (to avoid exporting in the low price import slots). When Off export slots are sorted just by decreasing export price and then time (so high value exports are planned first). By default with this option On the latest export slots of the same value will be picked, this is useful for fixed-price export tariffs where you want to export as late in the day as you can, thus preserving the battery for as long as possible. Battery margins and metrics options input_number.predbat_best_soc_keep is the minimum battery level in kWh that Predbat will to try to keep the battery above for the Predbat plan. This is a soft constraint only that's used for longer-term planning and is ignored for the forthcoming first 4 hours of the plan. As this is not used for short-term planning your SoC can drop below this - use input_number.predbat_best_soc_min if you want to force all charges to be above a set level. It's usually good to have best_soc_keep set to 0kWh to use your entire battery, values above zero will end up costing more money but will ensure you have some spare battery kept back for emergency use. input_number.predbat_best_soc_keep_weight ( expert_mode ) Is used to tune how strongly you want the keep metric to apply. A value of 0 would essentially ignore keep while higher values will make it more important to always stay above your keep threshold even if it costs more money to do so. The default is 0.5 - this is the recommended setting. input_number.predbat_best_soc_min ( expert mode ) (default 0kWh) sets the minimum charge level (in kWh) for charging during each slot and the minimum force export level also (set to 0 if you want to skip some slots). If you set this to a non-zero value you will need to use the low rate threshold to control which slots you charge from or you may charge all the time. input_number.predbat_best_soc_max ( expert mode ) sets the maximum charge level (in kWh) for charging during each slot. A value of 0kWh (the default) disables this feature. input_number.combine_rate_threshold ( expert mode ) sets a threshold (in pence) to combine charge or export slots into a single larger average rate slot. The default is 0p which disables this feature and all rate changes result in a new slot. switch.predbat_combine_charge_slots Controls if charge slots of > the slot duration (default 30 minutes) can be combined. When turned Off (the default) they will be split up, increasing run times but potentially more accurate for planning. Turn this On combines charge slots together into a single block, useful to dissuade Predbat from repeatedly charging and discharging the battery to maximise income when the export rate is higher than the import rate, e.g. EV tariffs with a long overnight cheap rate. Turn this Off if you want to enable ad-hoc import during long periods of higher rates but you wouldn't charge normally in that period (e.g. pre-charge at the day rate before a saving session). switch.predbat_combine_export_slots ( expert mode ) Controls if export slots of > the slot duration (default 30 minute) can be combined. When turned Off (the default) they will be split up, increasing run times but potentially more accurate for planning. input_number.predbat_metric_min_improvement ( expert mode ) sets the minimum cost improvement in pence that it's worth lowering the battery SoC % for. The default value is 0.0p which means this feature is disabled and the battery will be charged less if it's cost neutral. If you use input_number.predbat_pv_metric10_weight then you probably don't need to use this as the 10% forecast does the same thing better Do not use it if you have multiple charge windows in a given period as it won't lead to good results (e.g. Agile) You could even go to something like -0.1 to say you would charge less even if it cost up to 0.1p more (best used with metric10). input_number.predbat_metric_min_improvement_export ( expert mode ) Sets the minimum pence cost improvement it's worth doing a forced export for. A value of 0.1p is the default which prevents any marginal exports as they must be worth at least 0.1 pence for a slot (less for shorter slots). If you increase this value (e.g. you only want to force export if very profitable), then exports will become less common. The value is in pence per slot of export time. input_number.predbat_metric_min_improvement_export_freeze ( expert mode ) Sets the minimum pence cost improvement it's worth doing an export freeze for. A value of 0.1p is the default which prevents any marginal freezes as they must be worth at least 0.1 pence for a slot duration (less for shorter slots). If you increase this value (e.g. you only want to freeze export if very profitable), then freeze exports will become less common. The value is in pence per slot of export time. input_number.predbat_metric_min_improvement_swap ( expert mode ) Sets the minimum improvement in cost to swap an export slot to a later time in the day. The default for this setting is -0.25p, meaning that export will be moved later even if it costs up to an extra 0.25p on the plan. The advantage of having late exports means that you are less likely to run out of battery earlier in the day. Values of between -1p and 0p would be recommended. input_number.predbat_rate_low_threshold ( expert mode ) When set to 0 (the default) Predbat will automatically look at the future import rates in the plan and determine the import rate threshold below which a slot will be considered to be a potential charging slot. If rate_low_threshold is set to a non-zero value this will set the threshold below future average import rates as the minimum to consider for a charge window, e.g. setting to 0.8 = 80% of the average rate. If you set this too low you might not get enough charge slots. If it's too high you might get too many in the 24-hour period which makes optimisation harder. input_number.predbat_rate_high_threshold ( expert mode ) When set to 0 (the default) Predbat will automatically look at the future export rates in the plan and determine the threshold above which a slot can be considered a potential exporting slot. If rate_high_threshold is set to a non-zero value this will set the threshold above future average export rates as the minimum export rate to consider exporting for, e.g. setting to 1.2 = 20% above average rate. If you set this too high you might not get any export slots. If it's too low you might get too many in the 24-hour period. input_number.predbat_metric_future_rate_offset_import ( expert mode ) Default 0p/kWh. Sets a pence per kWh offset to apply to future import energy rates that are not yet published, best used for variable rate tariffs such as Agile import where the rates are not published until 4pm. If you set this to a positive value then Predbat will assume unpublished import rates are higher by the given amount. Setting this to 1 to 1.5p for example results in Predbat being a little more aggressive in the charging calculation for today - Predbat will charge the battery to a higher percentage than it would otherwise as it expects a cost-benefit of using today's lower rates. NB: this can lead to higher costs and to some export if solar generation is better than forecast. input_number.predbat_metric_future_rate_offset_export ( expert mode ) Default 0p/kWh. Sets an offset to apply to future export energy rates that are not yet published, best used for variable rate tariffs such as Agile export where the rates are not published until 4pm. If you set this to a negative value then Predbat will assume unpublished export rates are lower by the given amount. switch.predbat_calculate_inday_adjustment Set to On by default. When turned on, will calculate the difference between today's actual load and today's predicated load and adjust the rest of the day's usage prediction accordingly. A scale factor can be set with input_number.predbat_metric_inday_adjust_damping ( expert mode ) (default 0.95) to either scale up or down the impact of the in-day adjustment (lower numbers scale down its impact). The in-day adjustment factor can be seen in predbat.load_inday_adjustment and charted with the In-Day Adjustment chart . input_number.predbat_carbon_metric ( carbon enable ) When Carbon footprint tracking is turned On ( switch.predbat_carbon_enable ) (Off by default), you can specify a cost per kg of CO2 used to weight the selection of plans. Values of around 10-200 will give varying outcomes to trade off cost vs carbon footprint of your system. Note: Carbon footprint tracking can only be turned on if apps.yaml is configured to point to the correct CO2 cost sensor Notifications Predbat can send mobile notifications for various events. You can control which types of notifications are sent using the following switches. Set the list of devices to notify in apps.yaml . Switch Default Controls switch.predbat_set_status_notify On Notifications when Predbat operational status changes (e.g. Idle, Charging, Exporting) switch.predbat_set_inverter_notify Off Notifications when inverter settings are changed (e.g. charge/discharge rates, reserve levels, time windows) switch.predbat_set_event_notify On Notifications for energy market events (e.g. Octopus Saving Sessions joined, Axle VPP events scheduled) switch.predbat_set_system_notify On Notifications for system events (e.g. auto-restart service, software updates, settings save/restore) Inverter control options switch.predbat_set_charge_low_power Enables low-power charging mode where the max charge rate will be automatically determined by Predbat to be the lowest possible rate to meet the charge target. This is only really effective for charge windows longer than a single slot. If this setting is turned on, it is strongly recommended that you create a battery_power_charge_curve in apps.yaml as otherwise the low power charge may not reach the charge target in time. This setting is off by default. The YouTube video low power charging and charging curve explains how the low-power charging works and shows how Predbat automatically creates it. input_number.predbat_charge_low_power_margin (requires switch.predbat_set_charge_low_power to be turned On) Controls how many minutes before the completion time to target finishing charging, this defaults to 10 but can be changed between 0 and 30. switch.predbat_set_reserve_enable ( expert_mode ) When turned On (the default) the battery reserve setting is used to hold the battery charge level once it has been reached or to protect against discharging beyond the set limit. switch.predbat_set_charge_freeze ( expert mode ) When turned On will allow Predbat to hold the current battery level while drawing from the grid/solar as an alternative to charging. On by default. switch.predbat_set_export_freeze When turned On (the default) will allow Predbat to export Solar to the grid rather than charging the battery. switch.predbat_set_export_freeze_only ( expert mode ) When turned On forced export is prevented, but export freeze can be used (if enabled) to export excess solar rather than charging the battery. This is useful with tariffs that pay you for solar exports but don't allow forced export (brown energy). Off by default. If you have switch.predbat_inverter_hybrid set to Off then if switch.predbat_inverter_soc_reset ( expert mode ) is set to On then the target SoC % will be reset to 100% outside of a charge window. This may be required for the AIO inverter to ensure it charges from solar. The default for this switch is On but it can be disabled in expert mode if need be. input_number.predbat_set_reserve_min Defines the battery reserve percentage for inverter 1, i.e. the minimum charge level that should be retained in the battery, a value of 4 is the default and minimum value and is recommended to make use of the full battery. When the battery level reaches the specified minimum level, your inverter will start importing from the grid to satisfy house load. If you want to pre-prepare the battery to retain extra charge in the event of a high likelihood of a grid power outage such as storms predicted, you can increase set_reserve_min to a higher value, and then change it back afterwards. (Obviously this is only any use if your inverter is wired to act as an Emergency Power Supply or whole-home backup 'island mode' on the GivEnergy AIO). input_number.predbat_set_reserve_min_1 defines the same minimum battery reserve percentage for inverter 2. Likewise predbat_set_reserve_min_2 and set_reserve_min_3 are the reserve minimums for inverter 3 and 4. Note that the input_number.predbat_set_reserve_min 's are used by Predbat to stop the battery SoC dropping below the specified level but are not used in planning battery charging. i.e. if you change a reserve min to a level higher than the current battery SoC then Predbat will not plan charging activity to increase the SoC to that level; you should set manual charges to increase the SoC level. switch.predbat_inverter_soc_reset ( expert mode ) When set to On (the default) the target SoC for the inverter(s) will be reset to 100% when a charge slot is not active, this can be used to workaround some firmware issues where the SoC target is used for solar charging as well as grid charging. When disabled the SoC target % will not be changed after a charge slot. input_number.inverter_limit_override When non-zero sets the maximum rate (in Watts) to set the battery charge or discharge rate to when in operation. Useful to workaround bad installs that trip the fuse/breaker when operating at full power. A value of 0 applies no limit. Balance Inverters When you have two or more inverters it's possible they get out of sync so they are at different charge levels or they start to cross-charge (one discharges into another). When enabled, balance inverters try to recover this situation by disabling either charging or discharging from one of the batteries until they re-align. If you do use Predbat's balance inverter function then be aware that Predbat will start repeatedly and rapidly updating your inverter settings to keep the inverters in balance with each other. This can be a problem with inverters that have a limited life-span flash memory . If available, you are strongly recommended to turn on \"real time registers\" using switch.givtcp_xxxx_real_time_control for GivEnergy inverters controlled via GivTCP, or an equivalent function for your inverter. The apps.yaml contains a setting balance_inverters_seconds which defines how often to run the balancing, 30 seconds is recommended if your machine is fast enough, but the default is 60 seconds. Turn On switch.predbat_balance_inverters_enable to enable this feature. It is Off by default. When turned on a number of other balance controls and configurations are made available: switch.predbat_balance_inverters_charge - Is used to toggle on/off balancing while the batteries are charging switch.predbat_balance_inverters_discharge - Is used to toggle on/off balancing while the batteries are discharging switch.predbat_balance_inverters_crosscharge - Is used to toggle on/off balancing when the batteries are cross charging input_number.predbat_balance_inverters_threshold_charge - Sets the minimum percentage divergence of SoC during charge before balancing, default is 1% input_number.predbat_balance_inverters_threshold_discharge - Sets the minimum percentage divergence of SoC during discharge before balancing, default is 1% Freeze Export during Demand An alternative to Predbat's full inverter balancing option if you have multiple inverters that can cross charge when the inverter is in Eco/Demand mode, is switch.predbat_set_freeze_export_during_demand ( expert mode ). Typically overnight when there is no solar generation and inverters are just meeting house load (Demand mode), multi-inverter setups will start cross charging from one inverter battery to another. If you turn On switch.predbat_set_freeze_export_during_demand then when Predbat is not charging or discharging, i.e. would be in Demand mode, then Predbat will override the normal Demand mode and set the inverters to Freeze Export mode which allows battery discharge, but not battery charging; thus preventing inverter cross-charging. It is recommended that you control switch.predbat_set_freeze_export_during_demand via an automation, such as turning it Off at sunrise and On at sunset so that the batteries can charge normally via solar generation. NB: Setting this switch to On has no affect on Predbat's planned Charging and Export activity, those will be executed normally, the switch only affects Demand mode. When the Freeze Export override is active, Predbat status will have '[Freeze exporting]' appended to the status. Cloud coverage and load variance By default Predbat tries to model passing clouds by modulating the PV forecast data on a 5-minute interval up and down while retaining the same predicted total. The amount of modulation depends on the difference between the PV50% (default) and PV10% scenario produced by Solcast. You can disable this feature ( expert mode only ) using switch.predbat_metric_cloud_enable . By default Predbat tries to model changes in your household load by modulating the historical data on a 5-minute interval up and down while retaining the same predicted total. The amount of modulation depends on the standard deviation of your load predictions over the coming period (currently 4 hours). You can disable this feature ( expert mode only ) using switch.metric_load_divergence_enable . iBoost model options Predbat has an 'iBoost model' that can be used to model using excess solar energy to heat hot water (or similar) instead of it being exported to the grid. This model can be used to control any solar diverter device, for example, an iBoost (e.g. using a Fingerbot or similar device to physically press the 'boost' button on the iBoost), a MyEnergy Eddi (using the MyEnergy integration), or it can be used with a high-power smart switch to turn on the hot water cylinder immersion heater when there is excess solar. So although Predbat refers to controlling an iBoost, you are not limited to just an iBoost device when using this model within Predbat. To turn the model on, switch.predbat_iboost_enable needs to be turned On (default is Off). The predicted output from the iBoost solar diverter model is returned in predbat.iboost_best and is populated in the 'iBoost' column of the Predbat plan . iBoost basic configuration When you turn on predbat_iBoost_enable the following additional Home Assistant entities are created by Predbat: input_number.predbat_iboost_max_energy Sets the maximum energy in kWh that the solar diverter can consume during a day before turning off - default 3kWh. input_number.predbat_iboost_max_power Sets the maximum power in watts that the solar diverter will consume - default 2400. input_number.predbat_iboost_min_power Sets the minimum power in watts that the solar diverter will consume - default 500. input_number.predbat_iboost_value_scaling Sets how to account for the value of iBoost units of energy. The default value of 0.75 means that each kWh of energy diverted is accounted for as 0.75 times The lowest future import rate. Higher values will generate plans with more solar diversion while lower values will generate less. A value of 0 means all diverted energy should be ignored in planning (assumed to be zero value). switch.predbat_iboost_energy_subtract When turned On (the default) energy reported by the iboost_energy_today sensor configured in apps.yaml will be subtracted from your historical load data to improve the accuracy of predictions. If you are using PredAI you will also need to subtract this data inside PredAI configuration. Different boost modes can be selected: iBoost modes Solar switch.predbat_iboost_solar When turned On, Predbat assumes the diverter will use solar power to boost the hot water heating. switch.predbat_iboost_solar_excess When turned Off (the default) will allow any solar power to be diverted while if enabled only excess power (power that would otherwise be exported) will be used. By default iboost will not run the battery is in force export mode unless you turn on switch.predbat_iboost_on_export . input_number.predbat_iboost_min_soc sets the minimum home battery SoC percentage that must be in the battery before the solar diverter is turned on. The default is 0 meaning hot water heating can occur regardless of what SoC level the battery is at. Battery switch.predbat_iboost_charging If set to On, the diverter will operate when the battery is charging (can be combined with solar) Energy rates only If both of the above are Off, but iBoost is turned On then boost will happen solely based on energy rates (see below). switch.predbat_iboost_smart Will pick the lowest import rate slots within 24 hours to achieve the desired energy as specified by input_number.predbat_iboost_max_energy . Only slots at or below the rate threshold will be selected. Note this option only applies when iboost_solar and iboost battery are both Off. input_number.predbat_iboost_smart_min_length Sets the minimum slot length in minutes to iBoost (only applies for energy rate only modes). The default is 30 minutes but can be set in multiples of the slot duration (default 30 minutes). Increasing this slot size could increase costs depending on your tariff. switch.predbat_iboost_on_export If set to On allows iBoost to run even if the battery is forced to export to the grid, otherwise it won't run in these circumstances. switch.predbat_iboost_prevent_discharge When set to On will stop your battery from discharging when iBoost is active and thus prevent your battery from draining to the diverter. This switch will work in all modes and is not recommended to be used when iBoost Solar is On as it will prevent your battery from discharging during excess solar periods which could cause additional imports due to passing clouds. iBoost energy rate filtering input_number.predbat_iboost_rate_threshold Sets the maximum import rate (in pence) that the diverter will trigger on, defaults to 100. input_number.predbat_iboost_rate_threshold_export Sets the maximum export rate (in pence) that the diverter will trigger on, defaults to 100. switch.predbat_iboost_gas When turned On will control the diverter to only operate when import electric rates are lower than gas rates. switch.predbat_iboost_gas_export When turned On will control the diverter to only operate when export electric rates are lower than gas rates. These can be useful if you have the choice to heat your hot water by immersion heater or by gas boiler. Note: Gas rates have to be configured in apps.yaml using metric_octopus_gas or rates_gas depending upon whether you are using the Octopus Integration or not. input_number.predbat_iboost_gas_scale Sets the scaling of the gas rates (set in apps.yaml )used before comparing with electric rates, to account for gas boiler losses and efficiency. It should be set to the reciprocal of the boiler efficiency, i.e. for an 80% efficient gas boiler, set to 1.25. iBoost control iBoost output data You will see input_number.predbat_iboost_today entity which tracks the estimated kWh consumed by the solar diverter during the day, and resets at midnight every night. The binary_sensor.predbat_iboost_active entity will be turned On when the solar diverter should be active and can be used for automations to trigger the immersion heater boost. The attributes within this sensor include 'solar' which includes Solar diversion should be active and 'full' which indicates iBoost should run at maximum rate (could be during a charge cycle or grid import). Example template automation for controlling the solar diverter: alias: Solar Diverter description: \"Start/stop solar diverter based on Predbat-determined slots\" trigger: - platform: state entity_id: - binary_sensor.predbat_iboost_active action: - choose: - conditions: - condition: state entity_id: binary_sensor.predbat_iboost_active state: \"True\" sequence: <commands to turn on your solar diverter> - conditions: - condition: state entity_id: binary_sensor.predbat_iboost_active state: \"False\" sequence: <commands to turn off your solar diverter> mode: single If you have an incrementing sensor that tracks the solar diverter energy usage then to make your predictions more accurate you should set the iboost_energy_today sensor in apps.yaml to point to it, and optionally set iboost_energy_scaling if the sensor isn't in kWh (e.g. set to 0.001 if the sensor is in Watts). The sensor should be an incrementing sensor which can reset at midnight or not. Holiday mode When you go away you are likely to use less electricity and so the previous load data will be quite pessimistic. Using the Home Assistant entity input_number.predbat_holiday_days_left you can set the number of full days that you will be away (including today). The number will count down by 1 day at midnight until it gets back to zero. Whilst the holiday days left are non-zero, Predbat's 'holiday mode' is active. When Predbat is in 'Demand' mode (i.e. not actively charging or discharging) and 'holiday mode' is active, Predbat's status will show as 'Demand (Holiday)'. When Predbat's 'holiday mode' is active the historical load data will be taken from yesterday's data (1 day ago) rather than from the days_previous setting in apps.yaml . This means Predbat will adjust more quickly to the new usage pattern. If you have been away for a longer period (more than your normal days_previous setting) then obviously it's going to take longer for the historical data to catch up, you could then enable holiday mode for another 7 days after your return. In summary: For short holidays set holiday_days_left to the number of full days you are away, including today but excluding the return day For longer holidays set holiday_days_left to the number of days you are away plus another 7 days until the data catches back up Manual Control In some cases, you may want to override Predbat's planned behaviour and make a decision yourself. One way to achieve this is to put Predbat into read-only mode using switch.predbat_set_read_only . When going to read-only mode the inverter will be put back to the default settings and you can then control it yourself using your inverter controls directly. A better alternative in some cases is to tell Predbat what you want it to do in a particular time slot using the Manual Control feature. Note that none of the manual control commands override the Predbat mode you have selected. So if for example you want to force Predbat to charge then you need to be in either 'Control charge' or 'Control charge & discharge' mode, and if you want to force Predbat to export then you need to be in 'Control charge & discharge mode'. You can force the battery to be charged within a single slot by using the select.predbat_manual_charge selector. Pick the day and time slot you wish to charge in (up to 48 hours in advance), and Predbat will change the plan to charge in the selected slot. You can select multiple slots by using the drop-down menu more than once. Selected slots will be shown in the list in square brackets, and you can cancel a Manual Control slot by selecting the slot time again. When you use the Manual Control features you can select the day and time from the next 48 hours, the overrides will be removed once their time slot expires (they do not repeat). The off option at the bottom of the list will cancel all selected force charges. When Predbat updates the plan you will see the slots that have been manually picked to be charging slots annotated in the Predbat HTML plan with an upside down 'F' symbol. If you use the selector from an automation you can combine multiple time slots together, with times in the format HH:MM. Entering the slot day is optional from an automation, and if you do not enter a day then the next slot with the matching time will be chosen. For example, the following automation action will set Predbat to charge in the next 22:00, 22:30 and 23:00 slots: action: select.select_option target: entity_id: - select.predbat_manual_charge data: option: >- 22:00,22:30,23:00 All the other select.predbat_manual_XX controls operate in a similar way. NOTE : once you select a day/time slot from any of the select.predbat_manual_XX selectors the selected time slot is immediately marked on the drop-down and you can then make another change. Predbat still has to update the plan which it will be doing so in the background, and this can take a few minutes to run (depending on the speed and power of the device you are running Home Assistant on), so don't be surprised why the Predbat plan doesn't change immediately - remember you can see the date/time the plan was last updated on the first row of the plan. As an alternative to selecting day/time slots from the select.predbat_manual_xx drop down lists, you can select a time slot then select the mode you want Predbat to be in from the Predbat plan shown in the Web Console . This might be easier to use than the selector controls. CAUTION: If you leave Predbat turned off for a long period of time then the override timeslots could end up repeating when you restart The select.predbat_manual_export selector can be used to manually force Predbat to export within a slot. If you set a force export then this takes priority over force charging. The select.predbat_manual_demand selector is used to force Predbat to demand mode for a slot, this implies no forced grid charging or exporting of the battery. House load will be supplied from solar, or the battery if there is insufficient solar, or grid import if there is insufficient battery charge. This is described as 'Eco' Mode for GivEnergy inverters but other inverters use different terminology. The select.predbat_manual_freeze_charge selector is used to force Predbat to freeze charge during a slot, this implies the battery will not discharge and will hold at the current level. The grid may be used if solar is not enough to cover the load. The select.predbat_manual_freeze_export selector is used to force Predbat to freeze export during a slot, this implies the battery will not charge but will still discharge for the house load. Any solar will be exported to the grid. The select.predbat_manual_import_rates selector is used to override the import rates for a slot, the rate selected will be that configured in input_number.predbat_manual_import_value (default 0p) which can be adjusted prior to making a selection. As with the other selectors the selection can be cleared by selecting the option in square brackets or by using off If this selector is used in an automation you can set the time and rate together by making a selection in the format HH:MM=rate e.g. 12:30=29.5 The select.predbat_manual_export_rates selector is used to override the export rates for a slot, the rate selected will be that configured in input_number.predbat_manual_export_value (default 0p) which can be adjusted prior to making a selection. Similar to manual_import_rates, if this selector is used in an automation you can set the time and rate together by making a selection in the format HH:MM=rate e.g. 12:30=29.5 The select.predbat_manual_load_adjust selector is used to make adjustments to the predicted load in kWh for a slot, the load adjustment amount will be that configured in input_number.predbat_manual_load_value (default 0.5kWh) which can be adjusted prior to making a selection. Predbat will add the adjustment amount to the kWh predicted load for those slots. If this selector is used in an automation you can set the time and kWh load adjustment amount together by making a selection in the format HH:MM=adjustment e.g. 12:30=0.5 The select.predbat_manual_soc selector is used to set a target State of Charge (SoC) percentage for a specific time. This is useful when you know you need a certain battery level at a particular time, for example before peak rates start or when you expect higher than normal consumption. The SoC target percentage will be that configured in input_number.predbat_manual_soc_value (default 100%) which can be adjusted prior to making a selection. For example, if you want the battery to be at 100% by 05:30, select that time slot. Predbat will plan charging to ensure the battery reaches the target SoC by that time. Note that the manual SoC target is a minimum SoC level for that time slot. If based upon your predicted load, solar generation and energy costs Predbat determines that your battery needs to be charged to a higher SoC level to minimise your costs, Predbat will charge to that required level. If this selector is used in an automation you can set the time and SoC together by making a selection in the format HH:MM=percentage e.g. 05:30=100 The manual SoC target works in conjunction with the weather alert system - if both are active at the same time, the higher SoC target will be used. Manual API select.predbat_manual_api enables you to overwrite configuration entries normally set in apps.yaml , e.g. from an automation. This is described in detail in Manual API and is mentioned here just for completeness. Debug switch.predbat_debug_enable When turned On will create lots of debugging information to aid diagnosis of Predbat issues. By default this is turned Off and its recommended that its only switched on when debug logs are requested. With the switch on: Firstly Predbat prints lots of extra debug information in the Predbat logfile which means the logfile will fill and swap to a new file more rapidly Secondly Predbat will create a debug output file 'debug/predbat_debug_HH_MM_SS.yaml' in a subfolder of the Predbat installation directory. This file contains a full export of your current Predbat config and is extremely useful to enable recreating your setup to diagnose issues. Any sensitive information such as Solcast or GivEnergy Cloud API keys are automatically removed. The following automation might be useful to automatically turn off Predbat debug mode after turning it on to capture the debug logs: alias: \"Predbat: Auto turn-off debug mode\" description: \"\" triggers: - trigger: state entity_id: - switch.predbat_debug_enable to: \"on\" for: minutes: 10 conditions: [] actions: - action: script.notify_all_devices metadata: {} data: title: \"INFO: Turned off Predbat debug after 10 minutes\" critical: \"N\" url: \"\" message: switch.predbat_debug_enable turned off - action: switch.turn_off target: entity_id: switch.predbat_debug_enable data: {} mode: single switch.predbat_plan_debug ( expert mode ) when turned On adds some extra debug to the Predbat HTML plan - see Predbat Plan debug mode for more details. Off by default. Updating Predbat You can either manually update Predbat to a new (or old) version or set Predbat to automatically update itself. These are described in detail in Updating Predbat and are listed here just for completeness: select.predbat_update - List of Predbat software versions you can select to update Predbat to switch.predbat_auto_update - When On, Predbat will automatically update itself as new releases are published on GitHub.","title":"Customisation"},{"location":"customisation/#customisation","text":"This document describes the Predbat configuration items in Home Assistant that you can modify to customise Predbat to fit your needs. All of these settings are entities that can be configured directly in Home Assistant (unlike the ' apps.yaml ' configuration items that have to be edited with a file editor). Note the default values of the settings inside Home Assistant are set inside Predbat, but the default can be overridden by setting its value in apps.yaml prior to starting Predbat for the first time. See Displaying output data for information on how to view and edit these entities within Home Assistant.","title":"Customisation"},{"location":"customisation/#saving-and-restoring-predbat-settings","text":"The selector select.predbat_saverestore can be used to save your current Predbat settings to a YAML file (kept in the directory /config/predbat_save/ ) and to restore the settings from one of these files. Selecting the selector option save current will cause the settings to be saved to a date/time-stamped file. You can rename this file yourself in the Home Assistant filesystem to give it a more human-readable name or delete it if you no longer want to keep it. This is normally best done in an SSH window or via a Samba mount. Selecting the option restore default will put all your settings back to the Predbat defaults. Before the restore, the current Predbat settings will be saved to the file previous.yaml - should you have made a mistake you can restore them quickly again. Selecting any of the .yaml files you have created will restore your settings from this file.","title":"Saving and restoring Predbat settings"},{"location":"customisation/#predbat-mode","text":"The mode that Predbat operates in will change the operation, this can be configured with select.predbat_mode drop-down menu as follows: Monitor Control SoC only Control charge Control charge & discharge If the switch.predbat_set_read_only is set to On then this prevents Predbat from making modifications to the inverter settings (regardless of the configuration). Predbat will continue making and updating its prediction plan every 10 minutes (by default), but no inverter changes will be made. This is useful if you want to override what Predbat is planning to do (e.g. your own automation), or whilst you are learning how Predbat works before turning it on 'in anger'. NOTE: Changing the Predbat mode or the read-only switch will cause Predbat to reset the inverter settings to default, this will disable both charge and discharge, reset charge and discharge rates to full power and reset the reserve to the default setting","title":"Predbat mode"},{"location":"customisation/#predbat-monitor-mode","text":"In Monitor mode Predbat will not control or Plan any charging or discharging, inverter balancing will take place if enabled, and the plan will show just what is expected based on the current inverter configuration alone.","title":"Predbat Monitor mode"},{"location":"customisation/#predbat-control-soc-only-mode","text":"In Control SoC only mode Predbat will adjust the target charge percentage (SoC target) according to the Best plan, but the charge window will not be modified. This mode can be useful if you just have one fixed charge slot per day and you only want Predbat to control the percentage the battery is charged based on solar generation and predicted house load. CAUTION: You must manually set any charging required on the inverter and if the charge window is disabled then no charging will take place.","title":"Predbat Control SoC only mode"},{"location":"customisation/#predbat-control-charge-mode","text":"In Control charge mode Predbat will set the charge times and charge percentages according to the Best plan, charging can be enabled and disabled by Predbat. Predbat will set the inverter into Eco mode when required to enable the battery to support house load, but it will not plan any forced discharging of the battery for export purposes. This mode can be useful if you don't have an export rate, you have a 'no export' limitation from your electricity supplier, or if you want to preserve the battery for home demand.","title":"Predbat Control charge mode"},{"location":"customisation/#predbat-control-charge-discharge-mode","text":"In Control charge & discharge mode Predbat will set both charge and force export (discharge) times and control charge and force export percentages. If you have set the switch.predbat_set_export_freeze_only set to On then forced export won't occur but Predbat can force the export of solar power to the grid when desired.","title":"Predbat Control charge &amp; discharge mode"},{"location":"customisation/#expert-mode","text":"Predbat has a toggle switch called switch.predbat_expert_mode which is set to Off by default for new installs (On by default for upgraded installs). A lot of Predbat's more advanced configuration options will not be available unless expert mode is turned On. It's recommended for new users to start without expert mode and then maybe turn it on later once you become more confident with the tool.","title":"Expert mode"},{"location":"customisation/#performance-related","text":"Predbat controls the inverter every 5 minutes it runs, and by default, updates and recalculates the plan every 10 minutes. This can however use a lot of CPU power especially on more complex tariffs like Agile when run on lower power machines such as Raspberry PIs and some thin clients. You can tweak input_number.predbat_calculate_plan_every ( expert mode ) (default 10 minutes) to reduce the frequency of replanning while keeping the inverter control in the fixed 5-minute slots. E.g. a value of 10 or 15 minutes should also give good results. If you have performance problems leave switch.predbat_calculate_second_pass ( expert mode ) turned Off as it's quite CPU intensive and provides very little improvement for most systems. You can turn on switch.predbat_combine_charge_slots and switch.predbat_combine_export_slots ( expert mode ) to speed up planning. Note: Combining export slots may prevent optimal forced export. Combining charge slots is usually fine for tariffs with longer periods of fixed rates but can limit the planning ability in some cases. The number of CPU threads you use can change your performance, you can set threads in apps.yaml to 0 to disable threading if you don't have multiple CPUs available, or set it to 'auto' (the default) to use one thread per CPU. It is recommended you don't set this to an odd number of threads.","title":"Performance related"},{"location":"customisation/#battery-loss-options","text":"input_number.predbat_battery_loss is an assumed percentage figure for energy lost when charging the battery, the default 0.03 is 3%. input_number.predbat_battery_loss_discharge is an assumed percentage figure for energy lost whilst discharging the battery, the default 0.03 is 3%. input_number.predbat_inverter_loss is an assumed percentage figure for energy lost during the conversion within the inverter from DC to AC or AC to DC, the default 0.04 is 4%. TIP: Make sure you set the losses correctly, they are decimal percentages, so don't set them to '4' thinking it'll be 4%, Predbat will take this as being 400% and your plan will be very strange! switch.predbat_inverter_hybrid Set to On (the default) if you have a hybrid inverter so no inverter losses will be applied for DC charging from Solar generation. You should set it to Off if you have an AC-coupled battery and inverter losses will be applied when the battery is charging from solar. NB: This switch only applies when Predbat is modelling solar charging. All grid charging (regardless of inverter type) has to undergo an AC to DC conversion so the inverter_loss % will be included in Predbat's model when charging from the grid. input_number.predbat_metric_battery_cycle ( expert mode ) This sets a 'virtual cost' in pence per kWh on using your battery for charging and discharging. Higher numbers will reduce battery cycles at the expense of using higher energy costs. In theory, if you have a 9.5kWh battery and think it will last say 6000 complete cycles and it cost you \u00a34000, then each full charge and discharge cycle is 19kWh and so the cost per complete cycle is \u00a34000 / 19 / 6000 = 3.5p. Taking the 3.5p per cycle example, if you set predbat_metric_battery_cycle to 1.75 (half of 3.5) then Predbat will apply the \"virtual cost\" of 1.75p to every kWh of charge and discharge of the battery. This cost will be included in Predbat's cost optimisation plan when it decides whether to charge, discharge the battery or let the house run on grid import. NB: For clarity and to re-emphasise, the \"virtual cost\" will be applied to BOTH the cost calculation for charging AND for discharging the battery. If you configure this number higher then more expensive plans will be selected which avoids charging and discharging your battery as much. Note that the cycle cost will not be included in the cost predictions that Predbat produces such as the Predbat HTML plan or Apex charts, it's just a cost taken into account by Predbat at the planning stage when the plan is calculated. NB: Setting this to a non-zero value will increase your daily cost, but will reduce your home battery usage. Figures of around 0p-2p are recommended, the default is 0p per kWh. input_number.predbat_metric_battery_value_scaling ( expert mode ) A percentage value that can be used to scale the value of the energy in the battery at the end of the plan. The battery value is accounted for in the optimisations at the lowest future import rate including charging and inverter losses. A value of 1.0 (the default) means no change to this, while lower than 1.0 means to value future battery levels less, greater than 1.0 will value it more (and hence hold more charge at the end of the plan). input_number.metric_self_sufficiency ( expert mode ) A price in pence per kWh used to skew the calculations towards self-sufficiency. Defaults to 0.0p/kWh. Effectively saying to Predbat to account for imports at a higher price than reality in the calculation and thus selecting plans with less import. If you want to be as self-sufficient as possible then set this to the difference between your lowest import rate and the highest export rate to take exports that require additional import appear unprofitable. This setting will not impact the real calculated costs and is only used for plan selection. Values of 5-10p may be worth trying if you prefer to avoid importing even if it saves you money.","title":"Battery loss options"},{"location":"customisation/#scaling-and-weight-options","text":"switch.predbat_metric_dynamic_load_adjust (default False) is a toggle that when enabled allows Predbat to take into account your energy consumption within the last 5 minutes. If the load is above what your battery can deliver the plan is updated to predict this load will continue during the current slot, thus preventing forced export in the plan. If car charging is planned but the load indicates that the car is not charging then Predbat will assume the car will no longer charge during this slot thus allowing the plan to include potential export. input_number.predbat_battery_rate_max_scaling is a percentage factor to adjust your maximum charge rate from that reported by the inverter. For example, a value of 0.95 would be 95% and indicate charging at 5% slower than reported. For GivEnergy inverters the charge rate reports the max AC rate and thus needs to be reduced by inverter losses. You can try computing your charge curve and check recommendations for changing this figure in the logfile. The default is 1.0, i.e. no scaling. input_number.predbat_battery_rate_max_scaling_discharge is a percentage factor to adjust your maximum discharge rate from that reported by the inverter. You can try computing your discharge curve and check recommendations for changing this figure in the logfile. The default is 1.05, i.e. battery discharges at 5% more power than the inverter reports. input_number.predbat_charge_scaling10 ( expert mode ) is a percentage factor applied to the battery charge rate specifically for the PV10% pessimistic scenario. This allows the PV10% prediction to model a slower battery charge rate to account for worst-case conditions (e.g. cold weather, battery degradation). For example, a value of 0.8 (the default) means the PV10% scenario assumes the battery will only charge at 80% of its normal rate. This setting only affects the PV10% scenario calculations and does not change the actual charge rate commands sent to your inverter. Use a lower value to be more pessimistic about charging capability in the worst-case scenario. The valid range is 0.1 to 1.0. switch.predbat_battery_capacity_nominal - When set to On, Predbat uses the reported battery size from the GivTCP 'Battery Nominal Capacity' field rather than from the normal GivTCP reported 'Battery Capacity kWh' size. If your battery size is reported wrongly maybe try turning this on and see if it helps. Defaults to Off. input_number.predbat_load_scaling is a percentage Scaling factor applied to the historical load, increase this if you want to be more pessimistic on future consumption. Use 1.0 to use exactly the previous load data. A value of 1.1 for example would add 10% to the historical load. The default value is 1.05 to add 5% scaling. Note that the output data entity predbat.load_energy_h0 will be scaled accordingly. input_number.predbat_load_scaling10 is a percentage Scaling factor applied to historical load only for the PV10% scenario (this is in addition to load_scaling above). This can be used to make the PV10% scenario take into account extra load usage and hence be more pessimistic while leaving the central scenario unchanged. The default is 1.1 meaning an extra 10% load is added. This will only have an impact if the PV 10% weighting is non-zero. input_number.predbat_load_scaling_saving is a percentage Scaling factor applied to historical load only during Octopus Saving sessions. This can be used to model your household cutting down on energy use inside a saving session (e.g. turning off a heat pump, deferring cooking until after the session, etc). The default is 1.0, i.e. no change to load in saving sessions. input_number.predbat_load_scaling_free is a percentage Scaling factor applied to historical load only during Free electricity sessions. This can be used to model your household increasing house load in a free electricity session (e.g. extra washing, cooking, tumble dryer, etc). The default is 1.2, i.e. 20% extra load in free electricity sessions.","title":"Scaling and weight options"},{"location":"customisation/#solar-pv-adjustment-options","text":"See also PV configuration options in apps.yaml including an explanation of PV10, PV50 and PV90 terminology. input_number.predbat_pv_scaling is a percentage scaling factor applied to PV data, decrease this if you want to be more pessimistic on PV production vs Solcast. Use 1.0 to accurately apply the Solcast forecast generation data. A value of 0.9, for instance, would reduce 10% from the Solcast generation forecast. input_number.predbat_pv_metric10_weight is the percentage weighting given to the Solcast 10% PV scenario in calculating solar generation. Use 0.0 to disable using the PV 10% in Predbat's forecast of solar generation. A value of 0.1 assumes that 1 in every 10 times we will get the Solcast 10% scenario, and 9 in every 10 times we will get the 'median' Solcast forecast. Predbat estimates solar generation for each half-hour slot to be a pv_metric10_weight weighting of the Solcast 10% PV forecast to the Solcast Median forecast. A value of 0.15 (the default) is recommended. switch.predbat_metric_pv_calibration_enable When turned On (the default), Predbat will use your historical solar generation data to calibrate your PV production estimates on a slot duration (default 30 minute) basis. This can be useful to adjust for your systems real performance. Do not use if you are using the Solcast integration and have turned on the integration's auto dampening . Predbat relies upon your solar generation being accurate so if your export generation can be curtailed by your solar inverter or your electricity supplier in periods when there is excess electricity in the grid, then you must turn PV calibration Off as otherwise Predbat will model the chopped solar generation as a PV calibration factor and will significantly reduce your forecast PV generation, leading to a very inaccurate plan.","title":"Solar PV adjustment options"},{"location":"customisation/#historical-load-data","text":"The historical load data is taken from the load sensor as configured in apps.yaml with the days are selected using days_previous , and weighted using days_previous_weight in apps.yaml . switch.predbat_load_filter_modal ( expert mode ) when turned On (the default) will automatically discard the lowest daily consumption day from the list of days to use (provided you have more than 1 day selected in days_previous). This can be used to ignore a single low usage day in your average calculation. By default is feature is On but can be turned Off only in expert mode. switch.predbat_predheat_enable when turned On, uses the Predheat model to predict your home heating system. Outputs include predicted temperature and energy usage and costs. See Predheat documentation for details. Off by default.","title":"Historical load data"},{"location":"customisation/#car-charging","text":"There are a number of configuration items in Home Assistant for Predbat to control your car charging. These are described in detail in Car Charging and are listed here just for completeness: switch.predbat_car_charging_hold - remove the historical car charging load from the house load input_number.predbat_car_charging_threshold - power threshold above which Predbat assumes the car is being charged input_number.predbat_car_charging_energy_scale - used to scale the car_charging_energy sensor in apps.yaml input_number.predbat_car_charging_rate - car's charging rate in kW per hour input_number.predbat_car_charging_loss - percentage energy lost when charging the car switch.predbat_octopus_intelligent_charging - controls whether Octopus Intelligent (via the Octopus Energy integration) controls the car charging or Predbat plans the car charging switch.predbat_octopus_intelligent_ignore_unplugged ( expert mode ) - used with Octopus Intelligent to prevent Predbat from assuming the car will be charging when the car is unplugged binary_sensor.predbat_car_charging_slot - set to On by Predbat when the car should be charged (Predbat-led charging) select.predbat_car_charging_plan_time - the time you want the car to be charged by switch.predbat_car_charging_plan_smart - allows Predbat to allocate car charging slots to the cheapest times rather than all low-rate slots input_number.predbat_car_charging_plan_max_price - maximum price per kWh to pay when charging your car switch.predbat_car_charging_from_battery - prevent the car from draining the home battery when charging switch.predbat_car_charging_manual_soc - ignore the car_charging_soc car SoC sensor set in apps.yaml (car 0) switch.predbat_car_charging_manual_soc_1/2/3 - ignore the car_charging_soc car SoC sensor for cars 1/2/3 input_number.predbat_car_charging_manual_soc_kwh - manually maintained car SoC in kWh (car 0, used if car SoC sensor is not available) input_number.predbat_car_charging_manual_soc_kwh_1/2/3 - manually maintained car SoC in kWh for cars 1/2/3","title":"Car Charging"},{"location":"customisation/#calculation-options","text":"See the Predbat mode setting above for basic calculation options input_number.predbat_forecast_plan_hours is the minimum length of the Predbat charge plan, and is the number of hours after the first charge slot to include in the plan. The default of 24 hours is the recommended value (to match energy rate cycles). Note that the actual length of the Predbat plan will vary depending upon when the first charge slot is. switch.predbat_calculate_export_oncharge ( expert mode ) When turned On, calculated export slots will disable or move charge slots, allowing them to intermix in the plan. When Off (the default) export slots will never be placed into charge slots. switch.predbat_set_discharge_during_charge - When turned On disables inverter discharge during charge slots, useful for multi-inverter setups to avoid cross-charging when batteries are out of balance. Default is On. switch.predbat_inverter_set_charge_before - ( expert_mode ) When turned On (the default), charge slots will be programmed before their start time, when Off they will only be configured when the charging time starts. switch.predbat_calculate_tweak_plan ( expert mode ) When turned On causes Predbat to perform a second pass optimisation across the next 8 charge and export windows in time order. Turned Off by default. This can help to slightly improve the plan for tariffs like Agile but can make it worse in some fixed rate tariffs which you want to force export late. switch.predbat_calculate_second_pass ( expert mode ) When turned On causes Predbat to perform a second pass optimisation across all the charge and export windows in time order. NOTE: This feature is quite slow so may need a higher-performance machine so is turned Off by default. This can help to slightly improve the plan for tariffs like Agile but can make it worse in some fixed rate tariffs in which you want to force export late. switch.predbat_calculate_import_low_export ( expert_mode ) When turned On (the default), import slots of the same value are sorted by export price. When turned Off they are sorted just by price and then time. By default with this option turned On, if there are multiple charge slots of the same price Predbat will try to charge when the export rates are the lowest thus leaving the higher export slots available. switch.predbat_calculate_export_high_import ( expert_mode ) When turned On (the default) export slots of the same value are sorted by import price (to avoid exporting in the low price import slots). When Off export slots are sorted just by decreasing export price and then time (so high value exports are planned first). By default with this option On the latest export slots of the same value will be picked, this is useful for fixed-price export tariffs where you want to export as late in the day as you can, thus preserving the battery for as long as possible.","title":"Calculation options"},{"location":"customisation/#battery-margins-and-metrics-options","text":"input_number.predbat_best_soc_keep is the minimum battery level in kWh that Predbat will to try to keep the battery above for the Predbat plan. This is a soft constraint only that's used for longer-term planning and is ignored for the forthcoming first 4 hours of the plan. As this is not used for short-term planning your SoC can drop below this - use input_number.predbat_best_soc_min if you want to force all charges to be above a set level. It's usually good to have best_soc_keep set to 0kWh to use your entire battery, values above zero will end up costing more money but will ensure you have some spare battery kept back for emergency use. input_number.predbat_best_soc_keep_weight ( expert_mode ) Is used to tune how strongly you want the keep metric to apply. A value of 0 would essentially ignore keep while higher values will make it more important to always stay above your keep threshold even if it costs more money to do so. The default is 0.5 - this is the recommended setting. input_number.predbat_best_soc_min ( expert mode ) (default 0kWh) sets the minimum charge level (in kWh) for charging during each slot and the minimum force export level also (set to 0 if you want to skip some slots). If you set this to a non-zero value you will need to use the low rate threshold to control which slots you charge from or you may charge all the time. input_number.predbat_best_soc_max ( expert mode ) sets the maximum charge level (in kWh) for charging during each slot. A value of 0kWh (the default) disables this feature. input_number.combine_rate_threshold ( expert mode ) sets a threshold (in pence) to combine charge or export slots into a single larger average rate slot. The default is 0p which disables this feature and all rate changes result in a new slot. switch.predbat_combine_charge_slots Controls if charge slots of > the slot duration (default 30 minutes) can be combined. When turned Off (the default) they will be split up, increasing run times but potentially more accurate for planning. Turn this On combines charge slots together into a single block, useful to dissuade Predbat from repeatedly charging and discharging the battery to maximise income when the export rate is higher than the import rate, e.g. EV tariffs with a long overnight cheap rate. Turn this Off if you want to enable ad-hoc import during long periods of higher rates but you wouldn't charge normally in that period (e.g. pre-charge at the day rate before a saving session). switch.predbat_combine_export_slots ( expert mode ) Controls if export slots of > the slot duration (default 30 minute) can be combined. When turned Off (the default) they will be split up, increasing run times but potentially more accurate for planning. input_number.predbat_metric_min_improvement ( expert mode ) sets the minimum cost improvement in pence that it's worth lowering the battery SoC % for. The default value is 0.0p which means this feature is disabled and the battery will be charged less if it's cost neutral. If you use input_number.predbat_pv_metric10_weight then you probably don't need to use this as the 10% forecast does the same thing better Do not use it if you have multiple charge windows in a given period as it won't lead to good results (e.g. Agile) You could even go to something like -0.1 to say you would charge less even if it cost up to 0.1p more (best used with metric10). input_number.predbat_metric_min_improvement_export ( expert mode ) Sets the minimum pence cost improvement it's worth doing a forced export for. A value of 0.1p is the default which prevents any marginal exports as they must be worth at least 0.1 pence for a slot (less for shorter slots). If you increase this value (e.g. you only want to force export if very profitable), then exports will become less common. The value is in pence per slot of export time. input_number.predbat_metric_min_improvement_export_freeze ( expert mode ) Sets the minimum pence cost improvement it's worth doing an export freeze for. A value of 0.1p is the default which prevents any marginal freezes as they must be worth at least 0.1 pence for a slot duration (less for shorter slots). If you increase this value (e.g. you only want to freeze export if very profitable), then freeze exports will become less common. The value is in pence per slot of export time. input_number.predbat_metric_min_improvement_swap ( expert mode ) Sets the minimum improvement in cost to swap an export slot to a later time in the day. The default for this setting is -0.25p, meaning that export will be moved later even if it costs up to an extra 0.25p on the plan. The advantage of having late exports means that you are less likely to run out of battery earlier in the day. Values of between -1p and 0p would be recommended. input_number.predbat_rate_low_threshold ( expert mode ) When set to 0 (the default) Predbat will automatically look at the future import rates in the plan and determine the import rate threshold below which a slot will be considered to be a potential charging slot. If rate_low_threshold is set to a non-zero value this will set the threshold below future average import rates as the minimum to consider for a charge window, e.g. setting to 0.8 = 80% of the average rate. If you set this too low you might not get enough charge slots. If it's too high you might get too many in the 24-hour period which makes optimisation harder. input_number.predbat_rate_high_threshold ( expert mode ) When set to 0 (the default) Predbat will automatically look at the future export rates in the plan and determine the threshold above which a slot can be considered a potential exporting slot. If rate_high_threshold is set to a non-zero value this will set the threshold above future average export rates as the minimum export rate to consider exporting for, e.g. setting to 1.2 = 20% above average rate. If you set this too high you might not get any export slots. If it's too low you might get too many in the 24-hour period. input_number.predbat_metric_future_rate_offset_import ( expert mode ) Default 0p/kWh. Sets a pence per kWh offset to apply to future import energy rates that are not yet published, best used for variable rate tariffs such as Agile import where the rates are not published until 4pm. If you set this to a positive value then Predbat will assume unpublished import rates are higher by the given amount. Setting this to 1 to 1.5p for example results in Predbat being a little more aggressive in the charging calculation for today - Predbat will charge the battery to a higher percentage than it would otherwise as it expects a cost-benefit of using today's lower rates. NB: this can lead to higher costs and to some export if solar generation is better than forecast. input_number.predbat_metric_future_rate_offset_export ( expert mode ) Default 0p/kWh. Sets an offset to apply to future export energy rates that are not yet published, best used for variable rate tariffs such as Agile export where the rates are not published until 4pm. If you set this to a negative value then Predbat will assume unpublished export rates are lower by the given amount. switch.predbat_calculate_inday_adjustment Set to On by default. When turned on, will calculate the difference between today's actual load and today's predicated load and adjust the rest of the day's usage prediction accordingly. A scale factor can be set with input_number.predbat_metric_inday_adjust_damping ( expert mode ) (default 0.95) to either scale up or down the impact of the in-day adjustment (lower numbers scale down its impact). The in-day adjustment factor can be seen in predbat.load_inday_adjustment and charted with the In-Day Adjustment chart . input_number.predbat_carbon_metric ( carbon enable ) When Carbon footprint tracking is turned On ( switch.predbat_carbon_enable ) (Off by default), you can specify a cost per kg of CO2 used to weight the selection of plans. Values of around 10-200 will give varying outcomes to trade off cost vs carbon footprint of your system. Note: Carbon footprint tracking can only be turned on if apps.yaml is configured to point to the correct CO2 cost sensor","title":"Battery margins and metrics options"},{"location":"customisation/#notifications","text":"Predbat can send mobile notifications for various events. You can control which types of notifications are sent using the following switches. Set the list of devices to notify in apps.yaml . Switch Default Controls switch.predbat_set_status_notify On Notifications when Predbat operational status changes (e.g. Idle, Charging, Exporting) switch.predbat_set_inverter_notify Off Notifications when inverter settings are changed (e.g. charge/discharge rates, reserve levels, time windows) switch.predbat_set_event_notify On Notifications for energy market events (e.g. Octopus Saving Sessions joined, Axle VPP events scheduled) switch.predbat_set_system_notify On Notifications for system events (e.g. auto-restart service, software updates, settings save/restore)","title":"Notifications"},{"location":"customisation/#inverter-control-options","text":"switch.predbat_set_charge_low_power Enables low-power charging mode where the max charge rate will be automatically determined by Predbat to be the lowest possible rate to meet the charge target. This is only really effective for charge windows longer than a single slot. If this setting is turned on, it is strongly recommended that you create a battery_power_charge_curve in apps.yaml as otherwise the low power charge may not reach the charge target in time. This setting is off by default. The YouTube video low power charging and charging curve explains how the low-power charging works and shows how Predbat automatically creates it. input_number.predbat_charge_low_power_margin (requires switch.predbat_set_charge_low_power to be turned On) Controls how many minutes before the completion time to target finishing charging, this defaults to 10 but can be changed between 0 and 30. switch.predbat_set_reserve_enable ( expert_mode ) When turned On (the default) the battery reserve setting is used to hold the battery charge level once it has been reached or to protect against discharging beyond the set limit. switch.predbat_set_charge_freeze ( expert mode ) When turned On will allow Predbat to hold the current battery level while drawing from the grid/solar as an alternative to charging. On by default. switch.predbat_set_export_freeze When turned On (the default) will allow Predbat to export Solar to the grid rather than charging the battery. switch.predbat_set_export_freeze_only ( expert mode ) When turned On forced export is prevented, but export freeze can be used (if enabled) to export excess solar rather than charging the battery. This is useful with tariffs that pay you for solar exports but don't allow forced export (brown energy). Off by default. If you have switch.predbat_inverter_hybrid set to Off then if switch.predbat_inverter_soc_reset ( expert mode ) is set to On then the target SoC % will be reset to 100% outside of a charge window. This may be required for the AIO inverter to ensure it charges from solar. The default for this switch is On but it can be disabled in expert mode if need be. input_number.predbat_set_reserve_min Defines the battery reserve percentage for inverter 1, i.e. the minimum charge level that should be retained in the battery, a value of 4 is the default and minimum value and is recommended to make use of the full battery. When the battery level reaches the specified minimum level, your inverter will start importing from the grid to satisfy house load. If you want to pre-prepare the battery to retain extra charge in the event of a high likelihood of a grid power outage such as storms predicted, you can increase set_reserve_min to a higher value, and then change it back afterwards. (Obviously this is only any use if your inverter is wired to act as an Emergency Power Supply or whole-home backup 'island mode' on the GivEnergy AIO). input_number.predbat_set_reserve_min_1 defines the same minimum battery reserve percentage for inverter 2. Likewise predbat_set_reserve_min_2 and set_reserve_min_3 are the reserve minimums for inverter 3 and 4. Note that the input_number.predbat_set_reserve_min 's are used by Predbat to stop the battery SoC dropping below the specified level but are not used in planning battery charging. i.e. if you change a reserve min to a level higher than the current battery SoC then Predbat will not plan charging activity to increase the SoC to that level; you should set manual charges to increase the SoC level. switch.predbat_inverter_soc_reset ( expert mode ) When set to On (the default) the target SoC for the inverter(s) will be reset to 100% when a charge slot is not active, this can be used to workaround some firmware issues where the SoC target is used for solar charging as well as grid charging. When disabled the SoC target % will not be changed after a charge slot. input_number.inverter_limit_override When non-zero sets the maximum rate (in Watts) to set the battery charge or discharge rate to when in operation. Useful to workaround bad installs that trip the fuse/breaker when operating at full power. A value of 0 applies no limit.","title":"Inverter control options"},{"location":"customisation/#balance-inverters","text":"When you have two or more inverters it's possible they get out of sync so they are at different charge levels or they start to cross-charge (one discharges into another). When enabled, balance inverters try to recover this situation by disabling either charging or discharging from one of the batteries until they re-align. If you do use Predbat's balance inverter function then be aware that Predbat will start repeatedly and rapidly updating your inverter settings to keep the inverters in balance with each other. This can be a problem with inverters that have a limited life-span flash memory . If available, you are strongly recommended to turn on \"real time registers\" using switch.givtcp_xxxx_real_time_control for GivEnergy inverters controlled via GivTCP, or an equivalent function for your inverter. The apps.yaml contains a setting balance_inverters_seconds which defines how often to run the balancing, 30 seconds is recommended if your machine is fast enough, but the default is 60 seconds. Turn On switch.predbat_balance_inverters_enable to enable this feature. It is Off by default. When turned on a number of other balance controls and configurations are made available: switch.predbat_balance_inverters_charge - Is used to toggle on/off balancing while the batteries are charging switch.predbat_balance_inverters_discharge - Is used to toggle on/off balancing while the batteries are discharging switch.predbat_balance_inverters_crosscharge - Is used to toggle on/off balancing when the batteries are cross charging input_number.predbat_balance_inverters_threshold_charge - Sets the minimum percentage divergence of SoC during charge before balancing, default is 1% input_number.predbat_balance_inverters_threshold_discharge - Sets the minimum percentage divergence of SoC during discharge before balancing, default is 1%","title":"Balance Inverters"},{"location":"customisation/#freeze-export-during-demand","text":"An alternative to Predbat's full inverter balancing option if you have multiple inverters that can cross charge when the inverter is in Eco/Demand mode, is switch.predbat_set_freeze_export_during_demand ( expert mode ). Typically overnight when there is no solar generation and inverters are just meeting house load (Demand mode), multi-inverter setups will start cross charging from one inverter battery to another. If you turn On switch.predbat_set_freeze_export_during_demand then when Predbat is not charging or discharging, i.e. would be in Demand mode, then Predbat will override the normal Demand mode and set the inverters to Freeze Export mode which allows battery discharge, but not battery charging; thus preventing inverter cross-charging. It is recommended that you control switch.predbat_set_freeze_export_during_demand via an automation, such as turning it Off at sunrise and On at sunset so that the batteries can charge normally via solar generation. NB: Setting this switch to On has no affect on Predbat's planned Charging and Export activity, those will be executed normally, the switch only affects Demand mode. When the Freeze Export override is active, Predbat status will have '[Freeze exporting]' appended to the status.","title":"Freeze Export during Demand"},{"location":"customisation/#cloud-coverage-and-load-variance","text":"By default Predbat tries to model passing clouds by modulating the PV forecast data on a 5-minute interval up and down while retaining the same predicted total. The amount of modulation depends on the difference between the PV50% (default) and PV10% scenario produced by Solcast. You can disable this feature ( expert mode only ) using switch.predbat_metric_cloud_enable . By default Predbat tries to model changes in your household load by modulating the historical data on a 5-minute interval up and down while retaining the same predicted total. The amount of modulation depends on the standard deviation of your load predictions over the coming period (currently 4 hours). You can disable this feature ( expert mode only ) using switch.metric_load_divergence_enable .","title":"Cloud coverage and load variance"},{"location":"customisation/#iboost-model-options","text":"Predbat has an 'iBoost model' that can be used to model using excess solar energy to heat hot water (or similar) instead of it being exported to the grid. This model can be used to control any solar diverter device, for example, an iBoost (e.g. using a Fingerbot or similar device to physically press the 'boost' button on the iBoost), a MyEnergy Eddi (using the MyEnergy integration), or it can be used with a high-power smart switch to turn on the hot water cylinder immersion heater when there is excess solar. So although Predbat refers to controlling an iBoost, you are not limited to just an iBoost device when using this model within Predbat. To turn the model on, switch.predbat_iboost_enable needs to be turned On (default is Off). The predicted output from the iBoost solar diverter model is returned in predbat.iboost_best and is populated in the 'iBoost' column of the Predbat plan .","title":"iBoost model options"},{"location":"customisation/#iboost-basic-configuration","text":"When you turn on predbat_iBoost_enable the following additional Home Assistant entities are created by Predbat: input_number.predbat_iboost_max_energy Sets the maximum energy in kWh that the solar diverter can consume during a day before turning off - default 3kWh. input_number.predbat_iboost_max_power Sets the maximum power in watts that the solar diverter will consume - default 2400. input_number.predbat_iboost_min_power Sets the minimum power in watts that the solar diverter will consume - default 500. input_number.predbat_iboost_value_scaling Sets how to account for the value of iBoost units of energy. The default value of 0.75 means that each kWh of energy diverted is accounted for as 0.75 times The lowest future import rate. Higher values will generate plans with more solar diversion while lower values will generate less. A value of 0 means all diverted energy should be ignored in planning (assumed to be zero value). switch.predbat_iboost_energy_subtract When turned On (the default) energy reported by the iboost_energy_today sensor configured in apps.yaml will be subtracted from your historical load data to improve the accuracy of predictions. If you are using PredAI you will also need to subtract this data inside PredAI configuration. Different boost modes can be selected:","title":"iBoost basic configuration"},{"location":"customisation/#iboost-modes","text":"","title":"iBoost modes"},{"location":"customisation/#solar","text":"switch.predbat_iboost_solar When turned On, Predbat assumes the diverter will use solar power to boost the hot water heating. switch.predbat_iboost_solar_excess When turned Off (the default) will allow any solar power to be diverted while if enabled only excess power (power that would otherwise be exported) will be used. By default iboost will not run the battery is in force export mode unless you turn on switch.predbat_iboost_on_export . input_number.predbat_iboost_min_soc sets the minimum home battery SoC percentage that must be in the battery before the solar diverter is turned on. The default is 0 meaning hot water heating can occur regardless of what SoC level the battery is at.","title":"Solar"},{"location":"customisation/#battery","text":"switch.predbat_iboost_charging If set to On, the diverter will operate when the battery is charging (can be combined with solar)","title":"Battery"},{"location":"customisation/#energy-rates-only","text":"If both of the above are Off, but iBoost is turned On then boost will happen solely based on energy rates (see below). switch.predbat_iboost_smart Will pick the lowest import rate slots within 24 hours to achieve the desired energy as specified by input_number.predbat_iboost_max_energy . Only slots at or below the rate threshold will be selected. Note this option only applies when iboost_solar and iboost battery are both Off. input_number.predbat_iboost_smart_min_length Sets the minimum slot length in minutes to iBoost (only applies for energy rate only modes). The default is 30 minutes but can be set in multiples of the slot duration (default 30 minutes). Increasing this slot size could increase costs depending on your tariff. switch.predbat_iboost_on_export If set to On allows iBoost to run even if the battery is forced to export to the grid, otherwise it won't run in these circumstances. switch.predbat_iboost_prevent_discharge When set to On will stop your battery from discharging when iBoost is active and thus prevent your battery from draining to the diverter. This switch will work in all modes and is not recommended to be used when iBoost Solar is On as it will prevent your battery from discharging during excess solar periods which could cause additional imports due to passing clouds.","title":"Energy rates only"},{"location":"customisation/#iboost-energy-rate-filtering","text":"input_number.predbat_iboost_rate_threshold Sets the maximum import rate (in pence) that the diverter will trigger on, defaults to 100. input_number.predbat_iboost_rate_threshold_export Sets the maximum export rate (in pence) that the diverter will trigger on, defaults to 100. switch.predbat_iboost_gas When turned On will control the diverter to only operate when import electric rates are lower than gas rates. switch.predbat_iboost_gas_export When turned On will control the diverter to only operate when export electric rates are lower than gas rates. These can be useful if you have the choice to heat your hot water by immersion heater or by gas boiler. Note: Gas rates have to be configured in apps.yaml using metric_octopus_gas or rates_gas depending upon whether you are using the Octopus Integration or not. input_number.predbat_iboost_gas_scale Sets the scaling of the gas rates (set in apps.yaml )used before comparing with electric rates, to account for gas boiler losses and efficiency. It should be set to the reciprocal of the boiler efficiency, i.e. for an 80% efficient gas boiler, set to 1.25.","title":"iBoost energy rate filtering"},{"location":"customisation/#iboost-control","text":"","title":"iBoost control"},{"location":"customisation/#iboost-output-data","text":"You will see input_number.predbat_iboost_today entity which tracks the estimated kWh consumed by the solar diverter during the day, and resets at midnight every night. The binary_sensor.predbat_iboost_active entity will be turned On when the solar diverter should be active and can be used for automations to trigger the immersion heater boost. The attributes within this sensor include 'solar' which includes Solar diversion should be active and 'full' which indicates iBoost should run at maximum rate (could be during a charge cycle or grid import). Example template automation for controlling the solar diverter: alias: Solar Diverter description: \"Start/stop solar diverter based on Predbat-determined slots\" trigger: - platform: state entity_id: - binary_sensor.predbat_iboost_active action: - choose: - conditions: - condition: state entity_id: binary_sensor.predbat_iboost_active state: \"True\" sequence: <commands to turn on your solar diverter> - conditions: - condition: state entity_id: binary_sensor.predbat_iboost_active state: \"False\" sequence: <commands to turn off your solar diverter> mode: single If you have an incrementing sensor that tracks the solar diverter energy usage then to make your predictions more accurate you should set the iboost_energy_today sensor in apps.yaml to point to it, and optionally set iboost_energy_scaling if the sensor isn't in kWh (e.g. set to 0.001 if the sensor is in Watts). The sensor should be an incrementing sensor which can reset at midnight or not.","title":"iBoost output data"},{"location":"customisation/#holiday-mode","text":"When you go away you are likely to use less electricity and so the previous load data will be quite pessimistic. Using the Home Assistant entity input_number.predbat_holiday_days_left you can set the number of full days that you will be away (including today). The number will count down by 1 day at midnight until it gets back to zero. Whilst the holiday days left are non-zero, Predbat's 'holiday mode' is active. When Predbat is in 'Demand' mode (i.e. not actively charging or discharging) and 'holiday mode' is active, Predbat's status will show as 'Demand (Holiday)'. When Predbat's 'holiday mode' is active the historical load data will be taken from yesterday's data (1 day ago) rather than from the days_previous setting in apps.yaml . This means Predbat will adjust more quickly to the new usage pattern. If you have been away for a longer period (more than your normal days_previous setting) then obviously it's going to take longer for the historical data to catch up, you could then enable holiday mode for another 7 days after your return. In summary: For short holidays set holiday_days_left to the number of full days you are away, including today but excluding the return day For longer holidays set holiday_days_left to the number of days you are away plus another 7 days until the data catches back up","title":"Holiday mode"},{"location":"customisation/#manual-control","text":"In some cases, you may want to override Predbat's planned behaviour and make a decision yourself. One way to achieve this is to put Predbat into read-only mode using switch.predbat_set_read_only . When going to read-only mode the inverter will be put back to the default settings and you can then control it yourself using your inverter controls directly. A better alternative in some cases is to tell Predbat what you want it to do in a particular time slot using the Manual Control feature. Note that none of the manual control commands override the Predbat mode you have selected. So if for example you want to force Predbat to charge then you need to be in either 'Control charge' or 'Control charge & discharge' mode, and if you want to force Predbat to export then you need to be in 'Control charge & discharge mode'. You can force the battery to be charged within a single slot by using the select.predbat_manual_charge selector. Pick the day and time slot you wish to charge in (up to 48 hours in advance), and Predbat will change the plan to charge in the selected slot. You can select multiple slots by using the drop-down menu more than once. Selected slots will be shown in the list in square brackets, and you can cancel a Manual Control slot by selecting the slot time again. When you use the Manual Control features you can select the day and time from the next 48 hours, the overrides will be removed once their time slot expires (they do not repeat). The off option at the bottom of the list will cancel all selected force charges. When Predbat updates the plan you will see the slots that have been manually picked to be charging slots annotated in the Predbat HTML plan with an upside down 'F' symbol. If you use the selector from an automation you can combine multiple time slots together, with times in the format HH:MM. Entering the slot day is optional from an automation, and if you do not enter a day then the next slot with the matching time will be chosen. For example, the following automation action will set Predbat to charge in the next 22:00, 22:30 and 23:00 slots: action: select.select_option target: entity_id: - select.predbat_manual_charge data: option: >- 22:00,22:30,23:00 All the other select.predbat_manual_XX controls operate in a similar way. NOTE : once you select a day/time slot from any of the select.predbat_manual_XX selectors the selected time slot is immediately marked on the drop-down and you can then make another change. Predbat still has to update the plan which it will be doing so in the background, and this can take a few minutes to run (depending on the speed and power of the device you are running Home Assistant on), so don't be surprised why the Predbat plan doesn't change immediately - remember you can see the date/time the plan was last updated on the first row of the plan. As an alternative to selecting day/time slots from the select.predbat_manual_xx drop down lists, you can select a time slot then select the mode you want Predbat to be in from the Predbat plan shown in the Web Console . This might be easier to use than the selector controls. CAUTION: If you leave Predbat turned off for a long period of time then the override timeslots could end up repeating when you restart The select.predbat_manual_export selector can be used to manually force Predbat to export within a slot. If you set a force export then this takes priority over force charging. The select.predbat_manual_demand selector is used to force Predbat to demand mode for a slot, this implies no forced grid charging or exporting of the battery. House load will be supplied from solar, or the battery if there is insufficient solar, or grid import if there is insufficient battery charge. This is described as 'Eco' Mode for GivEnergy inverters but other inverters use different terminology. The select.predbat_manual_freeze_charge selector is used to force Predbat to freeze charge during a slot, this implies the battery will not discharge and will hold at the current level. The grid may be used if solar is not enough to cover the load. The select.predbat_manual_freeze_export selector is used to force Predbat to freeze export during a slot, this implies the battery will not charge but will still discharge for the house load. Any solar will be exported to the grid. The select.predbat_manual_import_rates selector is used to override the import rates for a slot, the rate selected will be that configured in input_number.predbat_manual_import_value (default 0p) which can be adjusted prior to making a selection. As with the other selectors the selection can be cleared by selecting the option in square brackets or by using off If this selector is used in an automation you can set the time and rate together by making a selection in the format HH:MM=rate e.g. 12:30=29.5 The select.predbat_manual_export_rates selector is used to override the export rates for a slot, the rate selected will be that configured in input_number.predbat_manual_export_value (default 0p) which can be adjusted prior to making a selection. Similar to manual_import_rates, if this selector is used in an automation you can set the time and rate together by making a selection in the format HH:MM=rate e.g. 12:30=29.5 The select.predbat_manual_load_adjust selector is used to make adjustments to the predicted load in kWh for a slot, the load adjustment amount will be that configured in input_number.predbat_manual_load_value (default 0.5kWh) which can be adjusted prior to making a selection. Predbat will add the adjustment amount to the kWh predicted load for those slots. If this selector is used in an automation you can set the time and kWh load adjustment amount together by making a selection in the format HH:MM=adjustment e.g. 12:30=0.5 The select.predbat_manual_soc selector is used to set a target State of Charge (SoC) percentage for a specific time. This is useful when you know you need a certain battery level at a particular time, for example before peak rates start or when you expect higher than normal consumption. The SoC target percentage will be that configured in input_number.predbat_manual_soc_value (default 100%) which can be adjusted prior to making a selection. For example, if you want the battery to be at 100% by 05:30, select that time slot. Predbat will plan charging to ensure the battery reaches the target SoC by that time. Note that the manual SoC target is a minimum SoC level for that time slot. If based upon your predicted load, solar generation and energy costs Predbat determines that your battery needs to be charged to a higher SoC level to minimise your costs, Predbat will charge to that required level. If this selector is used in an automation you can set the time and SoC together by making a selection in the format HH:MM=percentage e.g. 05:30=100 The manual SoC target works in conjunction with the weather alert system - if both are active at the same time, the higher SoC target will be used.","title":"Manual Control"},{"location":"customisation/#manual-api","text":"select.predbat_manual_api enables you to overwrite configuration entries normally set in apps.yaml , e.g. from an automation. This is described in detail in Manual API and is mentioned here just for completeness.","title":"Manual API"},{"location":"customisation/#debug","text":"switch.predbat_debug_enable When turned On will create lots of debugging information to aid diagnosis of Predbat issues. By default this is turned Off and its recommended that its only switched on when debug logs are requested. With the switch on: Firstly Predbat prints lots of extra debug information in the Predbat logfile which means the logfile will fill and swap to a new file more rapidly Secondly Predbat will create a debug output file 'debug/predbat_debug_HH_MM_SS.yaml' in a subfolder of the Predbat installation directory. This file contains a full export of your current Predbat config and is extremely useful to enable recreating your setup to diagnose issues. Any sensitive information such as Solcast or GivEnergy Cloud API keys are automatically removed. The following automation might be useful to automatically turn off Predbat debug mode after turning it on to capture the debug logs: alias: \"Predbat: Auto turn-off debug mode\" description: \"\" triggers: - trigger: state entity_id: - switch.predbat_debug_enable to: \"on\" for: minutes: 10 conditions: [] actions: - action: script.notify_all_devices metadata: {} data: title: \"INFO: Turned off Predbat debug after 10 minutes\" critical: \"N\" url: \"\" message: switch.predbat_debug_enable turned off - action: switch.turn_off target: entity_id: switch.predbat_debug_enable data: {} mode: single switch.predbat_plan_debug ( expert mode ) when turned On adds some extra debug to the Predbat HTML plan - see Predbat Plan debug mode for more details. Off by default.","title":"Debug"},{"location":"customisation/#updating-predbat","text":"You can either manually update Predbat to a new (or old) version or set Predbat to automatically update itself. These are described in detail in Updating Predbat and are listed here just for completeness: select.predbat_update - List of Predbat software versions you can select to update Predbat to switch.predbat_auto_update - When On, Predbat will automatically update itself as new releases are published on GitHub.","title":"Updating Predbat"},{"location":"developing/","text":"Developing on Predbat Creating a fork Using GitHub, take a fork of Predbat - effectively, this creates a copy of the main repository, but in your personal space. There, you can create branches to develop on. Pull requests Once you've completed your work on your branch, you can create a pull request (PR) to merge your work back into the main branch of Predbat. This PR should describe the work you've done in a way that makes it easy for someone to review your work, and either add comments or approve it. Unit level testing Predbat now has some unit-level tests, to run them on your local machine: Create a test directory somewhere Copy apps.yaml to your test area Copy the files from github https://github.com/springfall2008/batpred/tree/main/coverage to this area Extract cases.tgz Have /Volumes/add_configs/6adb4f0d_predbat point to your Predbat app directory or edit run_all to change the path Run run_all You can add --quick to run just the faster tests. If the tests fail then debug them. For coverage analysis installed the 'coverage' library with Python ./run_cov --quick Open htmlcov/index.html in your web browser Editing the code There are at least a couple of ways of working on the code, outlined here. Using GitHub Codespaces What is GitHub Codespaces? Especially if you don't need to have a running Home Assistant system to make the changes you're interested in (e.g. for documentation, quick fixes etc.) a really easy way to work on the code is by using GitHub Codespaces. GitHub Codespaces gives you a full-featured development environment. This includes: A full IDE (a code editor), Visual Studio Code, which can be: Run in the browser, requiring no additional software to be installed Run in a virtual machine (VM) running in the cloud which can connect to a copy of VS Code installed on your own machine A terminal where you can run commands against your codebase e.g. running pre-commit to run the automatic code quality checks, linting files, etc. Software like mkdocs to re-generate the documentation files (and other software we may include) pre-installed in it The Codespaces environment is entirely separate from your HA installation, so does not require any modification to your HA setup to work with it. However, you are modifying code in an environment where you can't see HA running, so it's great for things like updating documentation, or writing automated tests, but not if you need to see your changes live within HA. Running GitHub Codespaces You may wish to first install VS Code on your machine, which does offer some benefits compared to running Codespaces in the cloud, but this is certainly not essential, and you'll see the same code editor and terminal, and you'll have the same commands and Python packages available in the terminal. The local installation is better in a small number of scenarios e.g. if you need to connect from your browser to a specific port on the VM, such as if you're working on the documentation. Importantly, even if you do a local install of VS Code and use that to edit your code within GitHub, the terminal, the code you're editing any commands that you run, and any processes like mkdocs that you may browse to are all running in the Codespaces VM. Your local VS Code is connected to the VM through SSH. It will appear as if the code, the terminal etc. are local, but they are not. Running a local VS Code install connected to Codespaces will not install Python, Python packages or anything else on your local machine. Now, from your fork or branch, click on the Code button, and select the Codespaces tab. You can create multiple environments, or use a single environment and swap between branches in it. Once you start your Codespaces environment, it will take a minute to create a VM for you, and to install the software we've asked it to install in there. It will also clone your repository and branch into it for you, and the VM will be authenticated with GitHub so you can commit and push straight back to your fork of Predbat on GitHub. You can choose between running the IDE in the browser or having your local installation of VS Code connects to the environment that GitHub Codespaces has created for you. The Codespaces will be already set up with Python, along with various Python packages (as defined in requirements.txt ). The environment is configured through the config in .devcontainer/devcontainer.json . Developing locally within Home Assistant To be documented later. Working on the documentation Overview of the Predbat documentation The documentation site at https://springfall2008.github.io/batpred/ is built from Markdown files in this repo. The Markdown files used to build the documentation are in the docs/ folder, with additional config for building the documentation site in mkdocs.yml . If you're making minor changes to the documentation e.g. fixing a spelling, you can just edit the Markdown files directly, and it will be pushed to the main documentation site as outlined in the documentation build process section below, once your changes are merged into main and released. However, if you're doing more than that, e.g. adding new sections, working with lists etc. we recommend you follow the instructions in working locally on the documentation below, as this will give you a live preview of what the documentation will look like once it's built and published. This will avoid any unexpected results appearing in the main documentation site. If you are adding a new file, please ensure you add that file to mkdocs.yml , so it will be linked from the menu in the sidebar. The documentation build process The documentation for the site is built using mkdocs , which will already be installed if you're using a GitHub Codespaces environment. For a detailed explanation of mkdocs features, please read the mkdocs documentation . As briefly covered above, mkdocs.yml contains the config for defining the documentation site, and the documentation is built by mkdocs reading the Markdown files in the docs/ folder, and creating HTML files from those files. mkdocs can be used locally for previewing, but is also used as part of the documentation build process that publishes the official documentation site. The publishing of the documentation is triggered by a GitHub action, as defined in .github/workflows/main.yml . In short, after configuring the build environment, mkdocs builds the site then pushes the HTML produced to the gh-pages branch, overwriting whatever was there previously. GitHub will then detect a new commit on the gh-pages branch, and that will trigger another action to run (as defined by GitHub). This action will take the HTML files on the gh-pages branch and will make them available at https://springfall2008.github.io/batpred/ . The documentation will be published as it is, with no further review process, so please ensure you check the documentation that will be built before merging it in. Working locally on the documentation If you are making changes to the documentation, you can see a live preview version of the documentation as it will be built and deployed. This preview version is local to your environment, is temporary, and does not impact the published version in any way. It's recommended for anything other than simple changes like fixing spelling, or adding a sentence or two. Things like new sections, lists, new pages etc. are best previewed due to the complications of various Markdown standards, as what works on GitHub READMEs, for example, does not necessarily work with the published documentation site (which follows a more strict Markdown standard). There are a number of terminal commands that you can use in the Codespaces environment. Open a terminal window in Codespaces by choosing Menu> Terminal > New Terminal. To run the live preview, enter mkdocs serve in the terminal window - this will cause mkdocs to build a local temporary version of the documentation site, and to temporarily publish it on port 8000 - it will show the link where you can access the documentation. Also, it will watch the docs/ folder, and any time you change the files, it will rebuild the site, allowing you to see changes to the Markdown files in your browser within a few seconds. The site will continue being served until you press CTRL-C to end the mkdocs serve command. Note, accessing the site published by mkdocs serve is not possible if you are using Codespaces to run VS Code in the browser, but it is possible if you're using it via VS Code running locally, due to how ports on your environment are shared. Coding standards Expected standards This section will be enhanced following discussions as we go. However, here's a starting point: Variable names should be lower_case_with_underscores - this fits with most existing variables, is a common standard for Python code, and also allows the spell checking to check individual words within the variable name. Enforced standards Certain coding standards are enforced within the repository. Some of them can be auto-fixed if you do a commit that fails one of those standards; other issues will need fixing first, as your pull request won't merge in GitHub until it passes. These standards are enforced by pre-commit , a tool which can run other tools to check, and potentially fix (for certain types of issues) any mistakes you've made. The .pre-commit-config.yaml file lists all checks that are currently carried out within the repository. Bear in mind that these checks are done according to the config within that file in the branch that you are working in, so if someone adds a new check, or changes some of the related settings, it won't apply on your branch until you've merged in their changes. Some of the tools have their own related config files: CSpell - .cspell.json and .cspell/custom-dictionary-workspace.txt Black - pyproject.toml Markdown Lint - .markdownlint.jsonc Additional notes on some of the standards: CSpell - if you have the spelling check failing due to a valid word which is not in the in-built dictionary, please add that word to the end of .cspell/custom-dictionary-workspace.txt and stage those changes. The spell-check should then pass. Note, that the dictionary file will get re-sorted alphabetically when you run pre-commit , so you'll need to re-stage the file after it's been sorted. Running the checks locally If you are using a Codespaces environment, you'll already have pre-commit installed automatically. You can run it manually, or automatically. Running pre-commit manually: In a terminal window, running pre-commit will run all the checks against any files that you have modified and staged. Alternatively, running pre-commit run --all-files will run all the checks against all files within the repository. Note that if pre-commit makes any changes to any files when it runs, those changes will not be staged. You will need to stage those changes too before committing. You may notice pre-commit mentioning about stashing changes - this is because when it runs, any changes that aren't staged are stashed (saved away temporarily) so it runs against only the staged changes; after it has run, it pulls back those stashed changes, so they appear again (still unstaged). Running pre-commit automatically: If you run pre-commit install in a terminal window it will install a pre-commit hook - this is a file which tells git to run some code for each type you do a particular action (a pre-commit hook runs at the start of processing a commit, but there are other hooks e.g. pre-push). Now, any time you perform a commit, pre-commit will run automatically on the staged files - this is a handy way of making sure that you don't accidentally commit code which will fail checks later. You can still run it manually as outlined above, in addition to the automated checks that it will do on commits. Running the checks from within GitHub When commits are done on pull requests, and in any other scenarios added to the on section of .github/workflows/linting.yml , the GitHub Actions in that file will run. In particular, the pre-commit.ci lite action will run. This uses the pre-commit code to run the same checks that get run locally (as described in the .pre-commit-config.yaml file). This will cause your commit, branch or pull request to get either a green tick or a red cross against it, to show whether the code passed the checks or not. This will happen automatically when you push code on a branch that has a pull request. In addition, if pre-commit finds any errors it can fix (e.g. a missing blank line at the end of a file, or trailing whitespace), it will make a commit of its own to fix those problems and will push that commit back to your branch on GitHub. This will then trigger another run, which should now pass. Note : This means that pre-commit will be adding commits to your branch - this will need you to be pulling changes from GitHub so you pick up the changes that have been added by pre-commit otherwise, you will hit a problem when you next try to push a commit on your branch. You can pull in those changes by running git pull , which is the equivalent of running git fetch and then git merge . This is no different to working on the same branch with another developer, but it will be different to the workflow most of us have when working on Predbat.","title":"Developing on Predbat"},{"location":"developing/#developing-on-predbat","text":"","title":"Developing on Predbat"},{"location":"developing/#creating-a-fork","text":"Using GitHub, take a fork of Predbat - effectively, this creates a copy of the main repository, but in your personal space. There, you can create branches to develop on.","title":"Creating a fork"},{"location":"developing/#pull-requests","text":"Once you've completed your work on your branch, you can create a pull request (PR) to merge your work back into the main branch of Predbat. This PR should describe the work you've done in a way that makes it easy for someone to review your work, and either add comments or approve it.","title":"Pull requests"},{"location":"developing/#unit-level-testing","text":"Predbat now has some unit-level tests, to run them on your local machine: Create a test directory somewhere Copy apps.yaml to your test area Copy the files from github https://github.com/springfall2008/batpred/tree/main/coverage to this area Extract cases.tgz Have /Volumes/add_configs/6adb4f0d_predbat point to your Predbat app directory or edit run_all to change the path Run run_all You can add --quick to run just the faster tests. If the tests fail then debug them. For coverage analysis installed the 'coverage' library with Python ./run_cov --quick Open htmlcov/index.html in your web browser","title":"Unit level testing"},{"location":"developing/#editing-the-code","text":"There are at least a couple of ways of working on the code, outlined here.","title":"Editing the code"},{"location":"developing/#using-github-codespaces","text":"","title":"Using GitHub Codespaces"},{"location":"developing/#what-is-github-codespaces","text":"Especially if you don't need to have a running Home Assistant system to make the changes you're interested in (e.g. for documentation, quick fixes etc.) a really easy way to work on the code is by using GitHub Codespaces. GitHub Codespaces gives you a full-featured development environment. This includes: A full IDE (a code editor), Visual Studio Code, which can be: Run in the browser, requiring no additional software to be installed Run in a virtual machine (VM) running in the cloud which can connect to a copy of VS Code installed on your own machine A terminal where you can run commands against your codebase e.g. running pre-commit to run the automatic code quality checks, linting files, etc. Software like mkdocs to re-generate the documentation files (and other software we may include) pre-installed in it The Codespaces environment is entirely separate from your HA installation, so does not require any modification to your HA setup to work with it. However, you are modifying code in an environment where you can't see HA running, so it's great for things like updating documentation, or writing automated tests, but not if you need to see your changes live within HA.","title":"What is GitHub Codespaces?"},{"location":"developing/#running-github-codespaces","text":"You may wish to first install VS Code on your machine, which does offer some benefits compared to running Codespaces in the cloud, but this is certainly not essential, and you'll see the same code editor and terminal, and you'll have the same commands and Python packages available in the terminal. The local installation is better in a small number of scenarios e.g. if you need to connect from your browser to a specific port on the VM, such as if you're working on the documentation. Importantly, even if you do a local install of VS Code and use that to edit your code within GitHub, the terminal, the code you're editing any commands that you run, and any processes like mkdocs that you may browse to are all running in the Codespaces VM. Your local VS Code is connected to the VM through SSH. It will appear as if the code, the terminal etc. are local, but they are not. Running a local VS Code install connected to Codespaces will not install Python, Python packages or anything else on your local machine. Now, from your fork or branch, click on the Code button, and select the Codespaces tab. You can create multiple environments, or use a single environment and swap between branches in it. Once you start your Codespaces environment, it will take a minute to create a VM for you, and to install the software we've asked it to install in there. It will also clone your repository and branch into it for you, and the VM will be authenticated with GitHub so you can commit and push straight back to your fork of Predbat on GitHub. You can choose between running the IDE in the browser or having your local installation of VS Code connects to the environment that GitHub Codespaces has created for you. The Codespaces will be already set up with Python, along with various Python packages (as defined in requirements.txt ). The environment is configured through the config in .devcontainer/devcontainer.json .","title":"Running GitHub Codespaces"},{"location":"developing/#developing-locally-within-home-assistant","text":"To be documented later.","title":"Developing locally within Home Assistant"},{"location":"developing/#working-on-the-documentation","text":"","title":"Working on the documentation"},{"location":"developing/#overview-of-the-predbat-documentation","text":"The documentation site at https://springfall2008.github.io/batpred/ is built from Markdown files in this repo. The Markdown files used to build the documentation are in the docs/ folder, with additional config for building the documentation site in mkdocs.yml . If you're making minor changes to the documentation e.g. fixing a spelling, you can just edit the Markdown files directly, and it will be pushed to the main documentation site as outlined in the documentation build process section below, once your changes are merged into main and released. However, if you're doing more than that, e.g. adding new sections, working with lists etc. we recommend you follow the instructions in working locally on the documentation below, as this will give you a live preview of what the documentation will look like once it's built and published. This will avoid any unexpected results appearing in the main documentation site. If you are adding a new file, please ensure you add that file to mkdocs.yml , so it will be linked from the menu in the sidebar.","title":"Overview of the Predbat documentation"},{"location":"developing/#the-documentation-build-process","text":"The documentation for the site is built using mkdocs , which will already be installed if you're using a GitHub Codespaces environment. For a detailed explanation of mkdocs features, please read the mkdocs documentation . As briefly covered above, mkdocs.yml contains the config for defining the documentation site, and the documentation is built by mkdocs reading the Markdown files in the docs/ folder, and creating HTML files from those files. mkdocs can be used locally for previewing, but is also used as part of the documentation build process that publishes the official documentation site. The publishing of the documentation is triggered by a GitHub action, as defined in .github/workflows/main.yml . In short, after configuring the build environment, mkdocs builds the site then pushes the HTML produced to the gh-pages branch, overwriting whatever was there previously. GitHub will then detect a new commit on the gh-pages branch, and that will trigger another action to run (as defined by GitHub). This action will take the HTML files on the gh-pages branch and will make them available at https://springfall2008.github.io/batpred/ . The documentation will be published as it is, with no further review process, so please ensure you check the documentation that will be built before merging it in.","title":"The documentation build process"},{"location":"developing/#working-locally-on-the-documentation","text":"If you are making changes to the documentation, you can see a live preview version of the documentation as it will be built and deployed. This preview version is local to your environment, is temporary, and does not impact the published version in any way. It's recommended for anything other than simple changes like fixing spelling, or adding a sentence or two. Things like new sections, lists, new pages etc. are best previewed due to the complications of various Markdown standards, as what works on GitHub READMEs, for example, does not necessarily work with the published documentation site (which follows a more strict Markdown standard). There are a number of terminal commands that you can use in the Codespaces environment. Open a terminal window in Codespaces by choosing Menu> Terminal > New Terminal. To run the live preview, enter mkdocs serve in the terminal window - this will cause mkdocs to build a local temporary version of the documentation site, and to temporarily publish it on port 8000 - it will show the link where you can access the documentation. Also, it will watch the docs/ folder, and any time you change the files, it will rebuild the site, allowing you to see changes to the Markdown files in your browser within a few seconds. The site will continue being served until you press CTRL-C to end the mkdocs serve command. Note, accessing the site published by mkdocs serve is not possible if you are using Codespaces to run VS Code in the browser, but it is possible if you're using it via VS Code running locally, due to how ports on your environment are shared.","title":"Working locally on the documentation"},{"location":"developing/#coding-standards","text":"","title":"Coding standards"},{"location":"developing/#expected-standards","text":"This section will be enhanced following discussions as we go. However, here's a starting point: Variable names should be lower_case_with_underscores - this fits with most existing variables, is a common standard for Python code, and also allows the spell checking to check individual words within the variable name.","title":"Expected standards"},{"location":"developing/#enforced-standards","text":"Certain coding standards are enforced within the repository. Some of them can be auto-fixed if you do a commit that fails one of those standards; other issues will need fixing first, as your pull request won't merge in GitHub until it passes. These standards are enforced by pre-commit , a tool which can run other tools to check, and potentially fix (for certain types of issues) any mistakes you've made. The .pre-commit-config.yaml file lists all checks that are currently carried out within the repository. Bear in mind that these checks are done according to the config within that file in the branch that you are working in, so if someone adds a new check, or changes some of the related settings, it won't apply on your branch until you've merged in their changes. Some of the tools have their own related config files: CSpell - .cspell.json and .cspell/custom-dictionary-workspace.txt Black - pyproject.toml Markdown Lint - .markdownlint.jsonc Additional notes on some of the standards: CSpell - if you have the spelling check failing due to a valid word which is not in the in-built dictionary, please add that word to the end of .cspell/custom-dictionary-workspace.txt and stage those changes. The spell-check should then pass. Note, that the dictionary file will get re-sorted alphabetically when you run pre-commit , so you'll need to re-stage the file after it's been sorted.","title":"Enforced standards"},{"location":"developing/#running-the-checks-locally","text":"If you are using a Codespaces environment, you'll already have pre-commit installed automatically. You can run it manually, or automatically. Running pre-commit manually: In a terminal window, running pre-commit will run all the checks against any files that you have modified and staged. Alternatively, running pre-commit run --all-files will run all the checks against all files within the repository. Note that if pre-commit makes any changes to any files when it runs, those changes will not be staged. You will need to stage those changes too before committing. You may notice pre-commit mentioning about stashing changes - this is because when it runs, any changes that aren't staged are stashed (saved away temporarily) so it runs against only the staged changes; after it has run, it pulls back those stashed changes, so they appear again (still unstaged). Running pre-commit automatically: If you run pre-commit install in a terminal window it will install a pre-commit hook - this is a file which tells git to run some code for each type you do a particular action (a pre-commit hook runs at the start of processing a commit, but there are other hooks e.g. pre-push). Now, any time you perform a commit, pre-commit will run automatically on the staged files - this is a handy way of making sure that you don't accidentally commit code which will fail checks later. You can still run it manually as outlined above, in addition to the automated checks that it will do on commits.","title":"Running the checks locally"},{"location":"developing/#running-the-checks-from-within-github","text":"When commits are done on pull requests, and in any other scenarios added to the on section of .github/workflows/linting.yml , the GitHub Actions in that file will run. In particular, the pre-commit.ci lite action will run. This uses the pre-commit code to run the same checks that get run locally (as described in the .pre-commit-config.yaml file). This will cause your commit, branch or pull request to get either a green tick or a red cross against it, to show whether the code passed the checks or not. This will happen automatically when you push code on a branch that has a pull request. In addition, if pre-commit finds any errors it can fix (e.g. a missing blank line at the end of a file, or trailing whitespace), it will make a commit of its own to fix those problems and will push that commit back to your branch on GitHub. This will then trigger another run, which should now pass. Note : This means that pre-commit will be adding commits to your branch - this will need you to be pulling changes from GitHub so you pick up the changes that have been added by pre-commit otherwise, you will hit a problem when you next try to push a commit on your branch. You can pull in those changes by running git pull , which is the equivalent of running git fetch and then git merge . This is no different to working on the same branch with another developer, but it will be different to the workflow most of us have when working on Predbat.","title":"Running the checks from within GitHub"},{"location":"devices/","text":"Support 3rd party devices/integrations This section of the documentation describes the configuration required for different 3rd party devices/integrations, typically EV chargers. If you have a device not listed then please raise a GitHub ticket with your configuration. Wallbox Pulsar https://www.home-assistant.io/integrations/wallbox/ Can be used both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in car_charging_energy: 're:sensor.wallbox_portal_added_energy' car_charging_planned: - 're:sensor.wallbox_portal_status_description' Wallbox works with Octopus Intelligent GO and can be triggered via Octopus themselves or an HA automation linked to the Predbat slot sensor Zappi https://github.com/CJNE/ha-myenergi Can be used both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in car_charging_energy: 're:sensor.myenergi_zappi_[0-9a-z]+_charge_added_session' car_charging_planned: - 're:sensor.myenergi_zappi_[0-9a-z]+_plug_status)' TIP: The Zappi must be set to Eco+ mode for IOG to control it. If Predbat starts exporting your battery (e.g. prior to the IOG cheap overnight period) then the Zappi can treat the exported energy as excess solar and start charging the EV battery with it! To prevent this happening, in the Zappi configuration set the Export Margin to 8000W so that the Zappi will only charge the EV from excess solar when more than 8000W is being exported (which should never happen). Tesla https://github.com/alandtse/tesla Can be used to extract the car's current SoC and Charge limit. Also can be used to control the cars charging with an automation linked to the Predbat slot sensor car_charging_limit: - 're:number.xxx_charge_limit' car_charging_soc: - 're:sensor.xxx_battery' Toyota https://github.com/DurgNomis-drol/ha_toyota - For Toyota EU cars only Can be used to extract the car's current SoC. car_charging_soc: - 'sensor.toyota_XXX_battery_level' Example sensor name for BZ4X - sensor.toyota_bz4x_battery_level Renault https://www.home-assistant.io/integrations/renault Can be used to extract the car's current SoC. car_charging_soc: - 'sensor.battery' Ohme Direct Predbat can talk direct to the Ohme cloud service to control your Ohme EV charger. See Ohme Direct HA In-Built Ohme Integration https://www.home-assistant.io/integrations/ohme The in-built Home Assistant Ohme integration can also be used with Predbat both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in. If you are on the Octopus Intelligent GO tariff the integration can be used to map out the cars charging slots into Predbat so that Predbat charges or stops your battery discharging into the car when its charging. car charging energy ohme_name: 're:time.ohme_(.+)_target_time' car_charging_energy: 'sensor.ohme_{ohme_name}_energy' Car charging planned car_charging_planned: - \"sensor.ohme_{ohme_name}_status\" car_charging_planned_response: - \"yes\" - \"on\" - \"true\" - \"connected\" - \"ev connected\" - \"charging\" - \"paused\" - \"waiting for car demand\" - \"waiting for ev\" - \"scheduled\" - \"enabled\" - \"latched\" - \"locked\" - \"plugged in\" - \"plugged_in\" - \"Plugged in\" - \"pending_approval\" Octopus Intelligent GO Replace XXX with your device ID which can be found by going to 'Settings' / 'Developer Tools' / 'Actions' then selecting 'Ohme: List Charge Slots' then selecting your Device from the drop down menu. Then click on 'Go to YAML mode' and copy the long string after config_entry: octopus_intelligent_slot: 'ohme.list_charge_slots' octopus_intelligent_slot_action_config: 'XXX' octopus_ready_time: 'time.ohme_{ohme_name}_target_time' octopus_charge_limit: 'number.ohme_{ohme_name}_target_percentage' Note: You should turn on switch.predbat_octopus_intelligent_ignore_unplugged as the Ohme charger does not clear its schedule when unplugged. Using Ohme car charging plans on other tariff e.g. Agile octopus_ready_time: 'time.ohme_{ohme_name}_target_time' octopus_charge_limit: 'number.ohme_{ohme_name}_target_percentage' octopus_slot_low_rate: False Note: You should turn on switch.predbat_octopus_intelligent_ignore_unplugged as the Ohme charger does not clear its schedule when unplugged. Old Ohme HACS Integration https://github.com/dan-r/HomeAssistant-Ohme Can be used both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in. If you are on the Octopus Intelligent GO tariff the integration can be used to map out the cars charging slots into Predbat so that Predbat charges or stops your battery discharging into the car when its charging. car charging energy car_charging_energy: 'sensor.ohme_session_energy' Octopus Intelligent GO octopus_intelligent_slot: 'binary_sensor.ohme_slot_active' octopus_ready_time: 'time.ohme_target_time' octopus_charge_limit: 'number.ohme_target_percentage' Note: You should turn on switch.predbat_octopus_intelligent_ignore_unplugged as the Ohme charger does not clear its schedule when unplugged. Using Ohme car charging plans on other tariff e.g. Agile octopus_intelligent_slot: 'binary_sensor.ohme_slot_active' octopus_ready_time: 'time.ohme_target_time' octopus_charge_limit: 'number.ohme_target_percent' octopus_slot_low_rate: False Note: You should turn on switch.predbat_octopus_intelligent_ignore_unplugged as the Ohme charger does not clear its schedule when unplugged. Determine if the car is charging now Normally not recommended if you are on Intelligent GO, but can be useful for ad-hoc charging not planned via Predbat car_charging_now: - 'binary_sensor.ohme_car_charging' PodPoint https://github.com/mattrayner/pod-point-home-assistant-component Can be used both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in. car_charging_energy: 're:(sensor.psl_[0-9]+_current_energy)' car_charging_planned: - 're:(sensor.psl_[0-9]+_status)' car_charging_planned_response: - 'plugged in' - 'connected-waiting-for-schedule' - 'suspended-evse' - 'pending' - 'charging' car_charging_now: - 're:(sensor.psl_[0-9]+_status)' car_charging_now_response: - 'charging' Also can be used to control the cars charging with an automation linked to the Predbat slot sensor. The device needs to be set to 'Smart' mode in the PodPoint app. Your automation trigger should then set the switch.psl_XXXXXX_charging_allowed to on. And off to stop charging. This uses the PodPoint schedule override setting to start/stop the charge. Hypervolt https://github.com/gndean/home-assistant-hypervolt-charger Can be used both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in (only V3 models). For plugged-in detection on V2 models, see guidance https://springfall2008.github.io/batpred/car-charging/#example-ev-and-charger-setup . car_charging_energy: 're:(sensor.hypervolt_session_energy_total_increasing)' car_charging_planned: - 're:(binary_sensor.hypervolt_car_plugged)' car_charging_planned_response: - 'on' car_charging_now: - 're:(sensor.hypervolt_charging_readiness)' car_charging_now_response: - 'charging' Note: sensor.hypervolt_session_energy_total_increasing defaults to 'unknown' between charging sessions. Agile Tariff To automate the schedule charging with Predbat, set up the automation to detect when there is a change to binary_sensor.predbat_car_charging_slot . Ensure that select.hypervolt_charge_mode is in 'Boost', when Predbat charging slot is 'on', set select.hypervolt_activation_mode to 'Plug and Charge', when it is 'off' set the 'Schedule', this is the recommended method for start/stop charging. Octopus Energy https://github.com/BottlecapDave/HomeAssistant-OctopusEnergy Can be used for energy rates, car charging and saving sessions For Energy Rates metric_octopus_import: 're:(sensor.(octopus_energy_|)electricity_[0-9a-z]+_[0-9a-z]+_current_rate)' metric_octopus_export: 're:(sensor.(octopus_energy_|)electricity_[0-9a-z]+_[0-9a-z]+_export_current_rate)' For Octopus Intelligent Go octopus_intelligent_slot: 're:(binary_sensor.octopus_energy([0-9a-z_]+|)_intelligent_dispatching)' octopus_ready_time: 're:((select|time).octopus_energy_([0-9a-z_]+|)_intelligent_target_time)' octopus_charge_limit: 're:(number.octopus_energy([0-9a-z_]+|)_intelligent_charge_target)' For Octopus Saving Sessions octopus_saving_session: 're:(binary_sensor.octopus_energy([0-9a-z_]+|)_saving_session(s|))' octopus_saving_session_octopoints_per_penny: 8 Nordpool For adjustment to Octopus Intelligent This is built into Predbat, see the apps.yaml configuration guide As your energy rates (e.g. for those in Norway) https://github.com/custom-components/nordpool/ Can be linked to Predbat to provide energy rates in your region e.g: metric_octopus_import: 'sensor.nordpool_kwh_oslo_eur_3_10_025' Solcast https://github.com/BJReplay/ha-solcast-solar For solar forecast data pv_forecast_today: re:(sensor.(solcast_|)(pv_forecast_|)forecast_today) pv_forecast_tomorrow: re:(sensor.(solcast_|)(pv_forecast_|)forecast_tomorrow) pv_forecast_d3: re:(sensor.(solcast_|)(pv_forecast_|)forecast_(day_3|d3)) pv_forecast_d4: re:(sensor.(solcast_|)(pv_forecast_|)forecast_(day_4|d4))","title":"Support 3rd party devices/integrations"},{"location":"devices/#support-3rd-party-devicesintegrations","text":"This section of the documentation describes the configuration required for different 3rd party devices/integrations, typically EV chargers. If you have a device not listed then please raise a GitHub ticket with your configuration.","title":"Support 3rd party devices/integrations"},{"location":"devices/#wallbox-pulsar","text":"https://www.home-assistant.io/integrations/wallbox/ Can be used both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in car_charging_energy: 're:sensor.wallbox_portal_added_energy' car_charging_planned: - 're:sensor.wallbox_portal_status_description' Wallbox works with Octopus Intelligent GO and can be triggered via Octopus themselves or an HA automation linked to the Predbat slot sensor","title":"Wallbox Pulsar"},{"location":"devices/#zappi","text":"https://github.com/CJNE/ha-myenergi Can be used both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in car_charging_energy: 're:sensor.myenergi_zappi_[0-9a-z]+_charge_added_session' car_charging_planned: - 're:sensor.myenergi_zappi_[0-9a-z]+_plug_status)' TIP: The Zappi must be set to Eco+ mode for IOG to control it. If Predbat starts exporting your battery (e.g. prior to the IOG cheap overnight period) then the Zappi can treat the exported energy as excess solar and start charging the EV battery with it! To prevent this happening, in the Zappi configuration set the Export Margin to 8000W so that the Zappi will only charge the EV from excess solar when more than 8000W is being exported (which should never happen).","title":"Zappi"},{"location":"devices/#tesla","text":"https://github.com/alandtse/tesla Can be used to extract the car's current SoC and Charge limit. Also can be used to control the cars charging with an automation linked to the Predbat slot sensor car_charging_limit: - 're:number.xxx_charge_limit' car_charging_soc: - 're:sensor.xxx_battery'","title":"Tesla"},{"location":"devices/#toyota","text":"https://github.com/DurgNomis-drol/ha_toyota - For Toyota EU cars only Can be used to extract the car's current SoC. car_charging_soc: - 'sensor.toyota_XXX_battery_level' Example sensor name for BZ4X - sensor.toyota_bz4x_battery_level","title":"Toyota"},{"location":"devices/#renault","text":"https://www.home-assistant.io/integrations/renault Can be used to extract the car's current SoC. car_charging_soc: - 'sensor.battery'","title":"Renault"},{"location":"devices/#ohme-direct","text":"Predbat can talk direct to the Ohme cloud service to control your Ohme EV charger. See Ohme Direct","title":"Ohme Direct"},{"location":"devices/#ha-in-built-ohme-integration","text":"https://www.home-assistant.io/integrations/ohme The in-built Home Assistant Ohme integration can also be used with Predbat both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in. If you are on the Octopus Intelligent GO tariff the integration can be used to map out the cars charging slots into Predbat so that Predbat charges or stops your battery discharging into the car when its charging. car charging energy ohme_name: 're:time.ohme_(.+)_target_time' car_charging_energy: 'sensor.ohme_{ohme_name}_energy' Car charging planned car_charging_planned: - \"sensor.ohme_{ohme_name}_status\" car_charging_planned_response: - \"yes\" - \"on\" - \"true\" - \"connected\" - \"ev connected\" - \"charging\" - \"paused\" - \"waiting for car demand\" - \"waiting for ev\" - \"scheduled\" - \"enabled\" - \"latched\" - \"locked\" - \"plugged in\" - \"plugged_in\" - \"Plugged in\" - \"pending_approval\" Octopus Intelligent GO Replace XXX with your device ID which can be found by going to 'Settings' / 'Developer Tools' / 'Actions' then selecting 'Ohme: List Charge Slots' then selecting your Device from the drop down menu. Then click on 'Go to YAML mode' and copy the long string after config_entry: octopus_intelligent_slot: 'ohme.list_charge_slots' octopus_intelligent_slot_action_config: 'XXX' octopus_ready_time: 'time.ohme_{ohme_name}_target_time' octopus_charge_limit: 'number.ohme_{ohme_name}_target_percentage' Note: You should turn on switch.predbat_octopus_intelligent_ignore_unplugged as the Ohme charger does not clear its schedule when unplugged. Using Ohme car charging plans on other tariff e.g. Agile octopus_ready_time: 'time.ohme_{ohme_name}_target_time' octopus_charge_limit: 'number.ohme_{ohme_name}_target_percentage' octopus_slot_low_rate: False Note: You should turn on switch.predbat_octopus_intelligent_ignore_unplugged as the Ohme charger does not clear its schedule when unplugged.","title":"HA In-Built Ohme Integration"},{"location":"devices/#old-ohme-hacs-integration","text":"https://github.com/dan-r/HomeAssistant-Ohme Can be used both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in. If you are on the Octopus Intelligent GO tariff the integration can be used to map out the cars charging slots into Predbat so that Predbat charges or stops your battery discharging into the car when its charging. car charging energy car_charging_energy: 'sensor.ohme_session_energy' Octopus Intelligent GO octopus_intelligent_slot: 'binary_sensor.ohme_slot_active' octopus_ready_time: 'time.ohme_target_time' octopus_charge_limit: 'number.ohme_target_percentage' Note: You should turn on switch.predbat_octopus_intelligent_ignore_unplugged as the Ohme charger does not clear its schedule when unplugged. Using Ohme car charging plans on other tariff e.g. Agile octopus_intelligent_slot: 'binary_sensor.ohme_slot_active' octopus_ready_time: 'time.ohme_target_time' octopus_charge_limit: 'number.ohme_target_percent' octopus_slot_low_rate: False Note: You should turn on switch.predbat_octopus_intelligent_ignore_unplugged as the Ohme charger does not clear its schedule when unplugged. Determine if the car is charging now Normally not recommended if you are on Intelligent GO, but can be useful for ad-hoc charging not planned via Predbat car_charging_now: - 'binary_sensor.ohme_car_charging'","title":"Old Ohme HACS Integration"},{"location":"devices/#podpoint","text":"https://github.com/mattrayner/pod-point-home-assistant-component Can be used both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in. car_charging_energy: 're:(sensor.psl_[0-9]+_current_energy)' car_charging_planned: - 're:(sensor.psl_[0-9]+_status)' car_charging_planned_response: - 'plugged in' - 'connected-waiting-for-schedule' - 'suspended-evse' - 'pending' - 'charging' car_charging_now: - 're:(sensor.psl_[0-9]+_status)' car_charging_now_response: - 'charging' Also can be used to control the cars charging with an automation linked to the Predbat slot sensor. The device needs to be set to 'Smart' mode in the PodPoint app. Your automation trigger should then set the switch.psl_XXXXXX_charging_allowed to on. And off to stop charging. This uses the PodPoint schedule override setting to start/stop the charge.","title":"PodPoint"},{"location":"devices/#hypervolt","text":"https://github.com/gndean/home-assistant-hypervolt-charger Can be used both for the Car Charging Hold feature (to filter out previous car charging) and to determine if the car is plugged in (only V3 models). For plugged-in detection on V2 models, see guidance https://springfall2008.github.io/batpred/car-charging/#example-ev-and-charger-setup . car_charging_energy: 're:(sensor.hypervolt_session_energy_total_increasing)' car_charging_planned: - 're:(binary_sensor.hypervolt_car_plugged)' car_charging_planned_response: - 'on' car_charging_now: - 're:(sensor.hypervolt_charging_readiness)' car_charging_now_response: - 'charging' Note: sensor.hypervolt_session_energy_total_increasing defaults to 'unknown' between charging sessions. Agile Tariff To automate the schedule charging with Predbat, set up the automation to detect when there is a change to binary_sensor.predbat_car_charging_slot . Ensure that select.hypervolt_charge_mode is in 'Boost', when Predbat charging slot is 'on', set select.hypervolt_activation_mode to 'Plug and Charge', when it is 'off' set the 'Schedule', this is the recommended method for start/stop charging.","title":"Hypervolt"},{"location":"devices/#octopus-energy","text":"https://github.com/BottlecapDave/HomeAssistant-OctopusEnergy Can be used for energy rates, car charging and saving sessions For Energy Rates metric_octopus_import: 're:(sensor.(octopus_energy_|)electricity_[0-9a-z]+_[0-9a-z]+_current_rate)' metric_octopus_export: 're:(sensor.(octopus_energy_|)electricity_[0-9a-z]+_[0-9a-z]+_export_current_rate)' For Octopus Intelligent Go octopus_intelligent_slot: 're:(binary_sensor.octopus_energy([0-9a-z_]+|)_intelligent_dispatching)' octopus_ready_time: 're:((select|time).octopus_energy_([0-9a-z_]+|)_intelligent_target_time)' octopus_charge_limit: 're:(number.octopus_energy([0-9a-z_]+|)_intelligent_charge_target)' For Octopus Saving Sessions octopus_saving_session: 're:(binary_sensor.octopus_energy([0-9a-z_]+|)_saving_session(s|))' octopus_saving_session_octopoints_per_penny: 8","title":"Octopus Energy"},{"location":"devices/#nordpool","text":"","title":"Nordpool"},{"location":"devices/#for-adjustment-to-octopus-intelligent","text":"This is built into Predbat, see the apps.yaml configuration guide","title":"For adjustment to Octopus Intelligent"},{"location":"devices/#as-your-energy-rates-eg-for-those-in-norway","text":"https://github.com/custom-components/nordpool/ Can be linked to Predbat to provide energy rates in your region e.g: metric_octopus_import: 'sensor.nordpool_kwh_oslo_eur_3_10_025'","title":"As your energy rates (e.g. for those in Norway)"},{"location":"devices/#solcast","text":"https://github.com/BJReplay/ha-solcast-solar For solar forecast data pv_forecast_today: re:(sensor.(solcast_|)(pv_forecast_|)forecast_today) pv_forecast_tomorrow: re:(sensor.(solcast_|)(pv_forecast_|)forecast_tomorrow) pv_forecast_d3: re:(sensor.(solcast_|)(pv_forecast_|)forecast_(day_3|d3)) pv_forecast_d4: re:(sensor.(solcast_|)(pv_forecast_|)forecast_(day_4|d4))","title":"Solcast"},{"location":"energy-rates/","text":"Energy rates Predbat needs to know what your Import and (optionally) Export rates are so it can plan the optimal way to use your battery. Your Import and Export rates can be simple flat rates, more complex time-of-day tariffs (e.g. Economy 7, Octopus Flux), or daily/half-hourly/quarter-hour rates that track electricity market prices (e.g. Octopus Agile or Tracker). Energy rates are all configured in the apps.yaml file that's stored in a directory name that depends on what type of Predbat installation method you have used . You will need to use a file editor within Home Assistant (e.g. either the File editor or Studio Code Server apps) to edit this file - see editing configuration files within Home Assistant if you need to install an editor. There are four different ways of configuring your Energy rates in apps.yaml , using Octopus Energy Direct , using the Octopus Energy Integration , using Octopus Rates URL's , or manually defining your rates and time periods . At least one of these methods must be used to define your import and export rates. If you don't then Predbat will assume zero for your energy rates. Plan Interval By default Predbat will plan and execute its plan based upon 30 minute time intervals. Energy rates need to be provided that align to :30 and :00 minutes past the hour. If your energy provider prices on the basis of smaller (or larger) intervals then the 30 minute interval duration can be overwritten by setting in apps.yaml : plan_interval_minutes: duration Octopus Energy direct If your electricity supplier is Octopus Energy then the simplest way to provide Predbat with your electricity pricing information is to connect Predbat directly to Octopus. This method will not work correctly if you have multiple import or export meters. A single Octopus Intelligent GO car charger or car is supported and Predbat will plan your battery charging based on iGo sessions. Saving sessions are also supported, including Predbat auto-enrolling you to them (note you must be joined to both the Octopus Octopoints and then the Saving Sessions schemes beforehand). You should first log into your Octopus account and go to the Accounts section and copy your Octopus account number e.g. A-1234567 . Then go to the API Access page , click 'regenerate API key' and copy your API key e.g. sk_live_1as12355... Put these both into your apps.yaml and you are done. octopus_api_account: 'XXXXXXXX' octopus_api_key: 'sk_live_yyyyyyyy' Octopus Free energy sessions Predbat can obtain details of Free energy sessions directly from the Octopus Web Site. As Octopus do not publish an API for this information it has to be done by 'scraping' the website - there may be future issues with this if Octopus ever change the website format. If you enable free energy sessions in Predbat then sessions will be considered even if you forget to sign-up to them in your Octopus account so be careful! octopus_free_url: 'http://octopus.energy/free-electricity' Octopus Energy Home Assistant Integration Octopus Energy integration setup Instead of using Octopus Energy Direct method, Predbat can also work with the Octopus Energy integration , this brings greater configurability than the direct method. The Octopus Energy integration connects to your Octopus Energy account and retrieves the tariffs you are on, and the current tariff rates. If you change tariff within Octopus the integration will automatically retrieve the updated tariff information, and as tariff prices change, again they are automatically retrieved. The integration also provides support for Intelligent Octopus charging to support (multiple) car charging. Follow the instructions provided in the Octopus Energy integration documentation to install and set up the integration. Once installed, you will need to configure the integration (go to Settings / Devices & Services / Integrations / Octopus Energy then click 'Configure') and provide the integration with your 'Octopus API key' (that you obtain from your Octopus account: Personal Details / API access). CAUTION To get detailed energy rates needed by Predbat you need to go into Home Assistant and manually enable the following Octopus Energy events which are disabled by default when the integration is installed: event.octopus_energy_electricity_xxxxxxxx_previous_day_rates event.octopus_energy_electricity_xxxxxxxx_current_day_rates event.octopus_energy_electricity_xxxxxxxx_next_day_rates event.octopus_energy_electricity_xxxxxxxx_export_previous_day_rates event.octopus_energy_electricity_xxxxxxxx_export_current_day_rates event.octopus_energy_electricity_xxxxxxxx_export_next_day_rates event.octopus_energy_gas_xxxxxxxx_previous_day_rates event.octopus_energy_gas_xxxxxxxx_current_day_rates event.octopus_energy_gas_xxxxxxxx_next_day_rates To enable the above events: Go to Settings / Devices & Services / Integrations, choose Octopus Energy, then xx entities You will see a list of entities (and events) supplied by the Octopus integration Click the 'Filter' symbol on the top right-hand corner (a series of lines in a downwards pointing arrow) and make sure all the options are selected Then in the left-hand-side search entities box, type \"current_day\" Click on the first event that comes up, check the name is the right one Click the cog wheel, then you should see the option to enable the event Click the option to enable the event and press 'Update' to make the change Repeat this for the other events. The gas rates are only required if you have a gas boiler, and an iBoost, and are using Predbat to determine whether it's cheaper to heat your hot water with the iBoost or via gas Verify that the integration is working correctly in Home Assistant by going to 'Settings' / 'Developer Tools' / 'States', and entering 'octopus' in the 'Filter entities' box. Confirm that the Octopus entities are being populated correctly. Configuring Predbat to use the Octopus Energy integration The following configuration items in apps.yaml are used to configure Predbat to use the Octopus Energy integration. They are set to a regular expression and should be auto-discovered so that Predbat automatically uses the Octopus Energy integration, but you can comment out the regular expression lines to disable, or you set them manually. metric_octopus_import - Import rates from the Octopus Energy integration, should point to the sensor sensor.octopus_energy_electricity_METER_NUMBER_current_rate metric_octopus_export - Export rates from the Octopus Energy integration, should point to the sensor sensor.octopus_energy_electricity_METER_NUMBER_export_current_rate metric_octopus_gas - Gas rates from the Octopus Energy integration, should point to the sensor sensor.octopus_energy_gas_METER_NUMBER_current_rate octopus_intelligent_slot - If you have the Octopus Intelligent Go tariff this should point to the 'slot' sensor binary_sensor.octopus_energy_DEVICE_ID_intelligent_dispatching metric_octopus_gas is (as above) only required to be configured if you are using Predbat to determine whether to heat your hot water via your iBoost or gas. If you do not have an export rate or are not on the Octopus Go tariff, then the appropriate lines can be commented out in apps.yaml. NOTE: Predbat using the Octopus integration rates relies upon the day rate events being enabled (see above) and the events and the sensor found by metric_octopus_xxx in apps.yaml being similarly named. There have been occasions with some Octopus Integration installations where the event name is as above but the sensor name has a different prefix, e.g. sensor.electricity_METER_NUMBER_current_rate and not sensor.octopus_energy_electricity_METER_NUMBER_current_rate. If this is the case then the sensor must be renamed to the correct format so that Predbat can function correctly. Standing charge Predbat can also (optionally) include the daily standing charge in cost predictions. The following configuration item in apps.yaml defaults to obtaining the standing charge from the Octopus Energy integration: metric_standing_charge - Standing charge in pounds. By default points to the Octopus Energy integration sensor sensor.octopus_energy_electricity_METER_NUMBER_current_standing_charge You can manually change this to a standing charge in pounds, e.g. 0.50 is 50p, or delete this line from apps.yaml, or set it to zero if you don't want the standing charge (and only have consumption usage) to be included in Predbat charts and output data. Note that this configuration option to suppress the standing charge only applies if you are using the Octopus Integration from Predbat. If you are using the Octopus Energy direct method of Predbat directly connecting to Octopus then the standing charge will always be included in the plan and charts. Octopus Saving sessions Predbat can automatically join you to Octopus saving sessions and plan battery activity for the saving session period to maximise your income. Note: You must have signed up to both the Octopus Octoplus and then the Saving Session schemes to benefit from these events For Predbat to automatically manage Octopus saving sessions the following additional configuration item in apps.yaml is used. Like the electricity rates, this is set in the apps.yaml template to a regular expression that should auto-discover the Octopus Energy integration. octopus_saving_session - Indicates if a saving session is active, should point to the sensor binary_sensor.octopus_energy_ACCOUNT_ID_octoplus_saving_sessions. When a saving session is available it will be automatically joined by Predbat and should then appear as a joined session within the next 30 minutes. NOTE: Predbat automatically joining the saving session relies upon the event being enabled and Predbat being able to find the saving session event as 'event.octopus_energy_ACCOUNT_ID_octoplus_saving_session_events' - there have been occasions with some Octopus Integration installations where the event name is different. If this is the case then the event must be renamed to the correct format that Predbat can function correctly. In the Predbat plan, for joined saving sessions the energy rates for import and export will be overridden by adding the assumed saving rate to your normal rate. The assumed rate will be taken from the Octopus Energy integration and converted into pence using the octopus_saving_session_octopoints_per_penny configuration item in apps.yaml (default is 8). If you normally cut back your house usage during a saving session then you can change input_number.predbat_load_scaling_saving to allow Predbat to assume an energy reduction in this period. E.g. setting to a value of 0.8 would indicate you will use 80% of the normal consumption in that period (a 20% reduction). As the saving session import and export rates are very high compared to normal Predbat will plan additional export during the saving session period. If necessary, a pre-charge may happen at some point during the day to maintain the battery right level for the session. Note that Predbat's operational mode select.predbat_mode must be set to either 'Control charge' or 'Control charge & discharge' for Predbat to be able to manage the battery for the saving session. If you do not have an export tariff then forced export will not apply and Predbat will just ensure you have enough battery charge to see you through the saving session period. If you do not want Predbat to automatically join Octopus saving sessions and manage your battery activity for the session, simply delete or comment out the octopus_saving_session entry in apps.yaml . Octopus free (power up) events Predbat can automatically detect Octopus free events and adjust your battery plan according. Note that this is derived from external sources, which do not verify your eligibility for free sessions. For Predbat to automatically manage Octopus free sessions the following additional configuration item in apps.yaml is used. Note: You must have signed up to the Octopus Octoplus scheme and eligible to benefit from these events Like the electricity rates, this is set in the apps.yaml template to a regular expression that should auto-discover the Octopus Energy integration. octopus_free_session - Will point to the free event sensor that is exposed by the Octopus Energy Integration. This event sensor contains the dates/times of all the free events. octopus_free_session: 're:(event.octopus_energy_([0-9a-z_]+|)_octoplus_free_electricity_session_events)' Note: This event may need to be enabled in Home Assistant first - see How to Enable Octopus events If you normally increase your house usage during a free session then you can change input_number.predbat_load_scaling_free to allow Predbat to assume an energy increase in this period. E.g. setting to a value of 1.2 would indicate you will use 20% more energy than normal during this period. (Default is 1.2) If you do not want Predbat to see these sessions then comment out the octopus_free_session setting. Note: If the above is not working due to a lack of data (via a 3rd party service) Predbat can scrape directly from the Octopus Web Site, this may not work in future if Octopus ever change the website format. If you enable this then sessions will be considered by Predbat even if you forget to sign-up to free electricity sessions in your Octopus account so be careful! octopus_free_url: 'http://octopus.energy/free-electricity' Octopus Rates URL As an alternative to the Octopus Direct or Octopus Energy integration methods, for Octopus Energy customers, you can configure Predbat to get the electricity rates directly online from the Octopus website. In apps.yaml configure the following lines: rates_import_octopus_url to point to the appropriate import tariff URL on the Octopus website rates_export_octopus_url to point to the export tariff URL e.g. (for DNO region A) rates_import_octopus_url : \"https://api.octopus.energy/v1/products/FLUX-IMPORT-23-02-14/electricity-tariffs/E-1R-FLUX-IMPORT-23-02-14-A/standard-unit-rates\" rates_import_octopus_url : \"https://api.octopus.energy/v1/products/AGILE-24-10-01/electricity-tariffs/E-1R-AGILE-24-10-01-A/standard-unit-rates\" rates_export_octopus_url: \"https://api.octopus.energy/v1/products/FLUX-EXPORT-23-02-14/electricity-tariffs/E-1R-FLUX-EXPORT-23-02-14-A/standard-unit-rates\" rates_export_octopus_url: \"https://api.octopus.energy/v1/products/AGILE-OUTGOING-19-05-13/electricity-tariffs/E-1R-AGILE-OUTGOING-19-05-13-A/standard-unit-rates/\" If you configure the rates_import_octopus_url then Predbat will use this instead of metric_octopus or rates_import. Similarly, rates_export_octopus_url takes precedence over metric_octopus_export or rates_export. A full list of available Octopus products is at https://api.octopus.energy/v1/products/ . If you view this page, search for the tariff by name, then copy the URL it shows into a new tab. E.g. https://api.octopus.energy/v1/products/GO-VAR-22-10-14/ Look through that page to find the right URL for usage charges in your DNO area https://api.octopus.energy/v1/products/GO-VAR-22-10-14//electricity-tariffs/E-1R-GO-VAR-22-10-14-A/standard-unit-rates (For area A) Configuring the Octopus rates URL is an expert feature as Octopus change the available products from time to time, so for most users, the Octopus Direct or Octopus Energy integration are simpler solutions. Energidataservice Integration https://github.com/MTrab/energidataservice If your electricity supplier provides data through the Energi Data Service, you can use the Energidataservice integration to fetch real-time and future electricity pricing data. This integration allows you to automatically retrieve rates and apply them within your energy management system, including optional tariff adjustments for greater accuracy. The integration processes hourly pricing data and converts it into (by default) 30-minute intervals, making it ideal for scheduling and optimising energy usage. Configuring Predbat to Use the Energidataservice Integration The following configuration items in apps.yaml are used to configure Predbat to use the Energidataservice integration. These items must be set explicitly to ensure that Predbat retrieves the correct import and export rates. metric_energidataservice_import - Import rates from the Energidataservice integration. This should point to the sensor that provides hourly import rates, such as sensor.energi_data_service. metric_energidataservice_export - Export rates from the Energidataservice integration. This should point to the sensor that provides hourly export rates (e.g., solar feed-in rates), such as sensor.energi_data_service_export. Other Energy Spot Rate sensor integrations Different spot rate integrations that include forecast prices may be used. Because integrations format their attribute data differently, a template sensor is required to convert the attribute data into a new sensor with the correctly formatted attributes: raw_today and raw_tomorrow. metric_octopus_import: 'sensor.current_buy_electricity_price_raw' metric_octopus_export: 'sensor.current_sell_electricity_price_raw' Czech Republic example https://github.com/rnovacek/homeassistant_cz_energy_spot_prices {% set attributes = states.sensor.current_buy_electricity_price.attributes %} {% set datetime_dict = zip(attributes.keys() | map('as_datetime', default={}), attributes.values()) | selectattr(0, 'datetime') %} {% set ns = namespace(output=[]) %} {% for start_time, price in datetime_dict %} {% if start_time < today_at() + timedelta(days=1) %} {% set ns.output = ns.output + [{'start': start_time.isoformat(), 'end': (start_time + timedelta(hours=1)).isoformat(), 'value': price | round(5)}] %} {% endif %} {% endfor %} {{ns.output | sort(attribute='start') }} Full code for CZ energy spot rate template: https://gist.github.com/ziat007/ae29e26ae257f069520b65f0168c3a6b Frank Energie Export rates with export fee The Frank Energie integration provides import and export rates for Frank Energie customers in the Netherlands. However the integration provides only the market rates and does not include the export fixed fee of 0.0115 per kWh. A template sensor can be used to manipulate the rates provided by the integration and add the required fee: # Export to Grid Payment - name: \"Frank export price schedule (\u20ac/kWh)\" unique_id: frank_export_price_schedule_eur_kwh unit_of_measurement: \"\u20ac/kWh\" icon: mdi:currency-eur state_class: measurement state: > {% set src = 'sensor.frank_energie_prices_current_electricity_market_price' %} {% set fee = states('input_number.frank_export_fee_eur_per_kwh') | float(0.0115) %} {% set arr = state_attr(src, 'prices') or [] %} {% set now_ = now() %} {% set price = states(src) | float(0) %} {% for b in arr %} {% if now_ >= as_datetime(b['from']) and now_ < as_datetime(b['till']) %} {% set price = b['price'] | float(0) %} {% endif %} {% endfor %} {{ (price - fee) | round(5) }} attributes: prices: > {% set src = 'sensor.frank_energie_prices_current_electricity_market_price' %} {% set fee = states('input_number.frank_export_fee_eur_per_kwh') | float(0.0115) %} {% set arr = state_attr(src, 'prices') or [] %} {% set out = namespace(list=[]) %} {% for b in arr %} {% set p = (b['price'] | float(0)) - fee %} {% set item = {'from': b['from'].strftime('%Y-%m-%dT%H:%M:%S%z'), 'till': b['till'].strftime('%Y-%m-%dT%H:%M:%S%z'), 'price': (p | round(5))} %} {% set out.list = out.list + [item] %} {% endfor %} {{ out.list | tojson }} Rate Bands to manually configure Energy Rates If you are not an Octopus Energy customer, or you are but your energy rates repeat simply, you can configure your rate bands in apps.yaml using rates_import/rates_export/rates_gas. Add the following entries to apps.yaml to define the pattern of rates over 24 hours: rates_import: - start: \"HH:MM:SS\" end: \"HH:MM:SS\" rate: pence rates_export: - start: \"HH:MM:SS\" end: \"HH:MM:SS\" rate: pence rates_gas: - start: \"HH:MM:SS\" end: \"HH:MM:SS\" rate: pence start and end are in the time format of \"HH:MM:SS\" e.g. \"12:30:00\" and should be aligned to 30 minute slots normally, i.e. end with \":30:00\" or \":00:00\". If you have set a different plan interval duration for your energy provider, e.g. 15 minute intervals, then make sure the start and end times align with the interval periods. The start and end times for the different rates must cover the whole 24 hour period with no gaps! rate is in pence e.g. 4.2 day_of_week Can also be used to control rates on specific days. You can specify one day or multiple days split by a comma. Note: Day 1 = Monday, 2 = Tuesday .... 7 = Sunday e.g: rates_import: - rate: 15 day_of_week: \"1,2,3,4,5\" - rate: 10 day_of_week: \"6,7\" start and end can be omitted and Predbat will assume that you are on a single flat-rate tariff. If there are any gaps in the 24-hour period then a zero rate will be assumed. The gas rates are only required if you have a gas boiler, or an iBoost, and are using Predbat to determine whether it's cheaper to heat your hot water with the iBoost or via gas. Manually over-riding energy rates You can also override the import or export energy rates (regardless of whether they are set manually or via the Octopus Energy integration) by using the override feature in apps.yaml. Rate override is used to set the specific date and time period where your rates are different, e.g. an Octopus Power Up session (zero rate for an hour or two), or the British Gas half-price electricity on Sundays. Unfortunately, there aren't any API's available to feed this information automatically into Predbat so you will have to define your own input controls and use the Predbat Manual API , or edit apps.yaml manually to set the appropriate rate over-ride dates and times: rates_import_override: - date: \"YYYY-MM-DD\" start: \"HH:MM:SS\" end: \"HH:MM:SS\" rate: pence rates_export_override: - date: \"YYYY-MM-DD\" start: \"HH:MM:SS\" end: \"HH:MM:SS\" rate: pence Optionally you can add a predicted load scaling factor for these periods using load_scaling , for example: rates_import_override: - date: '2024-01-21' start: '17:30:00' end: '18:30:00' rate: 150 load_scaling: 0.8 This instructs Predbat that during a 1-hour period at 5:30-6:30pm on 21st of Jan set the import rate to 150p and assume our load will be 80% of normal (20% lower). You can also make relative adjustments to your energy rates, e.g. if you want to avoid exporting during peak periods to improve your energy saving session results you could make a relative adjustment to your export rates using rate_increment . The reason not to just set rate is that when an energy saving session is active you do not want to ignore the higher export rate that is automatically provided by Octopus. In this example we subtract 10p from our export rate during the period that saving sessions normally fall within and thus steer Predbat away from force exporting during that time. The saving session will still work correctly as a 10p adjustment on rates >100p will have little/no impact. rates_export_override: - start: '17:00:00' end: '19:00:00' rate_increment: -10 You can also use a similar but opposite approach of setting a positive export rate_increment to encourage Predbat to discharge the battery at certain time periods. If you have a very low overnight rate (such as Octopus Go) and want to ensure your battery is discharged just before the low rate period, but you don't want to risk the battery running out too early (and importing at a higher rate), you can add a rate export override for the period you want to discharge just before the low rate period: rates_export_override: - start: '22:30:00' end: '23:30:00' rate_increment: 10 You can also define an import_rate_override with start and end times and only load_scaling (without a rate_increment or rate), e.g. if you just want to apply load scaling to certain defined periods. date is optional and if specified must be in the date format of \"YYYY-MM-DD\" e.g. \"2023-09-09\". If a date is specified then the rate override applies to that specific date, otherwise, it applies to all dates start and end must be specified in \"HH:MM:SS\" time format e.g. \"12:30:00\" load_scaling is an optional percentage change factor in house load for the period - 1.0 would be no change, 0.8 is 80% of nominal house load, 2.0 would be a 100% increase (i.e. 2x) on normal historic house load rate is an optional figure in pence to override the rate for the specific period rate_increment is optional and is the number of pence to add (or subtract) to the reported energy rates during this period Rate offsets If you are on an Agile or Tracker tariff you can tune future unknown energy rates by adjusting the entities input_number.predbat_metric_future_rate_offset_import ( expert mode ) and input_number.predbat_metric_future_rate_offset_export ( expert mode ) inside Home Assistant to set the predicted offset for future unknown rates. Future Agile energy rates In the energy market, it's possible to calculate the Octopus Agile rates from around 10am UK time using public data, you can enable this in apps.yaml for Import, Export or both. This will approximate the next day's rates based on the spot prices. The approximation is only used until the real Octopus Agile rates are released around 4pm. futurerate_url - URL of future energy market prices; this should not normally need to be changed futurerate_adjust_import and futurerate_adjust_export - Whether tomorrow's predicted import or export prices should be adjusted based on energy market prices or not. Set these depending on whether you have an agile tariff for import, export or both futurerate_peak_start and futurerate_peak_end - during the peak period Octopus applies an additional peak-rate price adjustment. These configuration items enable the peak-rate hours to be adjusted CAUTION: You may violate the terms and conditions of the Nordpool site if you use this data and as such the authors of Predbat accepts no responsibility for any violations: https://www.nordpoolgroup.com/en/About-us/terms-and-conditions-for-useofwebsite/ futurerate_url: 'https://dataportal-api.nordpoolgroup.com/api/DayAheadPrices?date=DATE&market=N2EX_DayAhead&deliveryArea=UK&currency=GBP' futurerate_adjust_import: True futurerate_adjust_export: False futurerate_peak_start: \"16:00:00\" futurerate_peak_end: \"19:00:00\" Axle VPP Axle in the UK provide a Virtual Power Plant (VPP) service to the National Grid. In times of strain in the energy grid, Axle will command inverters to export, and in return you get paid \u00a31/kWh. If you sign up to the Axle VPP service (currently only available for Fox, GivEnergy and SigEnergy inverters), Predbat can automatically retrieve details of the Axle event and include the necessary export within the Predbat plan. You should sign up for the Axle 'Events Only' service, not 'Full Control' which provides a service similar to Predbat (except not as good of course !) Once signed up to Axle, Predbat's Axle Energy VPP component polls the Axle API to obtain details of future events and add Axle event details to binary_sensor.predbat_axle_event . The following configuration options for the Axle VPP can be set in apps.yaml : axle_api_key - Sets your API key to communicate with the Axle Energy VPP (Virtual Power Plant) service axle_pence_per_kwh - Sets the payment rate in pence per kWh for Axle Energy VPP events (optional, default: 100) axle_automatic - When True (default) Predbat will automatically use binary_sensor.predbat_axle_event to record details of current and historic Axle events axle_session - Optional, enables you to manually configure the Axle binary sensor name if you don't wish to use the Predbat default name axle_control - Optional, when set to True will set Predbat into Read-Only mode for the duration of the Axle session so Axle can control your inverter. The Predbat status will show \"Read-Only (Axle)\" when this is active in an Axle session. Defaults to False so Predbat will control export of your inverter according to the Axle event details. To use the Axle VPP service only axle_api_key is required to be configured in apps.yaml , the other configuration options are optional. Grid Carbon intensity Predbat can also track Carbon intensity by linking it to an integration which provides this data. UK Grid Carbon intensity The National Grid provides this data, you can have Predbat fetch it directly by entering your postcode: # Carbon Intensity data from National grid carbon_postcode: 'SW1 5NA' carbon_automatic: True This direct connection will also set sensor.predbat_carbon with the current carbon data. By enabling switch.predbat_carbon_enable you can view Carbon Intensity in the predbat plan . Predbat can also optimise your grid charging based on the Carbon footprint by setting input_number.predbat_carbon_metric . UK Grid Carbon intensity (HA Integration) If you prefer you can instead install this integration: https://github.com/jfparis/sensor.carbon_intensity_uk . There have been reports that this integration might not be working any more. Once it is active update apps.yaml to link Predbat to the Sensor (if it's not already in your template): # Carbon Intensity data from National grid carbon_intensity: 're:(sensor.carbon_intensity_uk)'","title":"Energy rates"},{"location":"energy-rates/#energy-rates","text":"Predbat needs to know what your Import and (optionally) Export rates are so it can plan the optimal way to use your battery. Your Import and Export rates can be simple flat rates, more complex time-of-day tariffs (e.g. Economy 7, Octopus Flux), or daily/half-hourly/quarter-hour rates that track electricity market prices (e.g. Octopus Agile or Tracker). Energy rates are all configured in the apps.yaml file that's stored in a directory name that depends on what type of Predbat installation method you have used . You will need to use a file editor within Home Assistant (e.g. either the File editor or Studio Code Server apps) to edit this file - see editing configuration files within Home Assistant if you need to install an editor. There are four different ways of configuring your Energy rates in apps.yaml , using Octopus Energy Direct , using the Octopus Energy Integration , using Octopus Rates URL's , or manually defining your rates and time periods . At least one of these methods must be used to define your import and export rates. If you don't then Predbat will assume zero for your energy rates.","title":"Energy rates"},{"location":"energy-rates/#plan-interval","text":"By default Predbat will plan and execute its plan based upon 30 minute time intervals. Energy rates need to be provided that align to :30 and :00 minutes past the hour. If your energy provider prices on the basis of smaller (or larger) intervals then the 30 minute interval duration can be overwritten by setting in apps.yaml : plan_interval_minutes: duration","title":"Plan Interval"},{"location":"energy-rates/#octopus-energy-direct","text":"If your electricity supplier is Octopus Energy then the simplest way to provide Predbat with your electricity pricing information is to connect Predbat directly to Octopus. This method will not work correctly if you have multiple import or export meters. A single Octopus Intelligent GO car charger or car is supported and Predbat will plan your battery charging based on iGo sessions. Saving sessions are also supported, including Predbat auto-enrolling you to them (note you must be joined to both the Octopus Octopoints and then the Saving Sessions schemes beforehand). You should first log into your Octopus account and go to the Accounts section and copy your Octopus account number e.g. A-1234567 . Then go to the API Access page , click 'regenerate API key' and copy your API key e.g. sk_live_1as12355... Put these both into your apps.yaml and you are done. octopus_api_account: 'XXXXXXXX' octopus_api_key: 'sk_live_yyyyyyyy'","title":"Octopus Energy direct"},{"location":"energy-rates/#octopus-free-energy-sessions","text":"Predbat can obtain details of Free energy sessions directly from the Octopus Web Site. As Octopus do not publish an API for this information it has to be done by 'scraping' the website - there may be future issues with this if Octopus ever change the website format. If you enable free energy sessions in Predbat then sessions will be considered even if you forget to sign-up to them in your Octopus account so be careful! octopus_free_url: 'http://octopus.energy/free-electricity'","title":"Octopus Free energy sessions"},{"location":"energy-rates/#octopus-energy-home-assistant-integration","text":"","title":"Octopus Energy Home Assistant Integration"},{"location":"energy-rates/#octopus-energy-integration-setup","text":"Instead of using Octopus Energy Direct method, Predbat can also work with the Octopus Energy integration , this brings greater configurability than the direct method. The Octopus Energy integration connects to your Octopus Energy account and retrieves the tariffs you are on, and the current tariff rates. If you change tariff within Octopus the integration will automatically retrieve the updated tariff information, and as tariff prices change, again they are automatically retrieved. The integration also provides support for Intelligent Octopus charging to support (multiple) car charging. Follow the instructions provided in the Octopus Energy integration documentation to install and set up the integration. Once installed, you will need to configure the integration (go to Settings / Devices & Services / Integrations / Octopus Energy then click 'Configure') and provide the integration with your 'Octopus API key' (that you obtain from your Octopus account: Personal Details / API access). CAUTION To get detailed energy rates needed by Predbat you need to go into Home Assistant and manually enable the following Octopus Energy events which are disabled by default when the integration is installed: event.octopus_energy_electricity_xxxxxxxx_previous_day_rates event.octopus_energy_electricity_xxxxxxxx_current_day_rates event.octopus_energy_electricity_xxxxxxxx_next_day_rates event.octopus_energy_electricity_xxxxxxxx_export_previous_day_rates event.octopus_energy_electricity_xxxxxxxx_export_current_day_rates event.octopus_energy_electricity_xxxxxxxx_export_next_day_rates event.octopus_energy_gas_xxxxxxxx_previous_day_rates event.octopus_energy_gas_xxxxxxxx_current_day_rates event.octopus_energy_gas_xxxxxxxx_next_day_rates To enable the above events: Go to Settings / Devices & Services / Integrations, choose Octopus Energy, then xx entities You will see a list of entities (and events) supplied by the Octopus integration Click the 'Filter' symbol on the top right-hand corner (a series of lines in a downwards pointing arrow) and make sure all the options are selected Then in the left-hand-side search entities box, type \"current_day\" Click on the first event that comes up, check the name is the right one Click the cog wheel, then you should see the option to enable the event Click the option to enable the event and press 'Update' to make the change Repeat this for the other events. The gas rates are only required if you have a gas boiler, and an iBoost, and are using Predbat to determine whether it's cheaper to heat your hot water with the iBoost or via gas Verify that the integration is working correctly in Home Assistant by going to 'Settings' / 'Developer Tools' / 'States', and entering 'octopus' in the 'Filter entities' box. Confirm that the Octopus entities are being populated correctly.","title":"Octopus Energy integration setup"},{"location":"energy-rates/#configuring-predbat-to-use-the-octopus-energy-integration","text":"The following configuration items in apps.yaml are used to configure Predbat to use the Octopus Energy integration. They are set to a regular expression and should be auto-discovered so that Predbat automatically uses the Octopus Energy integration, but you can comment out the regular expression lines to disable, or you set them manually. metric_octopus_import - Import rates from the Octopus Energy integration, should point to the sensor sensor.octopus_energy_electricity_METER_NUMBER_current_rate metric_octopus_export - Export rates from the Octopus Energy integration, should point to the sensor sensor.octopus_energy_electricity_METER_NUMBER_export_current_rate metric_octopus_gas - Gas rates from the Octopus Energy integration, should point to the sensor sensor.octopus_energy_gas_METER_NUMBER_current_rate octopus_intelligent_slot - If you have the Octopus Intelligent Go tariff this should point to the 'slot' sensor binary_sensor.octopus_energy_DEVICE_ID_intelligent_dispatching metric_octopus_gas is (as above) only required to be configured if you are using Predbat to determine whether to heat your hot water via your iBoost or gas. If you do not have an export rate or are not on the Octopus Go tariff, then the appropriate lines can be commented out in apps.yaml. NOTE: Predbat using the Octopus integration rates relies upon the day rate events being enabled (see above) and the events and the sensor found by metric_octopus_xxx in apps.yaml being similarly named. There have been occasions with some Octopus Integration installations where the event name is as above but the sensor name has a different prefix, e.g. sensor.electricity_METER_NUMBER_current_rate and not sensor.octopus_energy_electricity_METER_NUMBER_current_rate. If this is the case then the sensor must be renamed to the correct format so that Predbat can function correctly.","title":"Configuring Predbat to use the Octopus Energy integration"},{"location":"energy-rates/#standing-charge","text":"Predbat can also (optionally) include the daily standing charge in cost predictions. The following configuration item in apps.yaml defaults to obtaining the standing charge from the Octopus Energy integration: metric_standing_charge - Standing charge in pounds. By default points to the Octopus Energy integration sensor sensor.octopus_energy_electricity_METER_NUMBER_current_standing_charge You can manually change this to a standing charge in pounds, e.g. 0.50 is 50p, or delete this line from apps.yaml, or set it to zero if you don't want the standing charge (and only have consumption usage) to be included in Predbat charts and output data. Note that this configuration option to suppress the standing charge only applies if you are using the Octopus Integration from Predbat. If you are using the Octopus Energy direct method of Predbat directly connecting to Octopus then the standing charge will always be included in the plan and charts.","title":"Standing charge"},{"location":"energy-rates/#octopus-saving-sessions","text":"Predbat can automatically join you to Octopus saving sessions and plan battery activity for the saving session period to maximise your income. Note: You must have signed up to both the Octopus Octoplus and then the Saving Session schemes to benefit from these events For Predbat to automatically manage Octopus saving sessions the following additional configuration item in apps.yaml is used. Like the electricity rates, this is set in the apps.yaml template to a regular expression that should auto-discover the Octopus Energy integration. octopus_saving_session - Indicates if a saving session is active, should point to the sensor binary_sensor.octopus_energy_ACCOUNT_ID_octoplus_saving_sessions. When a saving session is available it will be automatically joined by Predbat and should then appear as a joined session within the next 30 minutes. NOTE: Predbat automatically joining the saving session relies upon the event being enabled and Predbat being able to find the saving session event as 'event.octopus_energy_ACCOUNT_ID_octoplus_saving_session_events' - there have been occasions with some Octopus Integration installations where the event name is different. If this is the case then the event must be renamed to the correct format that Predbat can function correctly. In the Predbat plan, for joined saving sessions the energy rates for import and export will be overridden by adding the assumed saving rate to your normal rate. The assumed rate will be taken from the Octopus Energy integration and converted into pence using the octopus_saving_session_octopoints_per_penny configuration item in apps.yaml (default is 8). If you normally cut back your house usage during a saving session then you can change input_number.predbat_load_scaling_saving to allow Predbat to assume an energy reduction in this period. E.g. setting to a value of 0.8 would indicate you will use 80% of the normal consumption in that period (a 20% reduction). As the saving session import and export rates are very high compared to normal Predbat will plan additional export during the saving session period. If necessary, a pre-charge may happen at some point during the day to maintain the battery right level for the session. Note that Predbat's operational mode select.predbat_mode must be set to either 'Control charge' or 'Control charge & discharge' for Predbat to be able to manage the battery for the saving session. If you do not have an export tariff then forced export will not apply and Predbat will just ensure you have enough battery charge to see you through the saving session period. If you do not want Predbat to automatically join Octopus saving sessions and manage your battery activity for the session, simply delete or comment out the octopus_saving_session entry in apps.yaml .","title":"Octopus Saving sessions"},{"location":"energy-rates/#octopus-free-power-up-events","text":"Predbat can automatically detect Octopus free events and adjust your battery plan according. Note that this is derived from external sources, which do not verify your eligibility for free sessions. For Predbat to automatically manage Octopus free sessions the following additional configuration item in apps.yaml is used. Note: You must have signed up to the Octopus Octoplus scheme and eligible to benefit from these events Like the electricity rates, this is set in the apps.yaml template to a regular expression that should auto-discover the Octopus Energy integration. octopus_free_session - Will point to the free event sensor that is exposed by the Octopus Energy Integration. This event sensor contains the dates/times of all the free events. octopus_free_session: 're:(event.octopus_energy_([0-9a-z_]+|)_octoplus_free_electricity_session_events)' Note: This event may need to be enabled in Home Assistant first - see How to Enable Octopus events If you normally increase your house usage during a free session then you can change input_number.predbat_load_scaling_free to allow Predbat to assume an energy increase in this period. E.g. setting to a value of 1.2 would indicate you will use 20% more energy than normal during this period. (Default is 1.2) If you do not want Predbat to see these sessions then comment out the octopus_free_session setting. Note: If the above is not working due to a lack of data (via a 3rd party service) Predbat can scrape directly from the Octopus Web Site, this may not work in future if Octopus ever change the website format. If you enable this then sessions will be considered by Predbat even if you forget to sign-up to free electricity sessions in your Octopus account so be careful! octopus_free_url: 'http://octopus.energy/free-electricity'","title":"Octopus free (power up) events"},{"location":"energy-rates/#octopus-rates-url","text":"As an alternative to the Octopus Direct or Octopus Energy integration methods, for Octopus Energy customers, you can configure Predbat to get the electricity rates directly online from the Octopus website. In apps.yaml configure the following lines: rates_import_octopus_url to point to the appropriate import tariff URL on the Octopus website rates_export_octopus_url to point to the export tariff URL e.g. (for DNO region A) rates_import_octopus_url : \"https://api.octopus.energy/v1/products/FLUX-IMPORT-23-02-14/electricity-tariffs/E-1R-FLUX-IMPORT-23-02-14-A/standard-unit-rates\" rates_import_octopus_url : \"https://api.octopus.energy/v1/products/AGILE-24-10-01/electricity-tariffs/E-1R-AGILE-24-10-01-A/standard-unit-rates\" rates_export_octopus_url: \"https://api.octopus.energy/v1/products/FLUX-EXPORT-23-02-14/electricity-tariffs/E-1R-FLUX-EXPORT-23-02-14-A/standard-unit-rates\" rates_export_octopus_url: \"https://api.octopus.energy/v1/products/AGILE-OUTGOING-19-05-13/electricity-tariffs/E-1R-AGILE-OUTGOING-19-05-13-A/standard-unit-rates/\" If you configure the rates_import_octopus_url then Predbat will use this instead of metric_octopus or rates_import. Similarly, rates_export_octopus_url takes precedence over metric_octopus_export or rates_export. A full list of available Octopus products is at https://api.octopus.energy/v1/products/ . If you view this page, search for the tariff by name, then copy the URL it shows into a new tab. E.g. https://api.octopus.energy/v1/products/GO-VAR-22-10-14/ Look through that page to find the right URL for usage charges in your DNO area https://api.octopus.energy/v1/products/GO-VAR-22-10-14//electricity-tariffs/E-1R-GO-VAR-22-10-14-A/standard-unit-rates (For area A) Configuring the Octopus rates URL is an expert feature as Octopus change the available products from time to time, so for most users, the Octopus Direct or Octopus Energy integration are simpler solutions.","title":"Octopus Rates URL"},{"location":"energy-rates/#energidataservice-integration","text":"https://github.com/MTrab/energidataservice If your electricity supplier provides data through the Energi Data Service, you can use the Energidataservice integration to fetch real-time and future electricity pricing data. This integration allows you to automatically retrieve rates and apply them within your energy management system, including optional tariff adjustments for greater accuracy. The integration processes hourly pricing data and converts it into (by default) 30-minute intervals, making it ideal for scheduling and optimising energy usage.","title":"Energidataservice Integration"},{"location":"energy-rates/#configuring-predbat-to-use-the-energidataservice-integration","text":"The following configuration items in apps.yaml are used to configure Predbat to use the Energidataservice integration. These items must be set explicitly to ensure that Predbat retrieves the correct import and export rates. metric_energidataservice_import - Import rates from the Energidataservice integration. This should point to the sensor that provides hourly import rates, such as sensor.energi_data_service. metric_energidataservice_export - Export rates from the Energidataservice integration. This should point to the sensor that provides hourly export rates (e.g., solar feed-in rates), such as sensor.energi_data_service_export.","title":"Configuring Predbat to Use the Energidataservice Integration"},{"location":"energy-rates/#other-energy-spot-rate-sensor-integrations","text":"Different spot rate integrations that include forecast prices may be used. Because integrations format their attribute data differently, a template sensor is required to convert the attribute data into a new sensor with the correctly formatted attributes: raw_today and raw_tomorrow. metric_octopus_import: 'sensor.current_buy_electricity_price_raw' metric_octopus_export: 'sensor.current_sell_electricity_price_raw'","title":"Other Energy Spot Rate sensor integrations"},{"location":"energy-rates/#czech-republic-example","text":"https://github.com/rnovacek/homeassistant_cz_energy_spot_prices {% set attributes = states.sensor.current_buy_electricity_price.attributes %} {% set datetime_dict = zip(attributes.keys() | map('as_datetime', default={}), attributes.values()) | selectattr(0, 'datetime') %} {% set ns = namespace(output=[]) %} {% for start_time, price in datetime_dict %} {% if start_time < today_at() + timedelta(days=1) %} {% set ns.output = ns.output + [{'start': start_time.isoformat(), 'end': (start_time + timedelta(hours=1)).isoformat(), 'value': price | round(5)}] %} {% endif %} {% endfor %} {{ns.output | sort(attribute='start') }} Full code for CZ energy spot rate template: https://gist.github.com/ziat007/ae29e26ae257f069520b65f0168c3a6b","title":"Czech Republic example"},{"location":"energy-rates/#frank-energie-export-rates-with-export-fee","text":"The Frank Energie integration provides import and export rates for Frank Energie customers in the Netherlands. However the integration provides only the market rates and does not include the export fixed fee of 0.0115 per kWh. A template sensor can be used to manipulate the rates provided by the integration and add the required fee: # Export to Grid Payment - name: \"Frank export price schedule (\u20ac/kWh)\" unique_id: frank_export_price_schedule_eur_kwh unit_of_measurement: \"\u20ac/kWh\" icon: mdi:currency-eur state_class: measurement state: > {% set src = 'sensor.frank_energie_prices_current_electricity_market_price' %} {% set fee = states('input_number.frank_export_fee_eur_per_kwh') | float(0.0115) %} {% set arr = state_attr(src, 'prices') or [] %} {% set now_ = now() %} {% set price = states(src) | float(0) %} {% for b in arr %} {% if now_ >= as_datetime(b['from']) and now_ < as_datetime(b['till']) %} {% set price = b['price'] | float(0) %} {% endif %} {% endfor %} {{ (price - fee) | round(5) }} attributes: prices: > {% set src = 'sensor.frank_energie_prices_current_electricity_market_price' %} {% set fee = states('input_number.frank_export_fee_eur_per_kwh') | float(0.0115) %} {% set arr = state_attr(src, 'prices') or [] %} {% set out = namespace(list=[]) %} {% for b in arr %} {% set p = (b['price'] | float(0)) - fee %} {% set item = {'from': b['from'].strftime('%Y-%m-%dT%H:%M:%S%z'), 'till': b['till'].strftime('%Y-%m-%dT%H:%M:%S%z'), 'price': (p | round(5))} %} {% set out.list = out.list + [item] %} {% endfor %} {{ out.list | tojson }}","title":"Frank Energie Export rates with export fee"},{"location":"energy-rates/#rate-bands-to-manually-configure-energy-rates","text":"If you are not an Octopus Energy customer, or you are but your energy rates repeat simply, you can configure your rate bands in apps.yaml using rates_import/rates_export/rates_gas. Add the following entries to apps.yaml to define the pattern of rates over 24 hours: rates_import: - start: \"HH:MM:SS\" end: \"HH:MM:SS\" rate: pence rates_export: - start: \"HH:MM:SS\" end: \"HH:MM:SS\" rate: pence rates_gas: - start: \"HH:MM:SS\" end: \"HH:MM:SS\" rate: pence start and end are in the time format of \"HH:MM:SS\" e.g. \"12:30:00\" and should be aligned to 30 minute slots normally, i.e. end with \":30:00\" or \":00:00\". If you have set a different plan interval duration for your energy provider, e.g. 15 minute intervals, then make sure the start and end times align with the interval periods. The start and end times for the different rates must cover the whole 24 hour period with no gaps! rate is in pence e.g. 4.2 day_of_week Can also be used to control rates on specific days. You can specify one day or multiple days split by a comma. Note: Day 1 = Monday, 2 = Tuesday .... 7 = Sunday e.g: rates_import: - rate: 15 day_of_week: \"1,2,3,4,5\" - rate: 10 day_of_week: \"6,7\" start and end can be omitted and Predbat will assume that you are on a single flat-rate tariff. If there are any gaps in the 24-hour period then a zero rate will be assumed. The gas rates are only required if you have a gas boiler, or an iBoost, and are using Predbat to determine whether it's cheaper to heat your hot water with the iBoost or via gas.","title":"Rate Bands to manually configure Energy Rates"},{"location":"energy-rates/#manually-over-riding-energy-rates","text":"You can also override the import or export energy rates (regardless of whether they are set manually or via the Octopus Energy integration) by using the override feature in apps.yaml. Rate override is used to set the specific date and time period where your rates are different, e.g. an Octopus Power Up session (zero rate for an hour or two), or the British Gas half-price electricity on Sundays. Unfortunately, there aren't any API's available to feed this information automatically into Predbat so you will have to define your own input controls and use the Predbat Manual API , or edit apps.yaml manually to set the appropriate rate over-ride dates and times: rates_import_override: - date: \"YYYY-MM-DD\" start: \"HH:MM:SS\" end: \"HH:MM:SS\" rate: pence rates_export_override: - date: \"YYYY-MM-DD\" start: \"HH:MM:SS\" end: \"HH:MM:SS\" rate: pence Optionally you can add a predicted load scaling factor for these periods using load_scaling , for example: rates_import_override: - date: '2024-01-21' start: '17:30:00' end: '18:30:00' rate: 150 load_scaling: 0.8 This instructs Predbat that during a 1-hour period at 5:30-6:30pm on 21st of Jan set the import rate to 150p and assume our load will be 80% of normal (20% lower). You can also make relative adjustments to your energy rates, e.g. if you want to avoid exporting during peak periods to improve your energy saving session results you could make a relative adjustment to your export rates using rate_increment . The reason not to just set rate is that when an energy saving session is active you do not want to ignore the higher export rate that is automatically provided by Octopus. In this example we subtract 10p from our export rate during the period that saving sessions normally fall within and thus steer Predbat away from force exporting during that time. The saving session will still work correctly as a 10p adjustment on rates >100p will have little/no impact. rates_export_override: - start: '17:00:00' end: '19:00:00' rate_increment: -10 You can also use a similar but opposite approach of setting a positive export rate_increment to encourage Predbat to discharge the battery at certain time periods. If you have a very low overnight rate (such as Octopus Go) and want to ensure your battery is discharged just before the low rate period, but you don't want to risk the battery running out too early (and importing at a higher rate), you can add a rate export override for the period you want to discharge just before the low rate period: rates_export_override: - start: '22:30:00' end: '23:30:00' rate_increment: 10 You can also define an import_rate_override with start and end times and only load_scaling (without a rate_increment or rate), e.g. if you just want to apply load scaling to certain defined periods. date is optional and if specified must be in the date format of \"YYYY-MM-DD\" e.g. \"2023-09-09\". If a date is specified then the rate override applies to that specific date, otherwise, it applies to all dates start and end must be specified in \"HH:MM:SS\" time format e.g. \"12:30:00\" load_scaling is an optional percentage change factor in house load for the period - 1.0 would be no change, 0.8 is 80% of nominal house load, 2.0 would be a 100% increase (i.e. 2x) on normal historic house load rate is an optional figure in pence to override the rate for the specific period rate_increment is optional and is the number of pence to add (or subtract) to the reported energy rates during this period","title":"Manually over-riding energy rates"},{"location":"energy-rates/#rate-offsets","text":"If you are on an Agile or Tracker tariff you can tune future unknown energy rates by adjusting the entities input_number.predbat_metric_future_rate_offset_import ( expert mode ) and input_number.predbat_metric_future_rate_offset_export ( expert mode ) inside Home Assistant to set the predicted offset for future unknown rates.","title":"Rate offsets"},{"location":"energy-rates/#future-agile-energy-rates","text":"In the energy market, it's possible to calculate the Octopus Agile rates from around 10am UK time using public data, you can enable this in apps.yaml for Import, Export or both. This will approximate the next day's rates based on the spot prices. The approximation is only used until the real Octopus Agile rates are released around 4pm. futurerate_url - URL of future energy market prices; this should not normally need to be changed futurerate_adjust_import and futurerate_adjust_export - Whether tomorrow's predicted import or export prices should be adjusted based on energy market prices or not. Set these depending on whether you have an agile tariff for import, export or both futurerate_peak_start and futurerate_peak_end - during the peak period Octopus applies an additional peak-rate price adjustment. These configuration items enable the peak-rate hours to be adjusted CAUTION: You may violate the terms and conditions of the Nordpool site if you use this data and as such the authors of Predbat accepts no responsibility for any violations: https://www.nordpoolgroup.com/en/About-us/terms-and-conditions-for-useofwebsite/ futurerate_url: 'https://dataportal-api.nordpoolgroup.com/api/DayAheadPrices?date=DATE&market=N2EX_DayAhead&deliveryArea=UK&currency=GBP' futurerate_adjust_import: True futurerate_adjust_export: False futurerate_peak_start: \"16:00:00\" futurerate_peak_end: \"19:00:00\"","title":"Future Agile energy rates"},{"location":"energy-rates/#axle-vpp","text":"Axle in the UK provide a Virtual Power Plant (VPP) service to the National Grid. In times of strain in the energy grid, Axle will command inverters to export, and in return you get paid \u00a31/kWh. If you sign up to the Axle VPP service (currently only available for Fox, GivEnergy and SigEnergy inverters), Predbat can automatically retrieve details of the Axle event and include the necessary export within the Predbat plan. You should sign up for the Axle 'Events Only' service, not 'Full Control' which provides a service similar to Predbat (except not as good of course !) Once signed up to Axle, Predbat's Axle Energy VPP component polls the Axle API to obtain details of future events and add Axle event details to binary_sensor.predbat_axle_event . The following configuration options for the Axle VPP can be set in apps.yaml : axle_api_key - Sets your API key to communicate with the Axle Energy VPP (Virtual Power Plant) service axle_pence_per_kwh - Sets the payment rate in pence per kWh for Axle Energy VPP events (optional, default: 100) axle_automatic - When True (default) Predbat will automatically use binary_sensor.predbat_axle_event to record details of current and historic Axle events axle_session - Optional, enables you to manually configure the Axle binary sensor name if you don't wish to use the Predbat default name axle_control - Optional, when set to True will set Predbat into Read-Only mode for the duration of the Axle session so Axle can control your inverter. The Predbat status will show \"Read-Only (Axle)\" when this is active in an Axle session. Defaults to False so Predbat will control export of your inverter according to the Axle event details. To use the Axle VPP service only axle_api_key is required to be configured in apps.yaml , the other configuration options are optional.","title":"Axle VPP"},{"location":"energy-rates/#grid-carbon-intensity","text":"Predbat can also track Carbon intensity by linking it to an integration which provides this data.","title":"Grid Carbon intensity"},{"location":"energy-rates/#uk-grid-carbon-intensity","text":"The National Grid provides this data, you can have Predbat fetch it directly by entering your postcode: # Carbon Intensity data from National grid carbon_postcode: 'SW1 5NA' carbon_automatic: True This direct connection will also set sensor.predbat_carbon with the current carbon data. By enabling switch.predbat_carbon_enable you can view Carbon Intensity in the predbat plan . Predbat can also optimise your grid charging based on the Carbon footprint by setting input_number.predbat_carbon_metric .","title":"UK Grid Carbon intensity"},{"location":"energy-rates/#uk-grid-carbon-intensity-ha-integration","text":"If you prefer you can instead install this integration: https://github.com/jfparis/sensor.carbon_intensity_uk . There have been reports that this integration might not be working any more. Once it is active update apps.yaml to link Predbat to the Sensor (if it's not already in your template): # Carbon Intensity data from National grid carbon_intensity: 're:(sensor.carbon_intensity_uk)'","title":"UK Grid Carbon intensity (HA Integration)"},{"location":"faq/","text":"FAQ I've installed Predbat but I don't see the correct entities First look at predbat.status in Home Assistant and the Predbat/AppDaemon app log (which can be found in the list of log files in the System/Log area of the GUI). See if any errors are warnings are found. If you see an error something is likely configured incorrectly, check your entity settings are correct. Make sure Solcast is installed and it's auto-updated at least a couple of times a day (see the Solcast instructions ). The default Solcast sensor names may be wrong, you might need to update the apps.yaml config to match your own names (some people don't have the solcast_ bit in their names) Predbat is failing with Warn: Service call select/select_option data failed Here's an example error message: 2026-01-14 15:10:43.706153: Warn: Service call select/select_option data {'option': '17:00:00', 'entity_id': 'select.predbat_fox_603j303046yp036_battery_schedule_charge_end_time'} failed This will happen if you have no actual selectors provided by integrations in Home Assistant before Predbat starts. You can workaround this by adding a dummy selector to configuration.yaml and restarting HA e.g: template: - select: - name: \"simple_select\" state: \"{{ states('input_select.my_input') }}\" # Current value options: \"{{ ['Option 1', 'Option 2', 'Option 3'] }}\" # Available options select_option: - service: input_select.select_option target: entity_id: input_select.my_input data: option: \"{{ option }}\" Why is my house load lower than expected, or zero? If your house load is unusually low in the Predbat plan, then its often due to Predbat excluding some of your house load. Are your load_today , import_today , export_today and pv_today entries in apps.yaml correctly configured and pointing to the right inverter/Home Assistant entities? Check the history of these entities, are there gaps in them or do the entities go down during the day rather than continually increment - these need to be resolved if they do not increment continually over the day and reset at midnight. Have you accidentally used a power sensor (W or kW) rather than a daily energy sensor (Wh or kWh)? In the logfile do you see car/iBoost energy being excluded, e.g. \"Today's predicted so far 19.0kWh with 3.2kWh car/iBoost excluded\"? If energy is being excluded and you have an EV/iBoost, have you configured the correct car_charging_energy energy sensor(s) to filter car charging energy in apps.yaml ? Do these sensors increment over the day or are there gaps or resets back to zero during the day? Use a daily utility meter to wrap around your EV charger sensor to provide Predbat with a sensor that doesn't do this. Depending on the wiring of your EV charger and inverter, the inverter may not 'see' the EV charging energy. If you configure car_charging_energy in apps.yaml then Predbat will be calculating an artificially low house load - turn switch.car_charging_hold off to stop this. If you don't have a sensor that provides car charging energy then Predbat will use input_number.predbat_car_charging_threshold as the threshold to detect car charging - adjust as necessary for your EV charger. If you don't have an EV charger then turn switch.car_charging_hold off as Predbat will still use input_number.predbat_car_charging_threshold and assume any house load above this is EV charging. Why is my predicted charge % higher or lower than I might expect? Predbat is based on cost, so it will try to save you money. If you have the PV 10% option enabled it will also take into account the worst-case scenario and how often it might happen, so if the forecast is a bit unreliable it's better to charge more and not risk getting stung importing. Have you checked your energy rates for import and export are correct, maybe check the rates graph and confirm. If you do something like have export>import then Predbat will try to export as much as possible. Have you tuned Solcast to match your output accurately? Have you tuned predbat_best_soc_keep settings ? Do you have predicted car charging during the time period? You can also tune predbat_load_scaling and predbat_pv_scaling to adjust predictions up and down a bit Why didn't the slot get configured? Are you in read-only mode? My plan doesn't include any charging? Do you have the predbat_mode set to Control charge (or Control charge & discharge)? The charge limit keeps increasing/decreasing in the charge window or is unstable Check you don't have any other automations running that adjust GivTCP settings during this time. Some people had a script that changes the reserve %, this will cause problems - please disable other automations and retry. I changed a config item but it made no difference? You might have to wait a few minutes until the next update cycle. Depending on the speed of the computer that Predbat is running on, it can take 1-5 minutes for Predbat to run through. You can see the date/time that Predbat last completed a run at the start of the Predbat HTML plan . It's all running but I'm not getting very good results You might want to tune input_number.predbat_best_soc_keep to set a minimum target battery level, e.g. I use 2.0 (for 2kWh, which is just over 20% on a 9.5kWh battery). If you set input_number.predbat_best_soc_keep too high then Predbat could need to charge the battery at unfavourable import rates, so try to set it to a fairly low value, especially if you have a small battery. If you set it to zero then Predbat may not charge at all, so use 0.1 as a minimum. Have a read of the energy rates configuration guide as depending on your tariff different settings may be required Check your solar production is well calibrated (you can compare Solcast vs actually in the Home Assistant energy tab or on the GivEnergy portal) Make sure your inverter max AC rate has been set correctly If you have an EV that you charge then you will want some sort of car charging sensor or use the basic car charging hold feature or your load predictions may be unreliable - see Car charging Do you have a solar diverter? If so maybe you want to try using the iBoost model settings . Perhaps set up the calibration chart and let it run for 24 hours to see how things line up If your export slots are too small compared to expected check your inverter_limit is set correctly (see below) In my power flow diagram my grid power is the wrong way around You may need to set ' grid_power_invert to True if your grid_power is positive when importing. My plan is freeze charging or holding at 100% battery a lot Round trip losses Round trip losses for charging the battery and then using it for your home are: charge loss x inverter loss x inverter loss x discharge loss The default is therefore: $0.97 * 0.96 * 0.96 * 0.97 \\approx 0.87$ (13%) If you freeze charge or hold at 100% then you will be using the grid which is 13% cheaper than using the battery at the same import rate. If you start increasing these losses to say 5% and 6% then you are getting to around 20% round trip losses. This means charging the battery at 20p is the same cost as using the grid at 25p. However, if you start setting metric_self_sufficiency then you are telling Predbat to try to import less when possible. If your round trip losses are 20% then using the grid directly will import 20% less energy than charging your battery. Therefore a 5p metric self-sufficiency will effectively add another 1p to this difference i.e. using the grid at 26p is now the same as charging the battery at 20p! If you set metric_battery_cycle to say 2p then that would add another 4p to using the battery so now charging at 20p would equate to using the grid at 30p! Bottom line, be careful how you configure things. When my battery is charging to 100% it fluctuates between 98% and 100%, and/or gives an error setting reserve Some inverters e.g. GE AIO inverter won't allow the reserve to be set to 100, in which case set in apps.yaml inverter_reserve_max : 98 And this should prevent the issue The plan doesn't charge or discharge when I expect it to Predbat can only work on the information it's given, although it does run every 5 minutes to execute the plan, and updates and re-evaluates the plan every 10 minutes, adjusting if necessary. The plan Predbat produces assumes that your average load and PV forecasts are accurate and Predbat will aim to give you the maximum return. Make sure you have set up your Solcast solar forecast correctly with the number of panels, orientation, output, etc. Projected daily load is determined from historical load information so make sure you have set days_previous and days_previous_weight in apps.yaml to give appropriately representative load history to Predbat, and read the longer explanation of how days_previous works . You could adjust input_number.predbat_load_scaling to 1.2 so the plan will incorporate 20% more expected load if you want to be more pessimistic about historical load, and input_number.predbat_pv_scaling to similarly adjust the PV forecast - these and other adjustment options are described in the Scaling and Weight options . It is very important to correctly set Predbat's Battery Loss Options and Battery Margins as these can have a huge and critical impact on the plan that Predbat generates. Predbat's default configuration values are the recommended starting values for most users but there is no single right set of configuration values for every user of Predbat, it depends on many factors and your personal preferences. Many users will need to customise and tweak their Predbat configuration to suit their needs. The SoC level that Predbat aims to keep in the battery input_number.predbat_best_soc_keep and the absolute minimum SoC level input_number.predbat_best_soc_min are the first things to check. If these are set too high then Predbat will charge at unfavourable rates to maintain the battery SoC. Conversely, if you find Predbat is letting the battery exhaust too early, set predbat_best_soc_keep to 1.0 so Predbat will aim to keep 1kWh available for unexpected load. Predbat performs a lowest-cost battery optimisation so a key part of deciding whether to charge, discharge or feed the house from the battery are the loss rates input_number.predbat_battery_loss , input_number.predbat_battery_loss_discharge and input_number.predbat_inverter_loss . Typical values could be 4, 4, 4 or 5, 5, 5. It is tempting to set these inverter loss figures lower to encourage Predbat to use the battery more, but this should be resisted as experience from the GivEnergy community forum suggests total energy conversion losses are in the range of 10-20%. Putting these losses into context and assuming you have an AC-coupled battery and have set the losses to 4, 4 and 4; then for every kWh charged from the grid, you will only get 0.92kWh stored in the battery (4% charge + 4% inverter conversion loss) and similarly when that 0.92kWh is discharged to the home you will only receive 0.85kWh (0.92 x 0.92). These loss percentages also impact the Predbat plan. Consider an import rate of 20p/kWh; after conversion losses are considered, each 1kWh of stored battery charge will in effect have cost 21.7p (20 / 0.92) to import. Then for discharging, the same applies. Each kWh of stored battery charge (that costs 21.7p to charge) will in effect have cost 23.6p (21.7 / 0.92) to discharge. Predbat makes cost optimisation decisions so unless the current import rate is more than 23.6p, it will be cheaper to let the home run off grid import rather than to discharge the battery. If you turn debug mode on for the Predbat plan then you can see the effective import and export rates after losses that Predbat calculates in the Predbat plan. Predbat also uses input_number.predbat_metric_battery_cycle ( expert mode setting) to apply a 'virtual cost' in pence per kWh for charging and discharging the battery. The default value is 1p but this this can be changed to a different value to recognise the 'cost of using the battery', or set to zero to disable this feature. So if the metric battery cycle is set to 1p, and continuing the example above, each kWh of battery charge will be costed at 22.7p (21.7p + 1p battery metric to charge), and the battery will not be discharged to support the home unless the current import rate is more than 25.6p (23.6p + 1p cost of charging + 1p cost to discharge). input_number.predbat_metric_min_improvement and input_number.predbat_metric_min_improvement_discharge (both expert mode settings) also affect Predbat's cost optimisation decisions as to whether it is cost beneficial to charge or discharge the battery so could be tweaked if you feel Predbat is charging or discharging with marginal benefits. The defaults (0p and 0.1p respectively) should however give good results for most users. Finally, it could be worth considering adding import or export rate increments to apps.yaml if you want to direct Predbat to avoid or encourage charging or discharging in certain time periods - e.g. avoiding exporting in the time period saving sessions normally fall in, or to encourage discharging just before import rates fall overnight. Predbat is causing warning messages about 'exceed maximum size' in the Home Assistant Core log If you have a large input_number.predbat_forecast_plan_hours then you may see warning messages in the Home Assistant Core log about the size of a number of Predbat entities, the message will be \"State attributes for predbat. XXXX exceed maximum size of 16384 bytes\". This is just a warning, the Predbat entity attributes aren't stored in the database anyway, but you can suppress these warnings by adding the following to your configuration.yaml file: # Filter out 'message too large' warnings from Predbat entities logger: default: warning filters: homeassistant.components.recorder.db_schema: - \"State attributes for predbat.base10_export_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.base10_import_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.base10_metric exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.base10_pv_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.battery_cycle exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.battery_cycle_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.battery_power exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.battery_power_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_charge_limit exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_export_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_import_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_load_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_metric exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_pv_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best10_export_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best10_import_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best10_metric exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best10_pv_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.cost_today_export exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.cost_today_import exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.cost_yesterday exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.export_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.grid_power exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.grid_power_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.import_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_energy_actual exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_energy_adjusted exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_energy_predicted exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_power exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_power_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.metric exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.plan_html exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.pv_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.pv_power exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.pv_power_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.rates exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.soc_kw exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.soc_kw_base10 exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.soc_kw_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.soc_kw_best10 exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" Error - metric_octopus_import not set correctly or no energy rates can be read If you get this error in the Predbat log file: Check that the Octopus integration is working and that event.octopus_energy_electricity_METER_NUMBER_current_day_rates and sensor.octopus_electricity_energy_METER_NUMBER_current_rate are both populated by the integration. Ensure that you have followed the Octopus Integration Installation instructions , including enabling the Octopus Integration events. If you have been using an older version of the Octopus integration and have upgraded to version 9 or above, then you may find that your energy sensors are named sensor.electricity_METER_NUMBER_current_rate (i.e. no 'octopus_energy_' prefix) but the 'event' entities have the 'octopus_energy' prefix. If the 'event' and 'sensor' entities are not consistently named then Predbat will not be able to find the event entities if the sensor names don't match what's expected. To fix this, uninstall the Octopus integration, reboot Home Assistant, delete all the old Octopus sensors, and re-install the Octopus Integration . WARN: No solar data has been configured If you get this warning message in the Predbat log file or you see that the 'PV kWh' column in the Predbat plan card is completely blank: Ensure that you have installed and configured Solcast correctly Check the Solcast integration in Home Assistant is configured and enabled (go to Settings / Integrations / Solcast ) Check that there are no errors relating to Solcast in the Home Assistant log (go to Settings / System / Logs and view the 'Home Assistant Core' log). If you see an error 429 message in the log then this is as a result of Solcast's rate limiting for Hobbyist accounts. The only fix is to re-run the 'Solcast update' automation and hope that Solcast isn't as busy when you re-run. Verify the solar forecast has been populated in Home Assistant by going to 'Settings' / 'Developer Tools' / 'States', filtering on 'solcast', and check that you can see the half-hourly solar forecasts in the Solcast entities If you can see the Solcast entities but there are no forecast PV figures, try running the 'Solcast update' automation you created, and check again the Solcast entities If the Solcast entities are still not populated, try reloading the Solcast integration (go to System / Devices & Services / Integrations tab, click on 'Solcast PV Forecast', click the three vertical dots beside 'Configure' and choose 'Reload' from the dropdown menu) Check sensor.solcast_pv_api_limit (it's normally 10 for new Solcast accounts) meaning you can call the Solcast API 10 times a day (but if you have two solar arrays, e.g. East/West) then retrieving the forecast will count as two API calls. Compare this to sensor.solcast_pv_api_used to see how many Solcast API calls you have made today (alternatively, you can confirm how many API calls you have made today by logging into your Solcast account). If you've run out of API calls you will have to wait until midnight GMT for the API count to reset. It's recommended that you don't include the Solcast forecast within your GivEnergy portal to avoid running out of API calls. Check the Solcast server API status is OK Note: Can not find battery charge curve If you get the message \"Note: Can not find battery charge curve, one of the required settings for soc_kw, battery_power and charge_rate are missing from apps.yaml\" in the logfile then Predbat tries to create a battery charge curve but does not have access to the required history information in Home Assistant. Creating the battery charge curve is described in the apps.yaml document. The most likely cause of the above message appearing in the logfile is that you are controlling a GivEnergy inverter in REST mode but have not uncommented the following entities in apps.yaml that Predbat needs to obtain history from to create the battery charge curve: charge_rate: - number.givtcp_{geserial}_battery_charge_rate discharge_rate: - number.givtcp_{geserial}_battery_discharge_rate battery_power: - sensor.givtcp_{geserial}_battery_power soc_kw: - sensor.givtcp_{geserial}_soc_kwh You should also check that all the entities Predbat highlights that it are using have history, and that the charging/discharging goes to full/empty as described in the battery curve documentation. WARN: Inverter is in calibration mode If you see the message \"WARN: Inverter is in calibration mode, Predbat will not function correctly and will be disabled\" in the logfile, then Predbat has identified that your inverter is currently calibrating your battery. Predbat's status will also be set to 'Calibration'. Predbat will set the inverter charge and discharge rates to maximum (if they are not already), SoC target to 100% and battery reserve to minimum (usually 4%), and will not execute the plan nor enable battery charge or discharge. Once the inverter finishes calibrating the battery, Predbat will resume normal operations. Inverter time is xxx, Predbat computer time is xxx, this is xxx minutes skewed, Predbat may not function correctly If the predbat.status gives a warning error about the inverter time: Then it indicates that there is a mismatch between the clock that Predbat is using and the inverter time clock, and clearly with a clock mismatch, charging and discharging your battery at specific times may not work as expected. There are several potential causes of this problem: Check that the inverter time is correctly set, especially that it is set to GMT (even if it's summertime). In the GivEnergy portal, go to My Inverters / Remote Control (cog symbol) / click SEND next to 'Set Date and Time' Check that the time_zone in appdaemon.yaml is correctly set for your location (e.g. Europe/London) The time zone for Predbat in apps.yaml needs to be set to the same value Finally, check how often your inverter integration is polling your inverter for new data. For GivTCP the Self Run Loop Timer is recommended to be set to a value of between 20 and 60 seconds. If you have checked the above and keep getting \u201ctime is skewed\u201d warnings then it means Home Assistant/predbat isn\u2019t getting the same time from the inverter as it is expecting. Either GivTCP has lost communications with the inverter or the inverter has stopped talking to the world. If you look at the Logbook in Home Assistant you should see a steady stream of entities changing in HA. In particular, you will see the GivTCP inverter time entity changing every polling period, e.g. every 20 seconds. Possible fixes: restart the GivTCP app restart Home Assistant (although usually restarting GivTCP is enough) power the inverter off, turn off the panels and battery first, then the inverter, then follow the reverse sequence to power the inverter back on again. This forces the inverter to reconnect to your wifi do a \u2018reset to defaults\u2019 in the portal If you keep getting the warning message, even sporadically, then this points to an underlying issue in your home network between Home Assistant and the inverter. You may need to add a Wi-Fi repeater or ideally a fixed Ethernet connection to your inverter to improve signal strength if this keeps happening. There is a Home Assistant automation that will alert you if GivTCP stops sending data to predbat . I have another problem not listed above If you are still having trouble feel free to raise a GitHub ticket for support","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#ive-installed-predbat-but-i-dont-see-the-correct-entities","text":"First look at predbat.status in Home Assistant and the Predbat/AppDaemon app log (which can be found in the list of log files in the System/Log area of the GUI). See if any errors are warnings are found. If you see an error something is likely configured incorrectly, check your entity settings are correct. Make sure Solcast is installed and it's auto-updated at least a couple of times a day (see the Solcast instructions ). The default Solcast sensor names may be wrong, you might need to update the apps.yaml config to match your own names (some people don't have the solcast_ bit in their names)","title":"I've installed Predbat but I don't see the correct entities"},{"location":"faq/#predbat-is-failing-with-warn-service-call-selectselect_option-data-failed","text":"Here's an example error message: 2026-01-14 15:10:43.706153: Warn: Service call select/select_option data {'option': '17:00:00', 'entity_id': 'select.predbat_fox_603j303046yp036_battery_schedule_charge_end_time'} failed This will happen if you have no actual selectors provided by integrations in Home Assistant before Predbat starts. You can workaround this by adding a dummy selector to configuration.yaml and restarting HA e.g: template: - select: - name: \"simple_select\" state: \"{{ states('input_select.my_input') }}\" # Current value options: \"{{ ['Option 1', 'Option 2', 'Option 3'] }}\" # Available options select_option: - service: input_select.select_option target: entity_id: input_select.my_input data: option: \"{{ option }}\"","title":"Predbat is failing with Warn: Service call select/select_option data failed"},{"location":"faq/#why-is-my-house-load-lower-than-expected-or-zero","text":"If your house load is unusually low in the Predbat plan, then its often due to Predbat excluding some of your house load. Are your load_today , import_today , export_today and pv_today entries in apps.yaml correctly configured and pointing to the right inverter/Home Assistant entities? Check the history of these entities, are there gaps in them or do the entities go down during the day rather than continually increment - these need to be resolved if they do not increment continually over the day and reset at midnight. Have you accidentally used a power sensor (W or kW) rather than a daily energy sensor (Wh or kWh)? In the logfile do you see car/iBoost energy being excluded, e.g. \"Today's predicted so far 19.0kWh with 3.2kWh car/iBoost excluded\"? If energy is being excluded and you have an EV/iBoost, have you configured the correct car_charging_energy energy sensor(s) to filter car charging energy in apps.yaml ? Do these sensors increment over the day or are there gaps or resets back to zero during the day? Use a daily utility meter to wrap around your EV charger sensor to provide Predbat with a sensor that doesn't do this. Depending on the wiring of your EV charger and inverter, the inverter may not 'see' the EV charging energy. If you configure car_charging_energy in apps.yaml then Predbat will be calculating an artificially low house load - turn switch.car_charging_hold off to stop this. If you don't have a sensor that provides car charging energy then Predbat will use input_number.predbat_car_charging_threshold as the threshold to detect car charging - adjust as necessary for your EV charger. If you don't have an EV charger then turn switch.car_charging_hold off as Predbat will still use input_number.predbat_car_charging_threshold and assume any house load above this is EV charging.","title":"Why is my house load lower than expected, or zero?"},{"location":"faq/#why-is-my-predicted-charge-higher-or-lower-than-i-might-expect","text":"Predbat is based on cost, so it will try to save you money. If you have the PV 10% option enabled it will also take into account the worst-case scenario and how often it might happen, so if the forecast is a bit unreliable it's better to charge more and not risk getting stung importing. Have you checked your energy rates for import and export are correct, maybe check the rates graph and confirm. If you do something like have export>import then Predbat will try to export as much as possible. Have you tuned Solcast to match your output accurately? Have you tuned predbat_best_soc_keep settings ? Do you have predicted car charging during the time period? You can also tune predbat_load_scaling and predbat_pv_scaling to adjust predictions up and down a bit","title":"Why is my predicted charge % higher or lower than I might expect?"},{"location":"faq/#why-didnt-the-slot-get-configured","text":"Are you in read-only mode?","title":"Why didn't the slot get configured?"},{"location":"faq/#my-plan-doesnt-include-any-charging","text":"Do you have the predbat_mode set to Control charge (or Control charge & discharge)?","title":"My plan doesn't include any charging?"},{"location":"faq/#the-charge-limit-keeps-increasingdecreasing-in-the-charge-window-or-is-unstable","text":"Check you don't have any other automations running that adjust GivTCP settings during this time. Some people had a script that changes the reserve %, this will cause problems - please disable other automations and retry.","title":"The charge limit keeps increasing/decreasing in the charge window or is unstable"},{"location":"faq/#i-changed-a-config-item-but-it-made-no-difference","text":"You might have to wait a few minutes until the next update cycle. Depending on the speed of the computer that Predbat is running on, it can take 1-5 minutes for Predbat to run through. You can see the date/time that Predbat last completed a run at the start of the Predbat HTML plan .","title":"I changed a config item but it made no difference?"},{"location":"faq/#its-all-running-but-im-not-getting-very-good-results","text":"You might want to tune input_number.predbat_best_soc_keep to set a minimum target battery level, e.g. I use 2.0 (for 2kWh, which is just over 20% on a 9.5kWh battery). If you set input_number.predbat_best_soc_keep too high then Predbat could need to charge the battery at unfavourable import rates, so try to set it to a fairly low value, especially if you have a small battery. If you set it to zero then Predbat may not charge at all, so use 0.1 as a minimum. Have a read of the energy rates configuration guide as depending on your tariff different settings may be required Check your solar production is well calibrated (you can compare Solcast vs actually in the Home Assistant energy tab or on the GivEnergy portal) Make sure your inverter max AC rate has been set correctly If you have an EV that you charge then you will want some sort of car charging sensor or use the basic car charging hold feature or your load predictions may be unreliable - see Car charging Do you have a solar diverter? If so maybe you want to try using the iBoost model settings . Perhaps set up the calibration chart and let it run for 24 hours to see how things line up If your export slots are too small compared to expected check your inverter_limit is set correctly (see below)","title":"It's all running but I'm not getting very good results"},{"location":"faq/#in-my-power-flow-diagram-my-grid-power-is-the-wrong-way-around","text":"You may need to set ' grid_power_invert to True if your grid_power is positive when importing.","title":"In my power flow diagram my grid power is the wrong way around"},{"location":"faq/#my-plan-is-freeze-charging-or-holding-at-100-battery-a-lot","text":"Round trip losses Round trip losses for charging the battery and then using it for your home are: charge loss x inverter loss x inverter loss x discharge loss The default is therefore: $0.97 * 0.96 * 0.96 * 0.97 \\approx 0.87$ (13%) If you freeze charge or hold at 100% then you will be using the grid which is 13% cheaper than using the battery at the same import rate. If you start increasing these losses to say 5% and 6% then you are getting to around 20% round trip losses. This means charging the battery at 20p is the same cost as using the grid at 25p. However, if you start setting metric_self_sufficiency then you are telling Predbat to try to import less when possible. If your round trip losses are 20% then using the grid directly will import 20% less energy than charging your battery. Therefore a 5p metric self-sufficiency will effectively add another 1p to this difference i.e. using the grid at 26p is now the same as charging the battery at 20p! If you set metric_battery_cycle to say 2p then that would add another 4p to using the battery so now charging at 20p would equate to using the grid at 30p! Bottom line, be careful how you configure things.","title":"My plan is freeze charging or holding at 100% battery a lot"},{"location":"faq/#when-my-battery-is-charging-to-100-it-fluctuates-between-98-and-100-andor-gives-an-error-setting-reserve","text":"Some inverters e.g. GE AIO inverter won't allow the reserve to be set to 100, in which case set in apps.yaml inverter_reserve_max : 98 And this should prevent the issue","title":"When my battery is charging to 100% it fluctuates between 98% and 100%, and/or gives an error setting reserve"},{"location":"faq/#the-plan-doesnt-charge-or-discharge-when-i-expect-it-to","text":"Predbat can only work on the information it's given, although it does run every 5 minutes to execute the plan, and updates and re-evaluates the plan every 10 minutes, adjusting if necessary. The plan Predbat produces assumes that your average load and PV forecasts are accurate and Predbat will aim to give you the maximum return. Make sure you have set up your Solcast solar forecast correctly with the number of panels, orientation, output, etc. Projected daily load is determined from historical load information so make sure you have set days_previous and days_previous_weight in apps.yaml to give appropriately representative load history to Predbat, and read the longer explanation of how days_previous works . You could adjust input_number.predbat_load_scaling to 1.2 so the plan will incorporate 20% more expected load if you want to be more pessimistic about historical load, and input_number.predbat_pv_scaling to similarly adjust the PV forecast - these and other adjustment options are described in the Scaling and Weight options . It is very important to correctly set Predbat's Battery Loss Options and Battery Margins as these can have a huge and critical impact on the plan that Predbat generates. Predbat's default configuration values are the recommended starting values for most users but there is no single right set of configuration values for every user of Predbat, it depends on many factors and your personal preferences. Many users will need to customise and tweak their Predbat configuration to suit their needs. The SoC level that Predbat aims to keep in the battery input_number.predbat_best_soc_keep and the absolute minimum SoC level input_number.predbat_best_soc_min are the first things to check. If these are set too high then Predbat will charge at unfavourable rates to maintain the battery SoC. Conversely, if you find Predbat is letting the battery exhaust too early, set predbat_best_soc_keep to 1.0 so Predbat will aim to keep 1kWh available for unexpected load. Predbat performs a lowest-cost battery optimisation so a key part of deciding whether to charge, discharge or feed the house from the battery are the loss rates input_number.predbat_battery_loss , input_number.predbat_battery_loss_discharge and input_number.predbat_inverter_loss . Typical values could be 4, 4, 4 or 5, 5, 5. It is tempting to set these inverter loss figures lower to encourage Predbat to use the battery more, but this should be resisted as experience from the GivEnergy community forum suggests total energy conversion losses are in the range of 10-20%. Putting these losses into context and assuming you have an AC-coupled battery and have set the losses to 4, 4 and 4; then for every kWh charged from the grid, you will only get 0.92kWh stored in the battery (4% charge + 4% inverter conversion loss) and similarly when that 0.92kWh is discharged to the home you will only receive 0.85kWh (0.92 x 0.92). These loss percentages also impact the Predbat plan. Consider an import rate of 20p/kWh; after conversion losses are considered, each 1kWh of stored battery charge will in effect have cost 21.7p (20 / 0.92) to import. Then for discharging, the same applies. Each kWh of stored battery charge (that costs 21.7p to charge) will in effect have cost 23.6p (21.7 / 0.92) to discharge. Predbat makes cost optimisation decisions so unless the current import rate is more than 23.6p, it will be cheaper to let the home run off grid import rather than to discharge the battery. If you turn debug mode on for the Predbat plan then you can see the effective import and export rates after losses that Predbat calculates in the Predbat plan. Predbat also uses input_number.predbat_metric_battery_cycle ( expert mode setting) to apply a 'virtual cost' in pence per kWh for charging and discharging the battery. The default value is 1p but this this can be changed to a different value to recognise the 'cost of using the battery', or set to zero to disable this feature. So if the metric battery cycle is set to 1p, and continuing the example above, each kWh of battery charge will be costed at 22.7p (21.7p + 1p battery metric to charge), and the battery will not be discharged to support the home unless the current import rate is more than 25.6p (23.6p + 1p cost of charging + 1p cost to discharge). input_number.predbat_metric_min_improvement and input_number.predbat_metric_min_improvement_discharge (both expert mode settings) also affect Predbat's cost optimisation decisions as to whether it is cost beneficial to charge or discharge the battery so could be tweaked if you feel Predbat is charging or discharging with marginal benefits. The defaults (0p and 0.1p respectively) should however give good results for most users. Finally, it could be worth considering adding import or export rate increments to apps.yaml if you want to direct Predbat to avoid or encourage charging or discharging in certain time periods - e.g. avoiding exporting in the time period saving sessions normally fall in, or to encourage discharging just before import rates fall overnight.","title":"The plan doesn't charge or discharge when I expect it to"},{"location":"faq/#predbat-is-causing-warning-messages-about-exceed-maximum-size-in-the-home-assistant-core-log","text":"If you have a large input_number.predbat_forecast_plan_hours then you may see warning messages in the Home Assistant Core log about the size of a number of Predbat entities, the message will be \"State attributes for predbat. XXXX exceed maximum size of 16384 bytes\". This is just a warning, the Predbat entity attributes aren't stored in the database anyway, but you can suppress these warnings by adding the following to your configuration.yaml file: # Filter out 'message too large' warnings from Predbat entities logger: default: warning filters: homeassistant.components.recorder.db_schema: - \"State attributes for predbat.base10_export_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.base10_import_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.base10_metric exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.base10_pv_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.battery_cycle exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.battery_cycle_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.battery_power exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.battery_power_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_charge_limit exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_export_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_import_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_load_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_metric exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best_pv_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best10_export_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best10_import_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best10_metric exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.best10_pv_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.cost_today_export exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.cost_today_import exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.cost_yesterday exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.export_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.grid_power exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.grid_power_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.import_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_energy_actual exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_energy_adjusted exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_energy_predicted exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_power exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.load_power_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.metric exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.plan_html exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.pv_energy exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.pv_power exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.pv_power_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.rates exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.soc_kw exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.soc_kw_base10 exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.soc_kw_best exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\" - \"State attributes for predbat.soc_kw_best10 exceed maximum size of 16384 bytes. This can cause database performance issues; Attributes will not be stored\"","title":"Predbat is causing warning messages about 'exceed maximum size' in the Home Assistant Core log"},{"location":"faq/#error-metric_octopus_import-not-set-correctly-or-no-energy-rates-can-be-read","text":"If you get this error in the Predbat log file: Check that the Octopus integration is working and that event.octopus_energy_electricity_METER_NUMBER_current_day_rates and sensor.octopus_electricity_energy_METER_NUMBER_current_rate are both populated by the integration. Ensure that you have followed the Octopus Integration Installation instructions , including enabling the Octopus Integration events. If you have been using an older version of the Octopus integration and have upgraded to version 9 or above, then you may find that your energy sensors are named sensor.electricity_METER_NUMBER_current_rate (i.e. no 'octopus_energy_' prefix) but the 'event' entities have the 'octopus_energy' prefix. If the 'event' and 'sensor' entities are not consistently named then Predbat will not be able to find the event entities if the sensor names don't match what's expected. To fix this, uninstall the Octopus integration, reboot Home Assistant, delete all the old Octopus sensors, and re-install the Octopus Integration .","title":"Error - metric_octopus_import not set correctly or no energy rates can be read"},{"location":"faq/#warn-no-solar-data-has-been-configured","text":"If you get this warning message in the Predbat log file or you see that the 'PV kWh' column in the Predbat plan card is completely blank: Ensure that you have installed and configured Solcast correctly Check the Solcast integration in Home Assistant is configured and enabled (go to Settings / Integrations / Solcast ) Check that there are no errors relating to Solcast in the Home Assistant log (go to Settings / System / Logs and view the 'Home Assistant Core' log). If you see an error 429 message in the log then this is as a result of Solcast's rate limiting for Hobbyist accounts. The only fix is to re-run the 'Solcast update' automation and hope that Solcast isn't as busy when you re-run. Verify the solar forecast has been populated in Home Assistant by going to 'Settings' / 'Developer Tools' / 'States', filtering on 'solcast', and check that you can see the half-hourly solar forecasts in the Solcast entities If you can see the Solcast entities but there are no forecast PV figures, try running the 'Solcast update' automation you created, and check again the Solcast entities If the Solcast entities are still not populated, try reloading the Solcast integration (go to System / Devices & Services / Integrations tab, click on 'Solcast PV Forecast', click the three vertical dots beside 'Configure' and choose 'Reload' from the dropdown menu) Check sensor.solcast_pv_api_limit (it's normally 10 for new Solcast accounts) meaning you can call the Solcast API 10 times a day (but if you have two solar arrays, e.g. East/West) then retrieving the forecast will count as two API calls. Compare this to sensor.solcast_pv_api_used to see how many Solcast API calls you have made today (alternatively, you can confirm how many API calls you have made today by logging into your Solcast account). If you've run out of API calls you will have to wait until midnight GMT for the API count to reset. It's recommended that you don't include the Solcast forecast within your GivEnergy portal to avoid running out of API calls. Check the Solcast server API status is OK","title":"WARN: No solar data has been configured"},{"location":"faq/#note-can-not-find-battery-charge-curve","text":"If you get the message \"Note: Can not find battery charge curve, one of the required settings for soc_kw, battery_power and charge_rate are missing from apps.yaml\" in the logfile then Predbat tries to create a battery charge curve but does not have access to the required history information in Home Assistant. Creating the battery charge curve is described in the apps.yaml document. The most likely cause of the above message appearing in the logfile is that you are controlling a GivEnergy inverter in REST mode but have not uncommented the following entities in apps.yaml that Predbat needs to obtain history from to create the battery charge curve: charge_rate: - number.givtcp_{geserial}_battery_charge_rate discharge_rate: - number.givtcp_{geserial}_battery_discharge_rate battery_power: - sensor.givtcp_{geserial}_battery_power soc_kw: - sensor.givtcp_{geserial}_soc_kwh You should also check that all the entities Predbat highlights that it are using have history, and that the charging/discharging goes to full/empty as described in the battery curve documentation.","title":"Note: Can not find battery charge curve"},{"location":"faq/#warn-inverter-is-in-calibration-mode","text":"If you see the message \"WARN: Inverter is in calibration mode, Predbat will not function correctly and will be disabled\" in the logfile, then Predbat has identified that your inverter is currently calibrating your battery. Predbat's status will also be set to 'Calibration'. Predbat will set the inverter charge and discharge rates to maximum (if they are not already), SoC target to 100% and battery reserve to minimum (usually 4%), and will not execute the plan nor enable battery charge or discharge. Once the inverter finishes calibrating the battery, Predbat will resume normal operations.","title":"WARN: Inverter is in calibration mode"},{"location":"faq/#inverter-time-is-xxx-predbat-computer-time-is-xxx-this-is-xxx-minutes-skewed-predbat-may-not-function-correctly","text":"If the predbat.status gives a warning error about the inverter time: Then it indicates that there is a mismatch between the clock that Predbat is using and the inverter time clock, and clearly with a clock mismatch, charging and discharging your battery at specific times may not work as expected. There are several potential causes of this problem: Check that the inverter time is correctly set, especially that it is set to GMT (even if it's summertime). In the GivEnergy portal, go to My Inverters / Remote Control (cog symbol) / click SEND next to 'Set Date and Time' Check that the time_zone in appdaemon.yaml is correctly set for your location (e.g. Europe/London) The time zone for Predbat in apps.yaml needs to be set to the same value Finally, check how often your inverter integration is polling your inverter for new data. For GivTCP the Self Run Loop Timer is recommended to be set to a value of between 20 and 60 seconds. If you have checked the above and keep getting \u201ctime is skewed\u201d warnings then it means Home Assistant/predbat isn\u2019t getting the same time from the inverter as it is expecting. Either GivTCP has lost communications with the inverter or the inverter has stopped talking to the world. If you look at the Logbook in Home Assistant you should see a steady stream of entities changing in HA. In particular, you will see the GivTCP inverter time entity changing every polling period, e.g. every 20 seconds. Possible fixes: restart the GivTCP app restart Home Assistant (although usually restarting GivTCP is enough) power the inverter off, turn off the panels and battery first, then the inverter, then follow the reverse sequence to power the inverter back on again. This forces the inverter to reconnect to your wifi do a \u2018reset to defaults\u2019 in the portal If you keep getting the warning message, even sporadically, then this points to an underlying issue in your home network between Home Assistant and the inverter. You may need to add a Wi-Fi repeater or ideally a fixed Ethernet connection to your inverter to improve signal strength if this keeps happening. There is a Home Assistant automation that will alert you if GivTCP stops sending data to predbat .","title":"Inverter time is xxx, Predbat computer time is xxx, this is xxx minutes skewed, Predbat may not function correctly"},{"location":"faq/#i-have-another-problem-not-listed-above","text":"If you are still having trouble feel free to raise a GitHub ticket for support","title":"I have another problem not listed above"},{"location":"install/","text":"Install These instructions will take you through the process of installing and configuring Predbat for first-time use. If you have a working Predbat installation using AppDaemon and are changing to use the Predbat app, the AppDaemon to Predbat app upgrade process is described below. It's recommended that you watch the Predbat Video Guides before you start. We have tried to make the documentation as comprehensive as possible but a level of familiarity with the basics of Home Assistant, Apps, Integrations, Entities, File Editing and YAML is assumed. There are plenty of \"Home Assistant basics\" tutorials on YouTube, but here are a few useful videos to introduce you to Home Assistant and displaying inverter data: What is Home Assistant from Smart Home Junkie YAML Basics from This Smart Home Installing HACS from Speak to the Geek Setting up the Energy dashboard for GivEnergy inverters from Speak to the Geek Power Flow Card Plus from Speak to the Geek If you get stuck, please read the FAQs and if necessary raise a GitHub ticket for support. Inverter Control install You will need to install an integration to communicate with and control your inverter. Predbat was originally written for GivEnergy inverters controlled by the GivTCP app but has been extended for other inverter types. The specific integration you need will depend on the brand of inverter you have, please see Inverter Setup for details on installing and configuring the appropriate inverter control software so that Home Assistant is able to 'see' and manage your inverter. For many inverters there are specific additional configuration steps for Predbat and additional controls, automations and scripts to be created for the inverter for Predbat to be able to control it. You will need at least 24 hours of history in Home Assistant for Predbat to work correctly, the default is 7 days (but you configure this back to 1 day if you need to). Editing Configuration Files in Home Assistant The basic configuration for Predbat is stored in a configuration file called apps.yaml . A standard GivEnergy template apps.yaml file for GivTCP will be installed as part of the Predbat installation and you will need to edit and customise this configuration file for your own system setup. If you have a different inverter then you will need to use the appropriate apps.yaml template for that inverter. You will need a method of editing configuration files within your Home Assistant environment. There are several ways to achieve this in Home Assistant, but two of the simplest are to use either the File Editor or Studio Code Server apps. Whichever you use is a personal preference. File Editor is a bit simpler, Studio Code Server is more powerful but does require HACS (the Home Assistant Community Store) to be installed first. If you do not have one of these file editors already installed in Home Assistant: For Studio Code Server you will need to install HACS first (see Speak To The Geek video linked above) Go to Settings / Apps / Install app (bottom right) Scroll down the app list, to find either 'File editor' or 'Studio Code Server' as appropriate, click on the app, click 'INSTALL' Once the editor has been installed, ensure that the 'Start on boot' option is turned on, and click 'START' to start the app Thereafter whenever you need to edit a configuration file in Home Assistant you can navigate to Settings / Apps / editor_you_chose_to_use / 'OPEN WEB UI'. You can also turn the 'Show in sidebar' option on to give a quicker way to directly access the editor. If you are using the File Editor to edit Predbat's configuration files, you will need to turn OFF the Enforce Basepath option to access files in different directories (i.e. within the apps directory): From the File editor app page, click on the 'Configuration' tab to change this setting). It is set to 'On' by default: If you are using Studio Code Server it will default to showing just files and folders in the /config directory. To access the entire HA directory structure, click the three horizontal bars to the left of 'Explorer', File, Open Folder, type '/' (root) and click OK. Predbat app install Recommended The simplest way to install Predbat now is with the Predbat app. The Predbat-Appdaemon app and Appdaemon install methods previously used for Predbat have been retired. Go to settings, Apps, select Install app, three dots on the top right, Repositories, then add the following repo ' https://github.com/springfall2008/predbat_addon ' to the list and click close. Now refresh the list and find Predbat, click on it and click 'install'. Ensure 'start on boot' is enabled and click 'start'. NOTE: Throughout the rest of the Predbat documentation you will find reference to the Predbat configuration file apps.yaml and the Predbat logfile. These are located under the Home Assistant directory /addon_configs/6adb4f0d_predbat which contains: predbat.log - Predbat's active logfile that reports details of what Predbat is doing, and details of any errors apps.yaml - Predbat's configuration file which will need to be customised to your system and requirements. This configuration process is described below. You can use your file editor (i.e. 'File editor' or 'Studio Code Server' app) to open the directory /addon_configs/6adb4f0d_predbat and view these files. The Predbat web interface will work through the Predbat app, you can click on the 'Web UI' button to open it once Predbat is running. Docker Install As an alternative to the Predbat app, Predbat can be installed via Docker The Predbat docker image is https://hub.docker.com/r/nipar44/predbat_addon and is a fork of the Predbat app with updates so it will run directly as a Docker docker container. Installation instructions can be found at https://github.com/nipar4/predbat_addon . Predbat Installation Into Appdaemon Installing HACS, Appdaemon and then Predbat within Appdaemon has been deprecated, please swap to either the Predbat app or Docker installation methods. The process to upgrade from Predbat within Appdaemon to Predbat addon is described below. Solcast Install Predbat needs a solar forecast to predict solar generation and battery charging. If you have solar panels it's recommended to use the Solcast integration to retrieve your forecast solar generation. If you do not want to use Solcast you can also use Forecast.solar (less accurate) - see below. If you don't have one already, register for a free Solcast hobbyist account and enter the details of your system. You can create 2 sites maximum under one (free hobbyist) account, if you have more aspects then it suggests you average the angle based on the number of panels e.g. $7/10 * 240^\\circ + 3/10 * 120^\\circ$. Make sure you configure the Azimuth (panel orientation) correctly in your Solcast account, Azimuth is not set as a 0-359 degree value, but rather as 0-180 for westerly facing, or 0 to minus 179 for easterly facing. The Azimuth value is the number of degrees angled away from North, with the sign being West or East. If you're not sure, then do some quick research and check your roof orientation with a protractor on Google maps. Hybrid inverters only : If your hybrid inverter capacity is smaller than your array peak capacity, tell Solcast that your AC capacity is equal to your DC capacity (both equal to your array peak kW). Otherwise, Solcast will provide forecast data clipped at your inverter capacity. Let Predbat handle any necessary clipping instead. When supplied with the unclipped Solcast forecast data, Predbat can allow in its model for PV over the inverter capacity going to battery charging (bypassing the hybrid inverter). You will need your API key for the next steps: Predbat direct Solcast method Predbat can obtain the solar forecast directly from Solcast and the Solcast integration described below is not required. First, get your API key from the Solcast website, then as described in the Solcast apps.yaml documentation , uncomment the Solcast cloud interface settings in apps.yaml and set the API key correctly: solcast_host: 'https://api.solcast.com.au/' solcast_api_key: 'xxxx' solcast_poll_hours: 8 NB: If you use Predbat to obtain your Solcast solar forecast then you can't include the Solar Forecast within the Home Assistant Energy dashboard as you can with the Solcast integration described below. The Solcast integration also contains a 'solar dampening' feature that may be useful to reduce the solar forecast that Predbat receives at certain times of day, e.g. if your panels are shaded by trees or buildings. Predbat direct to forecast.solar The Forecast.solar service can also be used in Predbat, the free version offer access without an API Key but is limited to hourly data and does not provide any 10% or 90% data. Predbat Solar calibration can use past data to improve this information and provide the 10% data. You can create one or more rooftops by providing a list of the data for each one, they will be summed up automatically. The latitude and longitude are your location in world, or for the UK you can set a postcode. The azimuth is the direction of the roof: 0=North, -90=East, 90=West, -180/180 = South - note these are different to how Solcast measures azimuth so if you do swap from forecast.solar to Solcast, don't just copy the azimuth over! The declination is the angle of the panels, e.g. 45 for a sloped roof or 20 for those on a flat roof The efficiency relates to the aging of your panels, 0.95 is for newer systems but they will lose around 1% each year. The optional forecast_solar_max_age setting sets the number of hours between updates to PV data, the default is 8. forecast_solar: - postcode: SW1A 2AB kwp: 3 azimuth: 45 declination: 45 efficiency: 0.95 forecast_solar_max_age: 4 or you can set longitude and latitude if you are not in the UK or postcode does not work: latitude: 51.5072 longitude: -0.1276 Optionally you can set an api_key for personal or professional accounts and you can also set 'days' to define how many future days of data the forecast includes (2 for free, 3 for personal or 6 for professional). forecast_solar: - postcode: SW1A 2AB api_key: 'xxxxx' days: 3 Note you can omit any of these settings for a default value. They do not have to be exact if you use Predbat auto calibration for PV to improve the data quality. Solcast Home Assistant integration method Install the Solcast integration ( https://github.com/BJReplay/ha-solcast-solar ), create a free Solcast account , configure details of your solar arrays, and request an API key that you enter into the Solcast integration in Home Assistant. Make sure that the configuration option 'Enable forecast half-hourly detail attributes' is turned on as predbat requires the half-hourly detailed solar forecast to populate the predbat plan. By default the Solcast integration only provides hourly forecasts and Predbat will take each hourly PV forecast and treat it as a half-hour value - doubling your solar generation forecast! Predbat is configured in apps.yaml to automatically discover the Solcast forecast entities created by the Solcast integration in Home Assistant. Note that Predbat does not update Solcast integration for you so you will either need to use the default forecast auto-update within the integration, or create your own Home Assistant automation that updates the solar forecast a few times a day (e.g. dawn, dusk, and just before your nightly charge slot). Keep in mind hobbyist accounts only have 10 polls per day so the refresh period needs to be less than this. If you use the same Solcast account for other automations the total polls need to be kept under the limit or you will experience failures. Due to the popularity of the Solcast Hobbyist service, Solcast has introduced rate limiting for Hobbyist (free) accounts. If your update gets a 429 error then this is due to rate limiting. Solcast recommends that you poll for updated solar forecasts at random times, i.e. don't poll at precisely X o'clock and zero seconds. The Solcast integration will auto-retry if it gets a 429 error, but to minimise the potential rate limiting the sample Solcast automation below contains non-precise poll times for just this reason. Example Solcast update automation script: alias: Solcast update description: \"Update Solcast solar forecast\" triggers: - trigger: time at: - \"06:02:34\" - \"12:07:47\" - \"18:09:56\" - \"23:11:18\" conditions: [] actions: - action: solcast_solar.update_forecasts data: {} mode: single Manually run the automation and then make sure the Solcast integration is working in Home Assistant by going to 'Settings' / 'Developer Tools' / 'States', filtering on 'solcast', and check that you can see the half-hourly solar forecasts in the Solcast entities. No solar If you don't have any solar generation then use a file editor to comment out the following lines from the Solar forecast part of the apps.yaml configuration: pv_forecast_today: re:(sensor.(solcast_|)(pv_forecast_|)forecast_today) pv_forecast_tomorrow: re:(sensor.(solcast_|)(pv_forecast_|)forecast_tomorrow) pv_forecast_d3: re:(sensor.(solcast_|)(pv_forecast_|)forecast_(day_3|d3)) pv_forecast_d4: re:(sensor.(solcast_|)(pv_forecast_|)forecast_(day_4|d4)) Energy Rates Predbat needs to know what your electricity import and export rates are to optimise battery charging and discharging to minimise your expenditure. These rates are configured in Predbat's apps.yaml configuration file. Follow the instructions in the Energy Rates document. Note: that if you are using the Octopus integration the 'sensor.octopus_xxx' and 'event.octopus_xxx' entities must have a similar pattern of names for Predbat to work correctly - see the FAQ's if they are not. Configuring Predbat You will need to use a file editor (either the File editor or Studio Code Server app) to edit the apps.yaml file in Home Assistant to configure Predbat - see Configuring apps.yaml . When Predbat starts up initially it will perform a sanity check of itself and the configuration and confirm the right files are present. You will see this check in the log, should it fail a warning will be issued and predbat.status will also reflect the warning. While the above warning might not prevent Predbat from starting up, you should fix the issue ASAP as it may cause future problems. Note: If you are running the Predbat through the Predbat app or via Docker you will get a logfile warning message. Predbat Output and Configuration Controls As described above, the basic configuration of Predbat is held in the apps.yaml configuration file. When Predbat first runs it will create a number of output and configuration control entities in Home Assistant which are used to fine-tune how Predbat operates. The entities are all prefixed predbat and can be seen (and changed) from the Settings / Devices & Services / Entities list in Home Assistant or the Config view in Predbat web console . It is recommended that you create a dashboard page with all the required entities to control Predbat and another page to display Predbat's charging and discharging plan for your battery. The Output Data section describes these points in more detail including using the auto-generated predbat_dashboard.yaml dashboard file. The Home Assistant entity predbat.status contains details of what status Predbat is currently in (e.g. Idle, Charging, Error). Detailed progress messages and error logging are written to the Predbat logfile which you can view within Home Assistant using a file editor . The Predbat Configuration Guide gives an overview of the main Predbat configuration items and detail of 'standard Predbat configuration' settings for different electricity tariff types - e.g. a cheap overnight rate, multiple import rates during the day, and variable tariffs such as Agile, etc. The detailed Predbat Customisation Guide details all the Predbat configuration items (switches, input numbers, etc) in Home Assistant, and what each of them does. The Predbat Web Interface provides an easy way to view all of the Predbat configuration items, check apps.yaml for errors, and view the logfile. Ready to light the touch-paper By now you should have successfully installed and configured Predbat and the other components it is dependent upon (e.g. an inverter controller such as GivTCP, Solcast solar forecast, Octopus Energy integration, etc). You have checked the Predbat log file doesn't have any errors (there is a lot of output in the logfile, this is normal). You have configured Predbat's control entities , checked for apps.yaml errors , created some dashboard pages to control and monitor Predbat , and are ready to start Predbat generating your plan. You may initially want to set select.predbat_mode to Monitor to see how Predbat operates, e.g. by studying the Predbat Plan . In Monitor mode Predbat will monitor (but not change) the current inverter settings and predict the battery SoC based on predicted Solar Generation and House Load. NB: In Monitor mode Predbat will NOT plan any battery charge or discharge activity of its own, it will report on the predicted battery charge level based on the current inverter charge & discharge settings, predicted house load and predicted solar generation. In order to enable Predbat to start generating your plan you must delete the 'template: True' line in apps.yaml once you are happy with your configuration. Predbat will automatically run, analyse your house load, battery status, solar prediction, etc and produce a plan based on the current battery settings. Check the Predbat logfile again for errors. Voluminous output is quite normal but any errors or warnings should be investigated. Read the Predbat FAQ's for answers to common questions you may have. Also, check the Predbat status predbat.status - major errors will also be flagged here. Once Predbat is running successfully the recommended next step is to start Predbat planning your inverter charging and discharging activity, but not (yet) make any changes to the inverter. This enables you to get a feel for the Predbat plan and further customise Predbat's settings to meet your needs. Set select.predbat_mode to the correct mode of operation for your system - usually 'Control charge' or 'Control charge & discharge'. Also, you should set switch.predbat_set_read_only to On to stop Predbat from making any changes to your inverter. You can see the planned solar and grid charging and discharging activity in the Predbat Plan . Another set of views can be seen in the detailed Apex Charts showing Predbat's predictions . Once you are happy with the plan Predbat is producing, and are ready to let Predbat start controlling your inverter charging and discharging, set the switch switch.predbat_set_read_only to Off and Predbat will start controlling your inverter. Updating Predbat Note that any future updates to Predbat will not overwrite the apps.yaml configuration file that you have tailored to your setup. If new Predbat releases introduce new features to apps.yaml you may therefore need to manually copy across the new settings from the Template apps.yaml . Update via Home Assistant Recommended Predbat can now be updated using the Home Assistant update feature. When a new release is available you should see it in the Home Assistant settings: Click on the update and select Install: Note that clicking the 'Skip' button give an error about auto-update being enabled for Predbat and that the update cannot be skipped. This warning appears because of Predbat's built-in auto-update feature and can be safely ignored. If you wish to skip or ignore a Predbat update then you don't need to do anything; Predbat will not auto-update (despite what HA says) unless you turn on Predbat's auto-update (see below) or choose a version to install. Predbat will remain running on the current version until you choose to update. Predbat built-in update Recommended for manual selection of versions or automatic updates Predbat can now update itself, just select the version of Predbat you want to install from the select.predbat_update drop-down menu, the latest version will be at the top of the list. Predbat will update itself and automatically restart. Alternatively, if you turn On switch.predbat_auto_update , Predbat will automatically update itself as new releases are published on GitHub. Once Predbat has been installed and configured you should update Predbat to the latest version by selecting the latest version in the select.predbat_update selector, or by turning on the switch.predbat_auto_update to auto-update Predbat. Manually installing a Predbat release The Predbat version selector select.predbat_update contains the last 25 Predbat releases, but sometimes if Predbat has stopped working, or if you wish to downgrade to an older version that is not on the drop-down menu, then you might need to manually install a Predbat release. Go to Predbat releases on GitHub and find the release you wish to install. From the Assets list, download the source code (zip) file: Unzip the source code file you have downloaded Navigate to the release sub folder, then apps , and finally the predbat sub-folder Shutdown Predbat Copy all the .py files from the predbat sub-folder into your Predbat application folder in Home Assistant and overwrite the existing .py files. If you are running the Predbat app then the destination folder will be /addon_configs/6adb4f0d_predbat Restart Predbat Upgrading from AppDaemon to Predbat app These steps assume you already have a working Predbat system and want to upgrade to using the Predbat app instead of using either the AppDaemon or the AppDaemon-predbat app. Using the Predbat app is the strategic direction for Predbat and resolves some performance and data load issues that can occur with AppDaemon. The Predbat code that runs is the same and the configuration is exactly the same, it is just changing the 'container' that Predbat runs within. Before starting, watch the installing Predbat app video Although the upgrade steps are low risk, take a full backup of Home Assistant before starting Install the Predbat app : Add the Predbat app to the list of Repositories in the app store Install the Predbat app But do not start it - yet Install a file editor if you don't have one already installed - either File Editor or Studio Code Server, it doesn't matter Shutdown your existing AppDaemon or AppDaemon-predbat app: Go to Settings/Apps Click on the existing AppDaemon/AppDaemon-predbat app Click STOP, and untick 'Start on boot' Briefly start the new Predbat app so that it creates the addon_config folder and the template apps.yaml file: Go to Settings/Apps Click on the Predbat app Click START, wait a minute for the app to initialise itself, then click STOP. A predbat status warning that you have a template apps.yaml file is normal and can be ignored Open your file editor and open your existing apps.yaml file: If you are using the old 'combined AppDaemon/Predbat app installation method' it's in the directory /addon_configs/46f69597_appdaemon-predbat/apps , or with the old HACS Appdaemon app then Predbat installation method it's in /config/appdaemon/apps/batpred/config/ Select all the contents of the apps.yaml file and 'copy' (control-C, command-C, etc as appropriate) Now open the template apps.yaml file that's supplied with the Predbat app and has been created in the directory /addon_configs/6adb4f0d_predbat , select all the contents of the template apps.yaml file, and paste in the contents of your existing apps.yaml, overwriting the template with your specific configuration Now you are ready to swap from running the AppDaemon or AppDaemon-predbat app to the Predbat app: Go to Settings/Apps Click on the existing AppDaemon/AppDaemon-predbat app Make sure it is not running and 'Start on boot' is not ticked Click the back arrow Click on the Predbat app Click START, and tick 'Start on boot' If you are using the Predbat automatic monitor then you will need to enable the predbat_running binary sensor and change the automation, replacing the AppDaemon app id (a0d7b954_appdaemon) with 'a06adb4f0d_predbat', and 'binary_sensor.appdaemon_running' with 'binary_sensor.predbat_running'. And that's it. You should check the Log tab to ensure it all starts properly, but it should do as you've copied over your existing configuration. Note that if you are using the Predbat direct connection to Solcast then the Predbat app will need to download your solar forecast so will use up one or two of your daily API calls (hobbyist accounts have a 10 API calls a day limit). If you are using the Solcast integration then this won't be required. You may find that the Predbat app installed with an older version of Predbat than you were previously using, which might require you to update Predbat to the correct version . When you are happily running the Predbat app you can delete the AppDaemon or AppDaemon-predbat app. Backing up Home Assistant and Predbat It's strongly recommended that you implement an automatic mechanism to back up your Home Assistant and Predbat system. There are several ways of backing up Home Assistant but one of the simplest is the Home Assistant Google Drive Backup which is an app that runs every night, automatically makes a backup of Home Assistant (including Predbat), and copies that backup to a Google Drive for safekeeping. If you create a new Google account specifically for your Home Assistant backups you will automatically get 15Gb of free Google Drive storage, enough for a couple of weeks of backups. As well as the full Home Assistant backup you manually copy the contents of Predbat's apps.yaml configuration file to somewhere safe so that if you accidentally mis-edit it, you can get Predbat working quickly again by copying it back again. Uninstalling Predbat Incredible though it may be to imagine, its possible you may want to uninstall Predbat. Removing the Predbat app is easy, System / Apps / Predbat then select 'Uninstall'. Its recommended that you do a full restart of Home Assistant and all apps after removing Predbat. You will find that entities created by Predbat unfortunately don't get removed when you remove the Predbat app, and as they do not have unique Home Assistant id's, they can't be removed from the Devices & Services / Entities list. To remove the Predbat entities you will need to use a different mechanism and purge them from Home Assistant: 'Settings' / 'Developer Tools' / 'Actions' Search for 'Recorder: Purge Entities' Tick 'Domains to remove' and enter 'predbat' as the domain Tick 'Entity globs to remove' and enter ' .predbat_ ' Tick 'Days to keep' and set to zero days Then click 'Perform Action' This will remove the Predbat entities. Then do another full reboot of Home Assistant all the apps.","title":"Install details"},{"location":"install/#install","text":"These instructions will take you through the process of installing and configuring Predbat for first-time use. If you have a working Predbat installation using AppDaemon and are changing to use the Predbat app, the AppDaemon to Predbat app upgrade process is described below. It's recommended that you watch the Predbat Video Guides before you start. We have tried to make the documentation as comprehensive as possible but a level of familiarity with the basics of Home Assistant, Apps, Integrations, Entities, File Editing and YAML is assumed. There are plenty of \"Home Assistant basics\" tutorials on YouTube, but here are a few useful videos to introduce you to Home Assistant and displaying inverter data: What is Home Assistant from Smart Home Junkie YAML Basics from This Smart Home Installing HACS from Speak to the Geek Setting up the Energy dashboard for GivEnergy inverters from Speak to the Geek Power Flow Card Plus from Speak to the Geek If you get stuck, please read the FAQs and if necessary raise a GitHub ticket for support.","title":"Install"},{"location":"install/#inverter-control-install","text":"You will need to install an integration to communicate with and control your inverter. Predbat was originally written for GivEnergy inverters controlled by the GivTCP app but has been extended for other inverter types. The specific integration you need will depend on the brand of inverter you have, please see Inverter Setup for details on installing and configuring the appropriate inverter control software so that Home Assistant is able to 'see' and manage your inverter. For many inverters there are specific additional configuration steps for Predbat and additional controls, automations and scripts to be created for the inverter for Predbat to be able to control it. You will need at least 24 hours of history in Home Assistant for Predbat to work correctly, the default is 7 days (but you configure this back to 1 day if you need to).","title":"Inverter Control install"},{"location":"install/#editing-configuration-files-in-home-assistant","text":"The basic configuration for Predbat is stored in a configuration file called apps.yaml . A standard GivEnergy template apps.yaml file for GivTCP will be installed as part of the Predbat installation and you will need to edit and customise this configuration file for your own system setup. If you have a different inverter then you will need to use the appropriate apps.yaml template for that inverter. You will need a method of editing configuration files within your Home Assistant environment. There are several ways to achieve this in Home Assistant, but two of the simplest are to use either the File Editor or Studio Code Server apps. Whichever you use is a personal preference. File Editor is a bit simpler, Studio Code Server is more powerful but does require HACS (the Home Assistant Community Store) to be installed first. If you do not have one of these file editors already installed in Home Assistant: For Studio Code Server you will need to install HACS first (see Speak To The Geek video linked above) Go to Settings / Apps / Install app (bottom right) Scroll down the app list, to find either 'File editor' or 'Studio Code Server' as appropriate, click on the app, click 'INSTALL' Once the editor has been installed, ensure that the 'Start on boot' option is turned on, and click 'START' to start the app Thereafter whenever you need to edit a configuration file in Home Assistant you can navigate to Settings / Apps / editor_you_chose_to_use / 'OPEN WEB UI'. You can also turn the 'Show in sidebar' option on to give a quicker way to directly access the editor. If you are using the File Editor to edit Predbat's configuration files, you will need to turn OFF the Enforce Basepath option to access files in different directories (i.e. within the apps directory): From the File editor app page, click on the 'Configuration' tab to change this setting). It is set to 'On' by default: If you are using Studio Code Server it will default to showing just files and folders in the /config directory. To access the entire HA directory structure, click the three horizontal bars to the left of 'Explorer', File, Open Folder, type '/' (root) and click OK.","title":"Editing Configuration Files in Home Assistant"},{"location":"install/#predbat-app-install","text":"Recommended The simplest way to install Predbat now is with the Predbat app. The Predbat-Appdaemon app and Appdaemon install methods previously used for Predbat have been retired. Go to settings, Apps, select Install app, three dots on the top right, Repositories, then add the following repo ' https://github.com/springfall2008/predbat_addon ' to the list and click close. Now refresh the list and find Predbat, click on it and click 'install'. Ensure 'start on boot' is enabled and click 'start'. NOTE: Throughout the rest of the Predbat documentation you will find reference to the Predbat configuration file apps.yaml and the Predbat logfile. These are located under the Home Assistant directory /addon_configs/6adb4f0d_predbat which contains: predbat.log - Predbat's active logfile that reports details of what Predbat is doing, and details of any errors apps.yaml - Predbat's configuration file which will need to be customised to your system and requirements. This configuration process is described below. You can use your file editor (i.e. 'File editor' or 'Studio Code Server' app) to open the directory /addon_configs/6adb4f0d_predbat and view these files. The Predbat web interface will work through the Predbat app, you can click on the 'Web UI' button to open it once Predbat is running.","title":"Predbat app install"},{"location":"install/#docker-install","text":"As an alternative to the Predbat app, Predbat can be installed via Docker The Predbat docker image is https://hub.docker.com/r/nipar44/predbat_addon and is a fork of the Predbat app with updates so it will run directly as a Docker docker container. Installation instructions can be found at https://github.com/nipar4/predbat_addon .","title":"Docker Install"},{"location":"install/#predbat-installation-into-appdaemon","text":"Installing HACS, Appdaemon and then Predbat within Appdaemon has been deprecated, please swap to either the Predbat app or Docker installation methods. The process to upgrade from Predbat within Appdaemon to Predbat addon is described below.","title":"Predbat Installation Into Appdaemon"},{"location":"install/#solcast-install","text":"Predbat needs a solar forecast to predict solar generation and battery charging. If you have solar panels it's recommended to use the Solcast integration to retrieve your forecast solar generation. If you do not want to use Solcast you can also use Forecast.solar (less accurate) - see below. If you don't have one already, register for a free Solcast hobbyist account and enter the details of your system. You can create 2 sites maximum under one (free hobbyist) account, if you have more aspects then it suggests you average the angle based on the number of panels e.g. $7/10 * 240^\\circ + 3/10 * 120^\\circ$. Make sure you configure the Azimuth (panel orientation) correctly in your Solcast account, Azimuth is not set as a 0-359 degree value, but rather as 0-180 for westerly facing, or 0 to minus 179 for easterly facing. The Azimuth value is the number of degrees angled away from North, with the sign being West or East. If you're not sure, then do some quick research and check your roof orientation with a protractor on Google maps. Hybrid inverters only : If your hybrid inverter capacity is smaller than your array peak capacity, tell Solcast that your AC capacity is equal to your DC capacity (both equal to your array peak kW). Otherwise, Solcast will provide forecast data clipped at your inverter capacity. Let Predbat handle any necessary clipping instead. When supplied with the unclipped Solcast forecast data, Predbat can allow in its model for PV over the inverter capacity going to battery charging (bypassing the hybrid inverter). You will need your API key for the next steps:","title":"Solcast Install"},{"location":"install/#predbat-direct-solcast-method","text":"Predbat can obtain the solar forecast directly from Solcast and the Solcast integration described below is not required. First, get your API key from the Solcast website, then as described in the Solcast apps.yaml documentation , uncomment the Solcast cloud interface settings in apps.yaml and set the API key correctly: solcast_host: 'https://api.solcast.com.au/' solcast_api_key: 'xxxx' solcast_poll_hours: 8 NB: If you use Predbat to obtain your Solcast solar forecast then you can't include the Solar Forecast within the Home Assistant Energy dashboard as you can with the Solcast integration described below. The Solcast integration also contains a 'solar dampening' feature that may be useful to reduce the solar forecast that Predbat receives at certain times of day, e.g. if your panels are shaded by trees or buildings.","title":"Predbat direct Solcast method"},{"location":"install/#predbat-direct-to-forecastsolar","text":"The Forecast.solar service can also be used in Predbat, the free version offer access without an API Key but is limited to hourly data and does not provide any 10% or 90% data. Predbat Solar calibration can use past data to improve this information and provide the 10% data. You can create one or more rooftops by providing a list of the data for each one, they will be summed up automatically. The latitude and longitude are your location in world, or for the UK you can set a postcode. The azimuth is the direction of the roof: 0=North, -90=East, 90=West, -180/180 = South - note these are different to how Solcast measures azimuth so if you do swap from forecast.solar to Solcast, don't just copy the azimuth over! The declination is the angle of the panels, e.g. 45 for a sloped roof or 20 for those on a flat roof The efficiency relates to the aging of your panels, 0.95 is for newer systems but they will lose around 1% each year. The optional forecast_solar_max_age setting sets the number of hours between updates to PV data, the default is 8. forecast_solar: - postcode: SW1A 2AB kwp: 3 azimuth: 45 declination: 45 efficiency: 0.95 forecast_solar_max_age: 4 or you can set longitude and latitude if you are not in the UK or postcode does not work: latitude: 51.5072 longitude: -0.1276 Optionally you can set an api_key for personal or professional accounts and you can also set 'days' to define how many future days of data the forecast includes (2 for free, 3 for personal or 6 for professional). forecast_solar: - postcode: SW1A 2AB api_key: 'xxxxx' days: 3 Note you can omit any of these settings for a default value. They do not have to be exact if you use Predbat auto calibration for PV to improve the data quality.","title":"Predbat direct to forecast.solar"},{"location":"install/#solcast-home-assistant-integration-method","text":"Install the Solcast integration ( https://github.com/BJReplay/ha-solcast-solar ), create a free Solcast account , configure details of your solar arrays, and request an API key that you enter into the Solcast integration in Home Assistant. Make sure that the configuration option 'Enable forecast half-hourly detail attributes' is turned on as predbat requires the half-hourly detailed solar forecast to populate the predbat plan. By default the Solcast integration only provides hourly forecasts and Predbat will take each hourly PV forecast and treat it as a half-hour value - doubling your solar generation forecast! Predbat is configured in apps.yaml to automatically discover the Solcast forecast entities created by the Solcast integration in Home Assistant. Note that Predbat does not update Solcast integration for you so you will either need to use the default forecast auto-update within the integration, or create your own Home Assistant automation that updates the solar forecast a few times a day (e.g. dawn, dusk, and just before your nightly charge slot). Keep in mind hobbyist accounts only have 10 polls per day so the refresh period needs to be less than this. If you use the same Solcast account for other automations the total polls need to be kept under the limit or you will experience failures. Due to the popularity of the Solcast Hobbyist service, Solcast has introduced rate limiting for Hobbyist (free) accounts. If your update gets a 429 error then this is due to rate limiting. Solcast recommends that you poll for updated solar forecasts at random times, i.e. don't poll at precisely X o'clock and zero seconds. The Solcast integration will auto-retry if it gets a 429 error, but to minimise the potential rate limiting the sample Solcast automation below contains non-precise poll times for just this reason. Example Solcast update automation script: alias: Solcast update description: \"Update Solcast solar forecast\" triggers: - trigger: time at: - \"06:02:34\" - \"12:07:47\" - \"18:09:56\" - \"23:11:18\" conditions: [] actions: - action: solcast_solar.update_forecasts data: {} mode: single Manually run the automation and then make sure the Solcast integration is working in Home Assistant by going to 'Settings' / 'Developer Tools' / 'States', filtering on 'solcast', and check that you can see the half-hourly solar forecasts in the Solcast entities.","title":"Solcast Home Assistant integration method"},{"location":"install/#no-solar","text":"If you don't have any solar generation then use a file editor to comment out the following lines from the Solar forecast part of the apps.yaml configuration: pv_forecast_today: re:(sensor.(solcast_|)(pv_forecast_|)forecast_today) pv_forecast_tomorrow: re:(sensor.(solcast_|)(pv_forecast_|)forecast_tomorrow) pv_forecast_d3: re:(sensor.(solcast_|)(pv_forecast_|)forecast_(day_3|d3)) pv_forecast_d4: re:(sensor.(solcast_|)(pv_forecast_|)forecast_(day_4|d4))","title":"No solar"},{"location":"install/#energy-rates","text":"Predbat needs to know what your electricity import and export rates are to optimise battery charging and discharging to minimise your expenditure. These rates are configured in Predbat's apps.yaml configuration file. Follow the instructions in the Energy Rates document. Note: that if you are using the Octopus integration the 'sensor.octopus_xxx' and 'event.octopus_xxx' entities must have a similar pattern of names for Predbat to work correctly - see the FAQ's if they are not.","title":"Energy Rates"},{"location":"install/#configuring-predbat","text":"You will need to use a file editor (either the File editor or Studio Code Server app) to edit the apps.yaml file in Home Assistant to configure Predbat - see Configuring apps.yaml . When Predbat starts up initially it will perform a sanity check of itself and the configuration and confirm the right files are present. You will see this check in the log, should it fail a warning will be issued and predbat.status will also reflect the warning. While the above warning might not prevent Predbat from starting up, you should fix the issue ASAP as it may cause future problems. Note: If you are running the Predbat through the Predbat app or via Docker you will get a logfile warning message.","title":"Configuring Predbat"},{"location":"install/#predbat-output-and-configuration-controls","text":"As described above, the basic configuration of Predbat is held in the apps.yaml configuration file. When Predbat first runs it will create a number of output and configuration control entities in Home Assistant which are used to fine-tune how Predbat operates. The entities are all prefixed predbat and can be seen (and changed) from the Settings / Devices & Services / Entities list in Home Assistant or the Config view in Predbat web console . It is recommended that you create a dashboard page with all the required entities to control Predbat and another page to display Predbat's charging and discharging plan for your battery. The Output Data section describes these points in more detail including using the auto-generated predbat_dashboard.yaml dashboard file. The Home Assistant entity predbat.status contains details of what status Predbat is currently in (e.g. Idle, Charging, Error). Detailed progress messages and error logging are written to the Predbat logfile which you can view within Home Assistant using a file editor . The Predbat Configuration Guide gives an overview of the main Predbat configuration items and detail of 'standard Predbat configuration' settings for different electricity tariff types - e.g. a cheap overnight rate, multiple import rates during the day, and variable tariffs such as Agile, etc. The detailed Predbat Customisation Guide details all the Predbat configuration items (switches, input numbers, etc) in Home Assistant, and what each of them does. The Predbat Web Interface provides an easy way to view all of the Predbat configuration items, check apps.yaml for errors, and view the logfile.","title":"Predbat Output and Configuration Controls"},{"location":"install/#ready-to-light-the-touch-paper","text":"By now you should have successfully installed and configured Predbat and the other components it is dependent upon (e.g. an inverter controller such as GivTCP, Solcast solar forecast, Octopus Energy integration, etc). You have checked the Predbat log file doesn't have any errors (there is a lot of output in the logfile, this is normal). You have configured Predbat's control entities , checked for apps.yaml errors , created some dashboard pages to control and monitor Predbat , and are ready to start Predbat generating your plan. You may initially want to set select.predbat_mode to Monitor to see how Predbat operates, e.g. by studying the Predbat Plan . In Monitor mode Predbat will monitor (but not change) the current inverter settings and predict the battery SoC based on predicted Solar Generation and House Load. NB: In Monitor mode Predbat will NOT plan any battery charge or discharge activity of its own, it will report on the predicted battery charge level based on the current inverter charge & discharge settings, predicted house load and predicted solar generation. In order to enable Predbat to start generating your plan you must delete the 'template: True' line in apps.yaml once you are happy with your configuration. Predbat will automatically run, analyse your house load, battery status, solar prediction, etc and produce a plan based on the current battery settings. Check the Predbat logfile again for errors. Voluminous output is quite normal but any errors or warnings should be investigated. Read the Predbat FAQ's for answers to common questions you may have. Also, check the Predbat status predbat.status - major errors will also be flagged here. Once Predbat is running successfully the recommended next step is to start Predbat planning your inverter charging and discharging activity, but not (yet) make any changes to the inverter. This enables you to get a feel for the Predbat plan and further customise Predbat's settings to meet your needs. Set select.predbat_mode to the correct mode of operation for your system - usually 'Control charge' or 'Control charge & discharge'. Also, you should set switch.predbat_set_read_only to On to stop Predbat from making any changes to your inverter. You can see the planned solar and grid charging and discharging activity in the Predbat Plan . Another set of views can be seen in the detailed Apex Charts showing Predbat's predictions . Once you are happy with the plan Predbat is producing, and are ready to let Predbat start controlling your inverter charging and discharging, set the switch switch.predbat_set_read_only to Off and Predbat will start controlling your inverter.","title":"Ready to light the touch-paper"},{"location":"install/#updating-predbat","text":"Note that any future updates to Predbat will not overwrite the apps.yaml configuration file that you have tailored to your setup. If new Predbat releases introduce new features to apps.yaml you may therefore need to manually copy across the new settings from the Template apps.yaml .","title":"Updating Predbat"},{"location":"install/#update-via-home-assistant","text":"Recommended Predbat can now be updated using the Home Assistant update feature. When a new release is available you should see it in the Home Assistant settings: Click on the update and select Install: Note that clicking the 'Skip' button give an error about auto-update being enabled for Predbat and that the update cannot be skipped. This warning appears because of Predbat's built-in auto-update feature and can be safely ignored. If you wish to skip or ignore a Predbat update then you don't need to do anything; Predbat will not auto-update (despite what HA says) unless you turn on Predbat's auto-update (see below) or choose a version to install. Predbat will remain running on the current version until you choose to update.","title":"Update via Home Assistant"},{"location":"install/#predbat-built-in-update","text":"Recommended for manual selection of versions or automatic updates Predbat can now update itself, just select the version of Predbat you want to install from the select.predbat_update drop-down menu, the latest version will be at the top of the list. Predbat will update itself and automatically restart. Alternatively, if you turn On switch.predbat_auto_update , Predbat will automatically update itself as new releases are published on GitHub. Once Predbat has been installed and configured you should update Predbat to the latest version by selecting the latest version in the select.predbat_update selector, or by turning on the switch.predbat_auto_update to auto-update Predbat.","title":"Predbat built-in update"},{"location":"install/#manually-installing-a-predbat-release","text":"The Predbat version selector select.predbat_update contains the last 25 Predbat releases, but sometimes if Predbat has stopped working, or if you wish to downgrade to an older version that is not on the drop-down menu, then you might need to manually install a Predbat release. Go to Predbat releases on GitHub and find the release you wish to install. From the Assets list, download the source code (zip) file: Unzip the source code file you have downloaded Navigate to the release sub folder, then apps , and finally the predbat sub-folder Shutdown Predbat Copy all the .py files from the predbat sub-folder into your Predbat application folder in Home Assistant and overwrite the existing .py files. If you are running the Predbat app then the destination folder will be /addon_configs/6adb4f0d_predbat Restart Predbat","title":"Manually installing a Predbat release"},{"location":"install/#upgrading-from-appdaemon-to-predbat-app","text":"These steps assume you already have a working Predbat system and want to upgrade to using the Predbat app instead of using either the AppDaemon or the AppDaemon-predbat app. Using the Predbat app is the strategic direction for Predbat and resolves some performance and data load issues that can occur with AppDaemon. The Predbat code that runs is the same and the configuration is exactly the same, it is just changing the 'container' that Predbat runs within. Before starting, watch the installing Predbat app video Although the upgrade steps are low risk, take a full backup of Home Assistant before starting Install the Predbat app : Add the Predbat app to the list of Repositories in the app store Install the Predbat app But do not start it - yet Install a file editor if you don't have one already installed - either File Editor or Studio Code Server, it doesn't matter Shutdown your existing AppDaemon or AppDaemon-predbat app: Go to Settings/Apps Click on the existing AppDaemon/AppDaemon-predbat app Click STOP, and untick 'Start on boot' Briefly start the new Predbat app so that it creates the addon_config folder and the template apps.yaml file: Go to Settings/Apps Click on the Predbat app Click START, wait a minute for the app to initialise itself, then click STOP. A predbat status warning that you have a template apps.yaml file is normal and can be ignored Open your file editor and open your existing apps.yaml file: If you are using the old 'combined AppDaemon/Predbat app installation method' it's in the directory /addon_configs/46f69597_appdaemon-predbat/apps , or with the old HACS Appdaemon app then Predbat installation method it's in /config/appdaemon/apps/batpred/config/ Select all the contents of the apps.yaml file and 'copy' (control-C, command-C, etc as appropriate) Now open the template apps.yaml file that's supplied with the Predbat app and has been created in the directory /addon_configs/6adb4f0d_predbat , select all the contents of the template apps.yaml file, and paste in the contents of your existing apps.yaml, overwriting the template with your specific configuration Now you are ready to swap from running the AppDaemon or AppDaemon-predbat app to the Predbat app: Go to Settings/Apps Click on the existing AppDaemon/AppDaemon-predbat app Make sure it is not running and 'Start on boot' is not ticked Click the back arrow Click on the Predbat app Click START, and tick 'Start on boot' If you are using the Predbat automatic monitor then you will need to enable the predbat_running binary sensor and change the automation, replacing the AppDaemon app id (a0d7b954_appdaemon) with 'a06adb4f0d_predbat', and 'binary_sensor.appdaemon_running' with 'binary_sensor.predbat_running'. And that's it. You should check the Log tab to ensure it all starts properly, but it should do as you've copied over your existing configuration. Note that if you are using the Predbat direct connection to Solcast then the Predbat app will need to download your solar forecast so will use up one or two of your daily API calls (hobbyist accounts have a 10 API calls a day limit). If you are using the Solcast integration then this won't be required. You may find that the Predbat app installed with an older version of Predbat than you were previously using, which might require you to update Predbat to the correct version . When you are happily running the Predbat app you can delete the AppDaemon or AppDaemon-predbat app.","title":"Upgrading from AppDaemon to Predbat app"},{"location":"install/#backing-up-home-assistant-and-predbat","text":"It's strongly recommended that you implement an automatic mechanism to back up your Home Assistant and Predbat system. There are several ways of backing up Home Assistant but one of the simplest is the Home Assistant Google Drive Backup which is an app that runs every night, automatically makes a backup of Home Assistant (including Predbat), and copies that backup to a Google Drive for safekeeping. If you create a new Google account specifically for your Home Assistant backups you will automatically get 15Gb of free Google Drive storage, enough for a couple of weeks of backups. As well as the full Home Assistant backup you manually copy the contents of Predbat's apps.yaml configuration file to somewhere safe so that if you accidentally mis-edit it, you can get Predbat working quickly again by copying it back again.","title":"Backing up Home Assistant and Predbat"},{"location":"install/#uninstalling-predbat","text":"Incredible though it may be to imagine, its possible you may want to uninstall Predbat. Removing the Predbat app is easy, System / Apps / Predbat then select 'Uninstall'. Its recommended that you do a full restart of Home Assistant and all apps after removing Predbat. You will find that entities created by Predbat unfortunately don't get removed when you remove the Predbat app, and as they do not have unique Home Assistant id's, they can't be removed from the Devices & Services / Entities list. To remove the Predbat entities you will need to use a different mechanism and purge them from Home Assistant: 'Settings' / 'Developer Tools' / 'Actions' Search for 'Recorder: Purge Entities' Tick 'Domains to remove' and enter 'predbat' as the domain Tick 'Entity globs to remove' and enter ' .predbat_ ' Tick 'Days to keep' and set to zero days Then click 'Perform Action' This will remove the Predbat entities. Then do another full reboot of Home Assistant all the apps.","title":"Uninstalling Predbat"},{"location":"installation-summary/","text":"Installation summary Please see the sections below for how to achieve each step. This is just a checklist of things: Before you start, it is recommended that you watch the step-by-step installation videos, see the video guides section for those and other videos Make sure the right inverter control module is installed and running Install a file editor (either the File editor or Studio Code Server app) to enable you to edit configuration files if you haven't already - Editing configuration files Install - Predbat app install for HAOS, or as a Docker install Decide on and setup a Solar Forecast. It's recommended that you use Solcast , or you can use Forecast.solar . For Solcast: Register for a Solcast hobbyist account if you haven't already Solcast install and either: Configure Predbat to call Solcast for the Solar forecast, or Install and configure the Solcast integration , and check that you see the Solcast data in Home Assistant Follow the Energy Rates instructions to tell Predbat what your import and export energy rates are. If you use Octopus Energy then this includes installing the Octopus Energy integration (if you haven't already) - Octopus Energy Edit Predbat's apps.yaml configuration file to to match your system - apps.yaml settings The apps.yaml file will be in either the directory /addon_configs/6adb4f0d_predbat or /config/appdaemon/apps/predbat/config/ depending on which Predbat install method you used. Inverter settings match the names in GivTCP - should be automatic (but if you have 2 names you will have to edit apps.yaml) You have set the right number of inverters ( num_inverters ) Adjust your inverter_limit and export_limit as required You have your energy rates set correctly either using Octopus Energy integration or entered manually That the Solcast integration (if being used) is matching the configuration correctly - should be automatic If you have an electric car you have set up the Car Charging configuration Add the Predbat entities to your dashboard - Output data Follow the Configuration Guide to set 'standard' Predbat configuration settings depending on your import and export tariffs The detailed Customisation Guide lists all Predbat's controls and settings in Home Assistant that can be tuned for your system Set up the Predbat Plan card so you can check what Predbat is planning to do - Create the Predbat Plan card Set up the Apex Charts for other views on what Predbat is doing - Creating the charts Then check that Predbat is working correctly: Look at the Predbat log file and make sure you have no errors or warnings that are unexpected Check that there are no errors in apps.yaml Comment out or delete the 'template: True' line in apps.yaml when you are ready to start Predbat The predbat.status in Home Assistant should be 'Idle' (if there are any errors then they are reported here too) Start with select.predbat_mode set to 'Monitor' but remember to change it later to enable Predbat to control your inverter Look at the FAQ for help Overview of the key configuration elements:","title":"Install summary"},{"location":"installation-summary/#installation-summary","text":"Please see the sections below for how to achieve each step. This is just a checklist of things: Before you start, it is recommended that you watch the step-by-step installation videos, see the video guides section for those and other videos Make sure the right inverter control module is installed and running Install a file editor (either the File editor or Studio Code Server app) to enable you to edit configuration files if you haven't already - Editing configuration files Install - Predbat app install for HAOS, or as a Docker install Decide on and setup a Solar Forecast. It's recommended that you use Solcast , or you can use Forecast.solar . For Solcast: Register for a Solcast hobbyist account if you haven't already Solcast install and either: Configure Predbat to call Solcast for the Solar forecast, or Install and configure the Solcast integration , and check that you see the Solcast data in Home Assistant Follow the Energy Rates instructions to tell Predbat what your import and export energy rates are. If you use Octopus Energy then this includes installing the Octopus Energy integration (if you haven't already) - Octopus Energy Edit Predbat's apps.yaml configuration file to to match your system - apps.yaml settings The apps.yaml file will be in either the directory /addon_configs/6adb4f0d_predbat or /config/appdaemon/apps/predbat/config/ depending on which Predbat install method you used. Inverter settings match the names in GivTCP - should be automatic (but if you have 2 names you will have to edit apps.yaml) You have set the right number of inverters ( num_inverters ) Adjust your inverter_limit and export_limit as required You have your energy rates set correctly either using Octopus Energy integration or entered manually That the Solcast integration (if being used) is matching the configuration correctly - should be automatic If you have an electric car you have set up the Car Charging configuration Add the Predbat entities to your dashboard - Output data Follow the Configuration Guide to set 'standard' Predbat configuration settings depending on your import and export tariffs The detailed Customisation Guide lists all Predbat's controls and settings in Home Assistant that can be tuned for your system Set up the Predbat Plan card so you can check what Predbat is planning to do - Create the Predbat Plan card Set up the Apex Charts for other views on what Predbat is doing - Creating the charts Then check that Predbat is working correctly: Look at the Predbat log file and make sure you have no errors or warnings that are unexpected Check that there are no errors in apps.yaml Comment out or delete the 'template: True' line in apps.yaml when you are ready to start Predbat The predbat.status in Home Assistant should be 'Idle' (if there are any errors then they are reported here too) Start with select.predbat_mode set to 'Monitor' but remember to change it later to enable Predbat to control your inverter Look at the FAQ for help Overview of the key configuration elements:","title":"Installation summary"},{"location":"inverter-setup/","text":"Inverter setup PredBat was originally written for GivEnergy inverters using the GivTCP integration but has been extended to many other inverter models. The table below lists the inverters and required Home Assistant integrations that have had Predbat configurations developed. Follow the Predbat installation guide for full instructions to setup and configure Predbat. This document covers only the steps that are specific to different inverter types. Additionally, if your inverter type is not listed, you can create a custom inverter definition for Predbat . Once you get everything working please share the configuration as a github issue so it can be incorporated into the Predbat documentation. To setup the inverter with Predbat you will need to: Install the appropriate Home Assistant integration for your inverter Configure the integration according to its documentation Confirm that the integration is working. Are you receiving data from the various sensors (grid energy, charge limit, solar PV generated, etc)? Can you control the inverter using its Home Assistant controls? For each inverter there is a custom apps.yaml template configuration file that must be used in place of the GivTCP template file installed by default with Predbat: Open the inverter-specific template file with a browser Using a file editor in Home Assistant , edit the default apps.yaml configuration file Select-all in the default apps.yaml , and delete the entire template contents Select-all in the inverter-specific template file opened earlier, and copy and paste the contents into the Home Assistant file editor - if you copy but don't replace the standard apps.yaml template then Predbat will not function correctly. Follow the inverter-specific setup steps detailed below for each inverter (click on the inverter name in the table). Steps vary for each inverter, for some there are no additional steps, but for other inverters there are additional controls, scripts and automations that have to be created for Predbat to work with that inverter type. Follow the rest of the Predbat install instructions , in particular review that apps.yaml is configured correctly for your inverter. Name Integration Template GivEnergy with GivTCP GivTCP givenergy_givtcp.yaml Givenergy with GE Cloud ge_cloud givenergy_cloud.yaml [Givenergy with GE Cloud EMS](#givenergy-with-ge-cloud-ems ge_cloud EMS givenergy_ems.yaml Givenergy/Octopus No Home Assistant n/a ge_cloud_octopus_standalone.yaml Fox Foxess fox.yaml Fox Cloud Predbat fox_cloud.yaml Growatt with Solar Assistant Solar Assistant spa.yaml or sph.yaml Huawei Huawei Solar huawei.yaml Kostal Plenticore Kostal Plenticore kostal.yaml LuxPower LuxPython luxpower.yaml SigEnergy SigEnergy sigenergy_sigenstor.yaml Sofar inverters Sofar MQTT integration sofar.yaml SolarEdge inverters Solaredge Modbus Multi solaredge.yaml Solax Cloud Predbat solax_cloud.yaml Solax Gen4 inverters Solax Modbus integration in Modbus Power Control Mode solax_sx4.yaml Solis Cloud Predbat solis_cloud.yaml Solis Hybrid inverters (Firmware before FB00) Solax Modbus integration ginlong_solis.yaml Solis Hybrid inverters (Firmware FB00 and later) Solax Modbus integration ginlong_solis.yaml SunSynk Sunsynk sunsynk.yaml Tesla Powerwall Tesla Fleet or Teslemetry tesla_powerwall.yaml Victron Victron MQTT victron.yaml Note that support for all these inverters is in various stages of development. Please expect things to fail and report them as Issues on GitHub. GivEnergy with GivTCP It's recommended that you first watch the Installing GivTCP and Mosquitto Apps video from Speak to the Geek . Install Mosquitto Broker app: Go to Settings / Apps / Install app (bottom right) Scroll down the apps list, to find 'Mosquitto broker', click on the app, then click 'INSTALL' Once the Mosquitto broker has been installed, ensure that the 'Start on boot' and 'Watchdog' options are turned on, and click 'START' to start the app Next, configure Mosquitto broker by going to Settings / Devices and Services / Integrations. Mosquitto broker should appear as a Discovered integration so click the blue 'CONFIGURE' button, then SUBMIT to complete configuring Mosquitto broker Install the GivTCP app: Go to Settings / Apps / Install app Click the three dots in the top right corner, then Repositories You'll need to add the GivTCP repository as an additional custom repository so paste/type ' https://github.com/britkat1980/ha-addons ' into the text box and click 'Add' then 'Close' NB: this URL is for GivTCP v3, not v2 as covered in the video. Click the back button and then re-navigate to Settings / Apps / Install app so Home Assistant picks up the GivTCP app from the custom repository Scroll down the app list, to find 'GivTCP-V3', you should see the three addons; the production version, the latest beta and the latest dev versions. Click on the 'GivTCP' app, then click 'INSTALL' Once GivTCP has been installed, ensure that the 'Start on boot' and 'Watchdog' options are turned on Configure GivTCP: All configuration for GivTCP is done via the app Web interface On the GivTCP app, click 'START' to start the app Once the app has started, click 'Open Web UI' or go to http://homeassistant.local:8099/ , then click 'Go to Config Page' to configure GivTCP GivTCP will auto-discover your inverters and batteries so you shouldn't need to manually enter these, but check the IP address(s) it finds are correct If you have a single AIO then for Predbat to be able to communicate via REST to the AIO, it MUST be the first device configured in GivTCP. Conversely if you have a gateway and multiple AIO's then the gateway MUST be the first device in GivTCP If you have multiple inverters you may wish to change the default device prefixes that GivTCP assigns ('givtcp', 'givtcp2', 'givtcp3', etc) to make it easier to identify your devices within Home Assistant. For example, if you have a gateway and two AIOs you could use the prefixes 'GW', 'AIO-1' and 'AIO-2'. The prefixes should be set before you start using GivTCP in anger as changing the prefixes later on will result in both the old and new sensor names appearing in Home Assistant with the 'old' sensors being \"unavailable\". Note that if you do change the givtcp prefixes then you will also have to edit the apps.yaml configuration file to match, and change the sensor names that Predbat is looking for (by default prefixed 'givtcp_xxx') to your new sensor naming structure Click Next and Next to get to the Selfrun page, and turn on Self Run so that GivTCP automatically retrieves data from your inverter. The Self Run Loop Timer is how often GivTCP will retrieve data - it's recommended that set this to a value between 20 and 60, but not less than 15 seconds as otherwise the inverter will then spend all its time talking to GivTCP and won't communicate with the GivEnergy portal and app GivTCP auto-populates the MQTT page so as long as you're using Mosquitto broker within Home Assistant; you won't need to create a dedicated MQTT user or enter the details on the MQTT page You don't need to configure the Influx page. Tariff and Palm pages can also be skipped as these functions are done by Predbat (Optional) On the Web page, you can turn the Dashboard on to see a simple power flow diagram for your inverters (similar to the GivEnergy mobile app) On the 'Misc' page check that 'Print Raw' is set to on for added monitoring Finally, click 'Save and Restart' and GivTCP should start communicating with your inverters and will automatically create a set of 'givtcp_xxx' entities in Home Assistant for your inverter data, inverter controls and battery data Check the GivTCP Log tab that there aren't any errors; it should end with 'Publishing Home Assistant Discovery messages' Before you start using GivTCP to control your inverter Verify in the GivEnergy portal settings the following inverter settings are set correctly as these are settings that Predbat doesn't control, and if not set correctly could affect your battery activity: \"Inverter Charge Power Percentage\" is set to 100 (Predbat has its own low-rate charge control you can use if you wish) \"Inverter Discharge Power Percentage\" is set to 100. If you do wish to set a lower discharge rate then its recommended that instead you set inverter_limit_discharge in apps.yaml to the rate \"Battery Cutoff % Limit\" is set to 4 \"Enable AC Charge Upper Limit' is enabled (if you have this option) That charge slot 2 (or more) are disabled (as Predbat only uses slot1) That discharge slot 2 (or more) are disabled (as Predbat only uses slot1) Specific Predbat configuration requirements for certain GivEnergy equipment The rest of the Predbat installation instructions should now be followed, but its worth highlighting that there are a few specific settings that should be set for certain GivEnergy equipment. These settings are documented in the appropriate place in the documentation, but for ease of identification, are repeated here: If you are using GivTCP v3 and have an AIO or 3-phase inverter then you will need to manually set geserial in apps.yaml to your inverter serial number in lower case as the auto-detect doesn't work for this setup If you have a single AIO then control is directly to the AIO. Ensure geserial in apps.yaml is correctly picking the AIO and comment out geserial2 lines If you have multiple AIOs then all control of the AIOs is done through the Gateway so geserial in apps.yaml should be set to the Gateway serial number in lower case If you have multiple AIOs you might want to consider setting inverter charge and discharge limits unless you want to charge and discharge at the full 12kWh! If you have a 2.6kWh, 5.2kWh or AIO battery then you will need to set battery_scaling in apps.yaml as the battery size is incorrectly reported to GivTCP If you have an older inverter (AC3 or Gen 1 hybrid) with firmware that has battery pause support you may need to comment out pause start and end time controls in apps.yaml If you have a Gen 2, Gen 3 or AIO then you may need to set inverter_reserve_max in apps.yaml to 98. If you have a Gen 1 or a firmware version that allows the reserve being set to 100 then you can change the default from 98 to 100 If your inverter has been wired as an EPS (Emergency Power Supply) or AIO 'whole home backup', consider setting input_number.predbat_set_reserve_min to reserve some battery power for use in emergencies. NB: GivTCP and Predbat do not currently yet work together for 3-phase inverters . This is being worked on by the author of GivTCP, e.g. see GivTCP issue: unable to charge or discharge 3 phase inverters with Predbat GivEnergy with GE Cloud This is an experimental system, please discuss it on the ticket: https://github.com/springfall2008/batpred/issues/905 First set up ge_cloud integration using your API key https://github.com/springfall2008/ge_cloud Now copy the template givenergy_cloud.yaml from templates over the top of your apps.yaml and edit Set geserial to your inverter serial number Make sure that the 'discharge down to' registers are set to 4% and slots 2, 3 and 4 for charge and discharge are disabled in the portal (if you have them) GivEnergy with GE Cloud EMS First set up ge_cloud integration using your API key https://github.com/springfall2008/ge_cloud Now copy the template givenergy_ems.yaml from templates over the top of your apps.yaml and edit Set geserial to your first inverter serial and geserial2 to the second (look in HA for entity names) Set geseriale to the EMS inverter serial number (look in HA for the entity names) Turn off charge, export and discharge slots 2, 3 and 4 as Predbat will only use slot 1 - set the start and end times for these to 00:00 GivEnergy Octopus Cloud Direct - No Home Assistant Take the template and enter your GivEnergy API key directly into apps.yaml Set your Octopus API key in apps.yaml Set your Solcast API key in apps.yaml Review any other configuration settings Launch Predbat with hass.py (from the Predbat-addon repository) either via a Docker or just on a Linux/MAC/WSL command line shell. Fox Thanks to the work of @PeterHaban, for this Predbat configuration for Fox ESS inverters which Peter has working with a ECS4100h7 and UK Octopus Cosy. It runs off the work modes and charge/discharge rates. Copy the Fox template over the top of the supplied apps.yaml , and edit for your system. Create an input_number helper using the HA to hold the minimum battery soc level %, and set it to 10%: name: Battery Min SoC Min value: 0 Max value: 100 Create a template sensor helper using the HA UI to hold the SoC remaining percentage converted to kWh - sensor: - name: \"FoxESS SoC kWh remaining\" unit_of_measurement: \"kWh\" device_class: energy state_class: total state: > {{ ((float(states.sensor.foxess_battery_soc.state)/100) *float(states.sensor.foxess_bms_kwh_remaining.state)) }} Create a template sensor helper using the HA UI to hold the net grid power, combining the separate FoxESS integration import and export power sensors - sensor: - name: \"FoxESS Grid Power\" unit_of_measurement: \"kW\" device_class: power state_class: measurement state: > {% set import_p = states('sensor.foxess_grid_consumption') | float(0) %} {% set export_p = states('sensor.foxess_feed_in') | float(0) %} {{ import_p - export_p }} For an AC-coupled FoxESS inverter you will need a method to measure Solar Generation power and energy today for Predbat to use. The author of this configuration used an ESPHome flashed Emporia Vue 2, or you can use a Shelly EM or similar energy monitor. Replace the pv_today and pv_power entries in apps.yaml with the appropriate sensor names. Fox Cloud Predbat now has a built-in Fox cloud integration. Today it requires a battery that supports the scheduler mode to function. See the components documentation for details Components - Fox cloud Growatt with Solar Assistant You need to have a Solar Assistant installation https://solar-assistant.io Growatt has two popular series of inverters, SPA and SPH. Copy the template that matches your model from templates over the top of your apps.yaml , and edit inverter and battery settings as required. Yours may have different entity IDs on Home Assistant. Huawei The discussion ticket is here: https://github.com/springfall2008/batpred/issues/684 Please copy the template https://github.com/springfall2008/batpred/blob/main/templates/huawei.yaml over the top of your apps.yaml , and modify it for your system Ensure you set input_number.predbat_set_reserve_min to the minimum value for your system which may be 12% Huawei inverters can charge the battery from DC solar and discharge at one power level (e.g. 5kWh), but have a lower limit (e.g. 3kWh) for AC charging. At present Predbat doesn't have the ability to model separate DC and AC charging limits, so battery_rate_max is set to the lower limit in watts (e.g. 3000) in the template apps.yaml to ensure that Predbat correctly plans AC charging of the battery at the right rate. However this means Predbat will also limit DC solar charging to this lower limit and to avoid that an automation is used to overwrite the inverter_limit_charge during the hours of sunrise and sunset: alias: Predbat change inverter charge rate at sunrise and sunset description: Using predbat_manual_api triggers: - trigger: time at: entity_id: sensor.sun_next_rising id: sunrise - trigger: time at: entity_id: sensor.sun_next_setting id: sunset conditions: [] actions: - choose: - conditions: - condition: trigger alias: Sunrise id: - sunrise sequence: - action: select.select_option alias: set inverter charge rate to 5000W at sunrise for maximum DC solar charging target: entity_id: - select.predbat_manual_api data: option: inverter_limit_charge(0)=5000 - conditions: - condition: trigger alias: Sunset id: - sunset sequence: - action: select.select_option alias: set inverter charge rate to 1500W at sunset for reduced AC charging rate target: entity_id: - select.predbat_manual_api data: option: inverter_limit_charge(0)=3000 mode: single Set the Huawei inverter work mode to 'TOU' (Time Of Use). Kostal Plenticore Thanks to the work of @mbuhansen for this Predbat configuration for Kostal Plenticore inverters. It should work with both the G1/G2 and G3 inverters. Copy the Kostal template over the top of your apps.yaml , and edit for your system. Create four new input_boolean and six input_number helpers using the HA UI: input_boolean.charge_start_service input_boolean.discharge_start_service input_boolean.charge_freeze_service input_boolean.discharge_freeze_service input_number.plenticore_max_charge # this is how fast inverter has to charge in %, is set to -100 when charge from grid Min value: -100 Max value: 0 input_number.plenticore_max_discharge # this is how fast inverter has to charge in %, is set to 100 when discharge to grid Min value: 0 Max value: 100 input_number.predbat_charge_limit # this is the limit % Predbat is charging the battery to, can be used if charge limit is set to true Min value: 0 Max value: 100 input_number.predbat_reserve # this is used to set Min_soc in inverter, the minimum level to discharge the battery to Min value: 0 Max value: 100 input_number.predbat_charge_rate # This is the rate Predbat is charging the battery at, can be used if low power charge mode is Enabled, remember to switch from \"write -100 charging\" to \"write power rate charging\" in automation Min value: 0 Max value: (Inverter Battery max charge in watt) input_number.predbat_discharge_rate # this is used to set battery discharge to zero Min value: 0 Max value: (Inverter Battery max discharge in watt) ```text - To control the Kostal inverter you need to use a modbus/tcp connection, this is not a part of the Kostal integration. Add the following modbus configuration to your `configuration.yaml`: ```yaml modbus: - name: kostalplenticore # name on modbus connection type: tcp # Use TCP host: 192.168.xxx.xxx # Modbus device IP-address port: 1502 # Port to Modbus-server Next, create the automation that sends the modbus commands to the Kostal inverter integration, when each input_boolean is activated from Predbat: alias: Predbat Charge / Discharge Control description: \"\" triggers: - trigger: state entity_id: - input_boolean.charge_start_service to: - \"on\" id: charge for: hours: 0 minutes: 0 seconds: 5 - trigger: state entity_id: - input_boolean.discharge_start_service to: \"on\" id: Discharge - trigger: state entity_id: - input_boolean.charge_freeze_service to: \"on\" id: Charge freeze - trigger: state entity_id: - input_boolean.discharge_freeze_service to: \"on\" id: Discharge freeze conditions: [] actions: - choose: - conditions: - condition: trigger id: - charge sequence: - repeat: sequence: - if: - condition: state entity_id: binary_sensor.predbat_charging state: \"on\" enabled: true then: - delay: hours: 0 minutes: 0 seconds: 45 milliseconds: 0 - repeat: sequence: - alias: Write -100 charging action: modbus.write_register metadata: {} data: slave: 71 address: 1028 hub: kostalplenticore value: > [ {{ '0x%x' % unpack(pack(states('input_number.plenticore_max_charge') |float(0), \">f\"), \">H\", offset=2) | abs }}, {{ '0x%04x' % unpack(pack(states('input_number.plenticore_max_charge')|float(0), \">f\"), \">H\")|abs }} ] enabled: true - alias: Write power rate charging action: modbus.write_register metadata: {} data: slave: 71 address: 1034 hub: kostalplenticore value: |- [ {{ '0x%x' % unpack(pack((states('input_number.predbat_charge_rate')|float(0)) * -1, \">f\"), \">H\", offset=2) | abs }}, {{ '0x%04x' % unpack(pack((states('input_number.predbat_charge_rate')|float(0)) * -1, \">f\"), \">H\") | abs }} ] enabled: false - delay: hours: 0 minutes: 0 seconds: 15 milliseconds: 0 while: - condition: state entity_id: input_boolean.charge_start_service state: \"on\" - condition: state entity_id: binary_sensor.predbat_charging state: \"on\" enabled: true enabled: true else: - delay: hours: 0 minutes: 0 seconds: 45 milliseconds: 0 - repeat: sequence: - alias: Write discharge rate zero action: modbus.write_register metadata: {} data: hub: kostalplenticore address: 1040 slave: 71 value: > [ {{ '0x%x' % unpack(pack(states('input_number.predbat_discharge_rate') |float(0), \">f\"), \">H\", offset=2) | abs }}, {{ '0x%04x' % unpack(pack(states('input_number.predbat_discharge_rate') |float(0), \">f\"), \">H\")|abs }} ] enabled: false - alias: Write min SOC action: modbus.write_register metadata: {} data: hub: kostalplenticore address: 1042 slave: 71 value: > [ {{ '0x%x' % unpack(pack((states('input_number.predbat_reserve') |float(0) - 1), \">f\"), \">H\", offset=2) | abs }}, {{ '0x%04x' % unpack(pack((states('input_number.predbat_reserve') |float(0) - 1), \">f\"), \">H\")|abs }} ] enabled: true - delay: hours: 0 minutes: 0 seconds: 15 milliseconds: 0 while: - condition: template value_template: >- {{ states('sensor.scb_battery_soc') | float <= (states('predbat.best_charge_limit') | float + 1.0) }} - condition: state entity_id: binary_sensor.predbat_charging state: - \"off\" enabled: true enabled: true while: - condition: state entity_id: input_boolean.charge_start_service state: \"on\" - conditions: - condition: trigger id: - Discharge sequence: - delay: hours: 0 minutes: 0 seconds: 40 milliseconds: 0 enabled: true - repeat: sequence: - action: modbus.write_register metadata: {} data: slave: 71 address: 1028 hub: kostalplenticore value: > [ {{ '0x%x' % unpack(pack(states('input_number.plenticore_max_discharge') |float(0), \">f\"), \">H\", offset=2) | abs }}, {{ '0x%04x' % unpack(pack(states('input_number.plenticore_max_discharge')|float(0), \">f\"), \">H\")|abs }} ] alias: Write 100 Discharge - delay: hours: 0 minutes: 0 seconds: 15 milliseconds: 0 while: - condition: state entity_id: input_boolean.discharge_start_service state: \"on\" - conditions: - condition: trigger id: - Charge freeze - condition: template value_template: |2- {% set rate = states('sensor.predbat_rates') | float(0) %} {% set high_rate = states('sensor.predbat_high_rate_export_cost_2') | float(0) %} {{ rate < high_rate }} enabled: false sequence: - delay: hours: 0 minutes: 0 seconds: 45 milliseconds: 0 - repeat: sequence: - action: modbus.write_register data: address: 1040 hub: kostalplenticore slave: 71 value: > [{{ '0x%04x' % unpack(pack(states('input_number.predbat_discharge_rate') |float(0), \">f\"), \">H\", offset=2) | abs }}, {{ '0x%04x' % unpack(pack(states('input_number.predbat_discharge_rate')|float(0), \">f\"), \">H\")|abs }}] metadata: {} alias: Write discharge rate enabled: false - alias: Write min. SOC action: modbus.write_register data: address: 1042 hub: kostalplenticore slave: 71 value: > [ {{ '0x%x' % unpack(pack((states('input_number.predbat_reserve') |float(0) - 1), \">f\"), \">H\", offset=2) | abs }}, {{ '0x%04x' % unpack(pack((states('input_number.predbat_reserve')|float(0) - 1), \">f\"), \">H\")|abs }} ] metadata: {} enabled: true - delay: hours: 0 minutes: 0 seconds: 15 milliseconds: 0 while: - condition: state entity_id: input_boolean.charge_freeze_service state: \"on\" - conditions: - condition: trigger id: - Discharge freeze sequence: - delay: hours: 0 minutes: 0 seconds: 45 milliseconds: 0 - repeat: sequence: - action: modbus.write_register data: address: 1038 hub: kostalplenticore slave: 71 value: > [{{ '0x%04x' % unpack(pack(states('input_number.predbat_charge_rate') |float(0), \">f\"), \">H\", offset=2) | abs }}, {{ '0x%04x' % unpack(pack(states('input_number.predbat_charge_rate')|float(0), \">f\"), \">H\")|abs }}] metadata: {} alias: Write charge rate - delay: hours: 0 minutes: 0 seconds: 15 milliseconds: 0 while: - condition: state entity_id: input_boolean.discharge_freeze_service state: \"on\" mode: queued max: 10 LuxPower This requires the LuxPython component which integrates with your Lux Power inverter Copy the template luxpower.yaml from templates over the top of your apps.yaml , and edit inverter and battery settings as required Predbat should have access to the full usable capacity of your battery system. In the LuxPowerTek web portal (not the app), ensure that: System Charge SOC Limit (%) is set to 100% (default). On-Grid Cut-Off SOC (%) is set to 100% minus battery depth of discharge(%). Depending on your battery, this is typically between 20% and 0%. If you want to use Predbat in Control charge mode, go to the LuxPowerTek app or web portal and set all start and end time slots for AC Charge to 00:00 . For Control charge and discharge mode, set all AC Charge and Forced Discharge slots to 00:00 . Predbat only uses the first time slots and will set these automatically. LuxPower does not have a SoC max entity in kWh and the SoC percentage entity never reports the battery reaching 100%, so create the following template helper sensors: name: Lux SoC Max kWh template: {{ (states(\"sensor.lux_battery_capacity_ah\") |float) * (states(\"sensor.lux_battery_voltage_live\") | float) / 1000}} unit of measurement: kWh device class: Energy state class: Total name: Lux Battery SoC Corrected template: {% set soc = states('sensor.lux_battery')|int %} {% set charging_stopped = states('sensor.lux_bms_limit_charge_live')|float == 0 %} {% if charging_stopped and soc > 97 %} 100 {% else %} {{ soc }} {% endif %} unit of measurement: % device class: Battery state class: Measurement Create the following number helper. The maximum value (in Watts) can be found in your inverter data sheet. A more accurate figure can be obtained by observing the flow chart in the Monitor section of the LuxPower app/portal or by inspecting sensor.lux_battery_flow_live when the battery is force charging or discharging. name: Battery Rate Max entity_id: input_number.battery_rate_max minimum value: 0 maximum value: YOUR_INVERTER_MAXIMUM_CHARGE/DISCHARGE_RATE unit of measurement: W Thanks to the work of @brickatius , the following automations and configurations enable LuxPower inverters to provide Freeze Charging and Freeze Exporting functionality when Predbat is operating in Control charge and discharge mode. Important: The Freeze Charging and Freeze Exporting setup described below relies on a set of carefully designed helpers and automations that work together. Each component has a specific role in safely entering, maintaining, and exiting Freeze Charging mode. Removing or skipping any part can lead to missed triggers, stuck AC charging, or incomplete cleanup. For reliable operation, make sure all helpers and automations in this section are created exactly as described before using Freeze Charging or Freeze Exporting modes. All of the automations apart from LuxPower HA Startup Reset remain disabled when Predbat is not Freeze Charging. Freeze Charging Note: Although LuxPower inverters have the Charge first / Charge priority feature, Predbat achieves a similar outcome by directly manipulating AC charge settings. This is why the following implementation is required. Set up your LuxPower Integration as follows: - - If you have not already done so, set up the blueprint for changing the refresh interval as described in the LuxPython_DEV README. - In the LUX Refresh Interval automation set the refresh interval to **20 seconds**. Freeze Charging relies on frequent state updates; intervals above 30 seconds may result in delayed or missed AC arbitration. In your apps.yaml file: Look for support_charge_freeze in the inverter section and change False to True . Uncomment the three lines of the charge_freeze_service section so that Predbat turns on automation.luxpower_freeze_charge when Freeze Charging starts. Ensure the indentation and alignment match the other service entries. Helpers Create the following Freeze Charge Guard toggle helper and Solar compare Home binary sensor helper using the HA user interface. Toggle helper name: Freeze Charge Guard entity_id: input_boolean.freeze_charge_guard The freeze_charge_guard helper acts as a lifecycle gate. It is enabled only when Predbat explicitly requests Freeze Charging and is cleared on exit, watchdog abort, or Home Assistant restart. All Freeze Charging automations check this guard to prevent unintended operation. Binary sensor template helper \u00b9 name: Solar compare Home entity_id: binary_sensor.solar_compare_home template options: state: > {{ 'on' if states('sensor.lux_solar_output_live') | float(0) <= states('sensor.lux_home_consumption_live') | float(0) else 'off' }} Automations Create the following Freeze Charge \u00b2 and Freeze Charge Predbat Override automations. These are enabled when Predbat enters Freeze Charging mode and disabled when it exits. Note: The Freeze Charge automation uses sensor.lux_battery_soc_corrected as described above. alias: LuxPower Freeze Charge description: > Controls AC charging during Predbat freeze charge mode. Arms and triggers freeze subsystems and watchdog via freeze guard. triggers: - entity_id: automation.luxpower_freeze_charge from: \"off\" to: \"on\" id: freeze_enabled trigger: state - entity_id: binary_sensor.solar_compare_home to: \"on\" for: \"00:00:10\" id: solar_on trigger: state - entity_id: binary_sensor.solar_compare_home to: \"off\" for: \"00:00:10\" id: solar_off trigger: state conditions: - condition: state entity_id: input_boolean.predbat_ready state: \"on\" actions: - choose: - conditions: - condition: trigger id: freeze_enabled sequence: - alias: \"FreezeEntry: Enable exit & override automations\" action: automation.turn_on target: entity_id: - automation.luxpower_freeze_charge_exit - automation.luxpower_freeze_charge_predbat_override - alias: \"FreezeEntry: Arm watchdog\" action: automation.turn_on target: entity_id: automation.luxpower_freeze_charge_watchdog - alias: \"FreezeEntry: Set freeze guard ON (triggers watchdog)\" action: input_boolean.turn_on target: entity_id: input_boolean.freeze_charge_guard - alias: \"FreezeEntry: Set initial SOC charge level\" action: number.set_value target: entity_id: number.lux_ac_battery_charge_level data: value: \"{{ states('sensor.lux_battery_soc_corrected') | float(0) }}\" - alias: \"FreezeEntry: Initial AC arbitration\" choose: - conditions: - condition: state entity_id: binary_sensor.solar_compare_home state: \"on\" - condition: state entity_id: switch.lux_ac_charge_enable state: \"off\" sequence: - action: switch.turn_on target: entity_id: switch.lux_ac_charge_enable - conditions: - condition: state entity_id: binary_sensor.solar_compare_home state: \"off\" - condition: state entity_id: switch.lux_ac_charge_enable state: \"on\" sequence: - action: switch.turn_off target: entity_id: switch.lux_ac_charge_enable - conditions: - condition: trigger id: - solar_on - solar_off - condition: state entity_id: input_boolean.freeze_charge_guard state: \"on\" sequence: - alias: \"FreezeSolar: AC arbitration\" choose: - conditions: - condition: state entity_id: binary_sensor.solar_compare_home state: \"on\" - condition: state entity_id: switch.lux_ac_charge_enable state: \"off\" sequence: - action: switch.turn_on target: entity_id: switch.lux_ac_charge_enable - conditions: - condition: state entity_id: binary_sensor.solar_compare_home state: \"off\" - condition: state entity_id: switch.lux_ac_charge_enable state: \"on\" sequence: - action: switch.turn_off target: entity_id: switch.lux_ac_charge_enable mode: single alias: LuxPower Freeze Charge Predbat Override description: > Handles Predbat forcing AC ON during Freeze Charge. Uses template trigger to avoid repeated retriggers every few seconds. triggers: - value_template: | {{ is_state('switch.lux_ac_charge_enable', 'on') and is_state('binary_sensor.solar_compare_home', 'off') and is_state('input_boolean.freeze_charge_guard', 'on') and is_state('input_boolean.predbat_ready', 'on') }} trigger: template conditions: [] actions: - delay: \"00:00:10\" - alias: \"Predbat Override: Turn AC OFF due to Solar > Home\" action: switch.turn_off target: entity_id: switch.lux_ac_charge_enable - alias: \"Predbat Override: Log AC override\" action: system_log.write data: level: debug message: > FreezeCharge: Predbat forced AC ON \u2192 overridden OFF (Solar=OFF, FreezeGuard=ON, PredbatReady=ON) mode: single Create the Freeze Charge Exit automation to cleanly restore inverter state when Freeze Charging ends. yaml alias: LuxPower Freeze Charge Exit description: | Cleanup when Predbat leaves Freeze charging. triggers: - entity_id: predbat.status trigger: state conditions: - condition: state entity_id: input_boolean.freeze_charge_guard state: \"on\" - condition: template value_template: | {% set new = trigger.to_state.state | default('') %} {{ new not in ['unknown','unavailable'] and not new.startswith('Warn:') and not new.startswith('Error:') and 'Freeze charging' not in new }} actions: - target: entity_id: - automation.luxpower_freeze_charge - automation.luxpower_freeze_charge_predbat_override - automation.luxpower_freeze_charge_watchdog action: automation.turn_off - target: entity_id: input_boolean.freeze_charge_guard action: input_boolean.turn_off - choose: - conditions: - condition: template value_template: | {{ trigger.to_state.state.startswith('Charging') or trigger.to_state.state == 'Hold charging' }} sequence: - target: entity_id: switch.lux_ac_charge_enable action: switch.turn_on default: - target: entity_id: switch.lux_ac_charge_enable action: switch.turn_off - choose: - conditions: - condition: template value_template: | {{ trigger.to_state.state.startswith('Charging') }} sequence: - target: entity_id: number.lux_ac_battery_charge_level data: value: \"{{ states('number.lux_system_charge_soc_limit') | int(0) }}\" action: number.set_value - conditions: - condition: template value_template: | {{ trigger.to_state.state == 'Hold charging' }} sequence: - target: entity_id: number.lux_ac_battery_charge_level data: value: >- {{ states('number.lux_on_grid_discharge_cut_off_soc') | int(0) }} action: number.set_value - target: entity_id: automation.luxpower_freeze_charge_exit action: automation.turn_off mode: single Occasionally, when a Manual Freeze Charge is requested, Predbat may immediately decide that Hold Charging is the more appropriate state based on current conditions. In this case, Freeze Charging automations may remain enabled even though Predbat reports Hold Charging. The watchdog safely exits Freeze Charging after a short grace period. Create the Freeze Charge Watchdog automation to handle cases where Manual Freeze Charging immediately transitions to Hold Charging . alias: LuxPower Freeze Charge Watchdog description: > Cancels freeze charge if Predbat does not commit to Freeze charging. Triggered by freeze guard Boolean; self-disarms after execution. triggers: - entity_id: input_boolean.freeze_charge_guard from: \"off\" to: \"on\" trigger: state conditions: [] actions: - alias: \"Watchdog: Grace period\" delay: \"00:00:30\" - alias: \"Watchdog: Abort if no Freeze charging\" if: - condition: template value_template: | {{ not states('predbat.status').startswith('Freeze charging') }} then: - alias: \"Watchdog: Trace cancellation\" action: system_log.write data: level: warning message: > Predbat never entered Freeze charging (status=\"{{ states('predbat.status') }}\") \u2192 cancelling freeze - alias: \"Watchdog: Disable freeze automations\" action: automation.turn_off target: entity_id: - automation.luxpower_freeze_charge - automation.luxpower_freeze_charge_predbat_override - automation.luxpower_freeze_charge_exit - alias: \"Watchdog: Reset guard Boolean\" action: input_boolean.turn_off target: entity_id: input_boolean.freeze_charge_guard - alias: \"Watchdog: AC handling\" choose: - conditions: - condition: template value_template: | {{ states('predbat.status').startswith('Charging') or states('predbat.status') == 'Hold charging' }} sequence: - if: - condition: state entity_id: switch.lux_ac_charge_enable state: \"off\" then: - action: switch.turn_on target: entity_id: switch.lux_ac_charge_enable default: - if: - condition: state entity_id: switch.lux_ac_charge_enable state: \"on\" then: - action: switch.turn_off target: entity_id: switch.lux_ac_charge_enable - alias: \"Watchdog: Restore SOC limits\" choose: - conditions: - condition: template value_template: | {{ states('predbat.status').startswith('Charging') }} sequence: - action: number.set_value target: entity_id: number.lux_ac_battery_charge_level data: value: \"{{ states('number.lux_system_charge_soc_limit') | int(0) }}\" - conditions: - condition: template value_template: | {{ states('predbat.status') == 'Hold charging' }} sequence: - action: number.set_value target: entity_id: number.lux_ac_battery_charge_level data: value: >- {{ states('number.lux_on_grid_discharge_cut_off_soc') | int(0) }} - alias: \"Watchdog: Disarm self\" action: automation.turn_off target: entity_id: automation.luxpower_freeze_charge_watchdog mode: single ``` **Enable Freeze Charging** - Ensure **`switch.predbat_set_charge_freeze`** is turned On. Note that as this is an expert mode option, Predbat's [Expert Mode](customisation.md#expert-mode) must be turned on first. After Predbat recomputes, you may see some light grey **FrzChrg** slots in the state column of the plan. To disable Freeze Charging simply turn the switch Off. Predbat will no longer schedule any FrzChrg slots. --- ### Freeze Exporting If you have a LuxPower inverter with the **Charge Last** feature, enable the Predbat `discharge_freeze_service`. **Note** Freeze Exporting requires fewer supporting automations than Freeze Charging, as it relies primarily on inverter-side behaviour. No additional watchdog or guard logic is required. In your `apps.yaml` file: - Look for `support_discharge_freeze` in the inverter section and change `False` to `True` - Uncomment the last two lines of the `discharge_stop_service` section so Predbat turns `switch.lux_charge_last` off when Freeze exporting stops. - Uncomment the three lines of the `discharge_freeze_service` section so that Predbat turns on the LuxPower Charge Last switch. - Ensure the indentation and alignment match the other service entries. **Enable Freeze Exporting** - Ensure **`switch.predbat_set_export_freeze`** is turned On. After Predbat recomputes, you may see some dark grey **FrzExp** slots in the state column of the plan. To disable Freeze Exporting simply turn the switch Off. Predbat will no longer schedule any FrzExp slots. --- ### Home Assistant restart recovery - Create the following toggle helper and automation to ensure the inverter and Predbat return to a known safe state after a Home Assistant restart. This automation should be created even if you only set up one of the 'Freeze' services above. It must always be enabled. ```yaml name: Predbat Ready entity_id: input_boolean.predbat_ready ```text The `predbat_ready` helper prevents automation actions until LuxPower entities are fully available after startup. Ensure it is On after it has been created. ```yaml alias: LuxPower HA Startup Reset description: > On Home Assistant restart, wait for LuxPower entities to be available, then safely disable freeze charge, override, watchdog, guard boolean, AC/charge and charge last switches, and reset discharge current limit. Marks Predbat ready only after HA and Lux are stable. triggers: - event: start trigger: homeassistant actions: - alias: \"StartupReset: Mark Predbat NOT ready\" target: entity_id: input_boolean.predbat_ready action: input_boolean.turn_off - alias: \"StartupReset: Wait for Lux entities\" wait_template: | {{ states('switch.lux_ac_charge_enable') not in ['unknown','unavailable'] and states('switch.lux_charge_last') not in ['unknown','unavailable'] and states('switch.lux_force_discharge_enable') not in ['unknown','unavailable'] and states('number.lux_discharge_current_limit') not in ['unknown','unavailable'] }} timeout: \"00:02:00\" continue_on_timeout: true - alias: \"StartupReset: Disable freeze/override/watchdog\" target: entity_id: - automation.luxpower_freeze_charge - automation.luxpower_freeze_charge_predbat_override - automation.luxpower_freeze_charge_exit - automation.luxpower_freeze_charge_watchdog action: automation.turn_off - alias: \"StartupReset: Reset guard boolean\" target: entity_id: input_boolean.freeze_charge_guard action: input_boolean.turn_off - alias: \"StartupReset: Wait for battery voltage to be > 0\" wait_template: \"{{ states('sensor.lux_battery_voltage_live') | float > 0 }}\" timeout: \"00:01:00\" continue_on_timeout: true - alias: \"StartupReset: Set discharge current limit from battery_rate_max\" target: entity_id: number.lux_discharge_current_limit data: value: | {{ (states('input_number.battery_rate_max') | float / states('sensor.lux_battery_voltage_live') | float(1)) | round(0) }} action: number.set_value - alias: \"StartupReset: Turn off AC if on\" if: - condition: state entity_id: switch.lux_ac_charge_enable state: \"on\" then: - target: entity_id: switch.lux_ac_charge_enable action: switch.turn_off - alias: \"StartupReset: Turn off charge last if on\" if: - condition: state entity_id: switch.lux_charge_last state: \"on\" then: - target: entity_id: switch.lux_charge_last action: switch.turn_off - alias: \"StartupReset: Turn off force discharge if on\" if: - condition: state entity_id: switch.lux_force_discharge_enable state: \"on\" then: - target: entity_id: switch.lux_force_discharge_enable action: switch.turn_off - alias: \"StartupReset: Final settle delay\" delay: \"00:01:30\" - alias: \"StartupReset: Mark Predbat ready\" target: entity_id: input_boolean.predbat_ready action: input_boolean.turn_on - alias: \"StartupReset: Log completion\" data: level: debug message: \"StartupReset: cleanup complete, watchdog and guard OFF, Predbat ready\" action: system_log.write mode: single Notes If you do not need to record the binary sensor, you can exclude it from the HA recorder by adding the following to your configuration.yaml file: (HA restart required) recorder: exclude: entities: - binary_sensor.solar_compare_home While LuxPower inverters cannot exactly replicate Predbat\u2019s native Freeze Charging behaviour, these automations achieve an equivalent outcome. Any small differences are corrected the next time Predbat recalculates its plan. Troubleshooting If you see recurring Predbat log warnings mentioning scheduled_charge_enable every few minutes, and Predbat switches to Warn during Freeze Charging when solar generation exceeds house load, increase the delay in the LuxPower Freeze Predbat Override automation. Open the automation and locate the delay: \"00:00:10\" entry Increase the delay by a few additional seconds. Save the updated automation. Confirm that the warnings stop appearing when Freeze Charging is active and solar generation exceeds house load. SigEnergy Sigenstor To integrate your Sigenergy Sigenstor inverter with Predbat, you will need to follow the steps below: make sure the inverter is already integrated into Home Assistant. The Predbat configuration has been developed with the SigEnergy local modbus integration (the Python version of the Sigenergy HA integration). Copy the template sigenergy_sigenstor.yaml template over your apps.yaml , and edit for your system. All the Sigenergy entities referenced in apps.yaml need to be enabled for Predbat to use them. The following are disabled by default and will need enabling: sensor.sigen_plant_available_max_discharging_capacity sensor.sigen_plant_daily_consumed_energy number.sigen_plant_ess_backup_state_of_charge number.sigen_plant_ess_charge_cut_off_state_of_charge number.sigen_plant_ess_discharge_cut_off_state_of_charge sensor.sigen_plant_ess_max_charging_limit sensor.sigen_plant_ess_max_discharging_limit sensor.sigen_plant_max_active_power The following additions are needed to facilitate integration with Predbat and need to be put into Home Assistant's configuration.yaml or configured via the HA user interface: input_select: predbat_requested_mode: name: \"Predbat Requested Mode\" options: - \"Demand\" - \"Charging\" - \"Freeze Charging\" - \"Discharging\" - \"Freeze Discharging\" initial: \"Demand\" icon: mdi:battery-unknown input_number: charge_rate: name: Battery charge rate initial: 6950 min: 0 max: 20000 step: 1 mode: box unit_of_measurement: W discharge_rate: name: Battery discharge rate initial: 8000 min: 0 max: 20000 step: 1 mode: box unit_of_measurement: W Add the following automations to automations.yaml (or configure via the UI): - id: predbat_requested_mode_action alias: \"Predbat Requested Mode Action\" description: \"Acts as a mapper for the input_select.predbat_requested_mode to the select.sigen_plant_remote_ems_control_mode\" mode: restart triggers: - trigger: state entity_id: - input_select.predbat_requested_mode conditions: [] actions: - action: select.select_option metadata: {} target: entity_id: select.sigen_plant_remote_ems_control_mode data: option: > {% if is_state('input_select.predbat_requested_mode', \"Demand\") %}Maximum Self Consumption {% elif is_state('input_select.predbat_requested_mode', \"Charging\") %}Command Charging (PV First) {% elif is_state('input_select.predbat_requested_mode', \"Freeze Charging\") %}Maximum Self Consumption {% elif is_state('input_select.predbat_requested_mode', \"Discharging\") %}Command Discharging (PV First) {% elif is_state('input_select.predbat_requested_mode', \"Freeze Discharging\") %}Maximum Self Consumption {% endif %} - choose: # Freeze Charging # Docs: # Freeze charging - The battery is charging but the current battery level (SoC) is frozen (held). Think of it # as a charge to the current battery level. The grid or solar covers any house load. If there is a shortfall of # Solar power to meet house load, the excess house load is met from grid import, but if there is excess Solar # power above the house load, the excess solar will be used to charge the battery # In Sigenergy, this is effectively \"self consumption\" mode with discharging prohibited - conditions: - condition: state entity_id: input_select.predbat_requested_mode state: \"Freeze Charging\" sequence: - service: number.set_value data_template: entity_id: number.sigen_plant_ess_charge_cut_off_state_of_charge value: 100 - service: number.set_value data_template: entity_id: number.sigen_plant_ess_discharge_cut_off_state_of_charge value: 100 - service: number.set_value data_template: entity_id: number.sigen_plant_grid_import_limitation value: 0 # Freeze Discharging # Docs: # Freeze exporting (mapped to Freeze Discharging in sigenergy_sigenstor.yaml) - The battery is in demand mode, # but with charging disabled. The battery or solar covers the house load. As charging is disabled, if there is # excess solar generated, the current SoC level will be held and the excess solar will be exported. If there is # a shortfall of generated solar power to meet the house load, the battery will discharge to meet the extra load. # In Sigenergy, this is effectively \"self consumption\" mode with charging prohibited - conditions: - condition: state entity_id: input_select.predbat_requested_mode state: \"Freeze Discharging\" sequence: - service: number.set_value data_template: entity_id: number.sigen_plant_ess_charge_cut_off_state_of_charge value: 0 - service: number.set_value data_template: entity_id: number.sigen_plant_ess_discharge_cut_off_state_of_charge value: 0 - service: number.set_value data_template: entity_id: number.sigen_plant_grid_import_limitation value: 0 # If neither of the above conditions are met, set the limits to the input numbers - conditions: - condition: not conditions: - condition: state entity_id: input_select.predbat_requested_mode state: \"Freeze Charging\" - condition: state entity_id: input_select.predbat_requested_mode state: \"Freeze Discharging\" sequence: - service: number.set_value data_template: entity_id: number.sigen_plant_ess_charge_cut_off_state_of_charge value: 100 - service: number.set_value data_template: entity_id: number.sigen_plant_ess_discharge_cut_off_state_of_charge value: 0 - service: number.set_value data_template: entity_id: number.sigen_plant_grid_import_limitation value: 100 - id: automation_sigen_ess_max_charging_limit_input_number_action alias: Predbat max charging limit action description: Mapper from input_number.charge_rate to number sigen_plant_ess_max_charging_limit triggers: - trigger: state entity_id: input_number.charge_rate actions: - action: number.set_value target: entity_id: number.sigen_plant_ess_max_charging_limit data: value: '{{ [(states(''input_number.charge_rate'') | float / 1000) | round(2), states(''sensor.sigen_inverter_ess_rated_charging_power'') | float] | min}}' mode: single - id: automation_sigen_ess_max_discharging_limit_input_number_action alias: Predbat max discharging limit action description: Mapper from input_number.discharge_rate to number.sigen_plant_ess_max_discharging_limit triggers: - trigger: state entity_id: input_number.discharge_rate actions: - action: number.set_value target: entity_id: number.sigen_plant_ess_max_discharging_limit data: value: '{{ [(states(''input_number.discharge_rate'') | float / 1000) | round(2), states(''sensor.sigen_inverter_ess_rated_discharging_power'') | float] | min}}' mode: single Note: Some Sigenergy Predbat users have reported that their Sigenergy modbus integration has created some of the entities that Predbat requires with different names so you may need to adapt the above automations and apps.yaml (or rename your entities) to match: sensor.sigen_inverter_ess_rated_discharging_power is instead named sensor.sigen_inverter_ess_rated_discharge_power sensor.sigen_inverter_ess_rated_charging_power is sensor.sigen_inverter_ess_rated_charge_power sensor.sigen_plant_daily_consumed_energy is sensor.sigen_plant_daily_load_consumption Important: Depending upon your electricity supply, you may need to change where number.sigen_plant_grid_import_limitation is set to 100 in the first integration to any lower import limit that your electricity supplier may have imposed, e.g. 18kW roughly corresponds to an 80A supply. Sofar Inverters For this integration, the key elements are: Hardware - sofar2mqtt EPS board - Relatively easy to solder and flash, or can be bought pre-made. Software - Sofar MQTT integration - MQTT integration Home Assistant configuration - sofar_inverter.yaml (in templates directory), defines the custom HA entities and should be added to HA's configuration.yaml . This is the default Sofar HA configuration with a couple of additional inputs to support battery capacity. Predbat configuration - sofar.yaml template for Predbat (in templates directory). This file should be copied over the top of your apps.yaml and edited for your installation Please note that the inverter needs to be put into \"Passive Mode\" for the sofar2mqtt to control the inverter. This integration has various limitations, it can charge and discharge the battery but does not have finer control over reserve and target SoC% Note: You will need to change the min reserve in Home Assistant to match your minimum battery level ( input_number.predbat_set_reserve_min ). Please see this ticket in Github for ongoing discussions: https://github.com/springfall2008/batpred/issues/395 SolarEdge Inverters Please copy the template https://github.com/springfall2008/batpred/blob/main/templates/solaredge.yaml over the top of your apps.yaml and modify it for your system The default entity name prefix for the integration is 'solaredge' but if you have changed this on installation then you will need to amend the apps.yaml template and the template sensors to match your new prefix Ensure that number.solaredge_i1_storage_command_timeout is set to a reasonably high value e.g. 3600 seconds to avoid the commands issued being cancelled Power Control Options, as well as Enable Battery Control, must be enabled in the Solaredge Modbus Multi integration configuration, and switch.solaredge_i1_advanced_power_control must be on. For pv_today , pv_power and load_power sensors to work you need to create these as a template entities within your Home Assistant configuration.yaml . These sensors are not critical so you can just comment them out in apps.yaml if you can't get them to work: template: - sensor: - name: \"Solar Panel Production W\" unique_id: solar_panel_production_w unit_of_measurement: \"W\" icon: mdi:solar-power state: > {% set i1_dc_power = states('sensor.solaredge_i1_dc_power') | float(0) %} {% set b1_dc_power = states('sensor.solaredge_b1_dc_power') | float(0) %} {% if (i1_dc_power + b1_dc_power <= 0) %} 0 {% else %} {{ (i1_dc_power + b1_dc_power) }} {% endif %} availability: > {{ states('sensor.solaredge_i1_dc_power') | is_number and states('sensor.solaredge_b1_dc_power') | is_number }} - name: \"Solar House Consumption W\" unique_id: solar_house_consumption_w unit_of_measurement: \"W\" icon: mdi:home state: > {% set i1_ac_power = states('sensor.solaredge_i1_ac_power') | float(0) %} {% set m1_ac_power = states('sensor.solaredge_m1_ac_power') | float(0) %} {% if (i1_ac_power - m1_ac_power <= 0) %} 0 {% else %} {{ (i1_ac_power - m1_ac_power) }} {% endif %} availability: > {{ states('sensor.solaredge_i1_ac_power') | is_number and states('sensor.solaredge_m1_ac_power') | is_number }} sensor: - platform: integration source: sensor.solar_panel_production_w method: left unit_prefix: k name: solar_panel_production_kwh sensor: - platform: integration source: sensor.solar_house_consumption_w method: left unit_prefix: k name: solar_house_consumption_kwh ```text If you have multiple batteries connected to your SolarEdge inverter and are using the SolarEdge Modbus Multi integration, this enumerates the multiple batteries as b1, b2, b3, etc with separate entities per battery. You will need to make a number of changes to the solaredge apps.yaml, replacing the following entries: ```yaml battery_rate_max: - sensor.calc_power_batteries_max_charge_power # maximum charge power of all the batteries battery_power: - sensor.calc_power_batteries_dc_power soc_percent: - sensor.calc_battery_all_state # average SoC of the batteries soc_max: - sensor.calc_battery_total_capacity # combined kWh maximum value of all the batteries soc_kw: - sensor.calc_battery_current_capacity Set charge_rate and discharge_rate to the SolarEdge inverter values, e.g. 5000 And add the following additional template sensors to configuration.yaml after the existing 'template:' line (from the earlier template sensor definitions): - sensor: # Template sensor for Max Battery Charge rate # This is the sum of all three batteries charge rate as the max charge rate can be higher than inverter capacity (e.g. 8k) when charging from AC+Solar # Returns 5000W as the minimum max value, the single battery charge/discharge limit to ensure at least one battery can always be charged if one or more batteries have 'gone offline' to modbus # Remove all 'B3' entries if you only have two batteries, or follow the same pattern for adding 'B4', etc if you have more than 3 batteries - name: \"Calc Power - Batteries Max Charge Power\" unique_id: calc_power_batteries_max_charge_power unit_of_measurement: \"W\" device_class: \"power\" state_class: \"measurement\" state: > {% set myB1 = float(states('sensor.solaredge_b1_max_charge_power'),0) %} {% set myB2 = float(states('sensor.solaredge_b2_max_charge_power'),0) %} {% set myB3 = float(states('sensor.solaredge_b3_max_charge_power'),0) %} {% set myValue = ((myB1 + myB2 + myB3)) | int %} {{ (myValue if (myValue) > 5000 else 5000) }} # Calculate Total Battery Power Value - name: \"Calc Power - Batteries DC Power\" unique_id: calc_power_batteries_dc_power unit_of_measurement: \"W\" device_class: \"power\" state_class: \"measurement\" state: > {% set myB1 = float(states('sensor.solaredge_b1_dc_power'),0) %} {% set myB2 = float(states('sensor.solaredge_b2_dc_power'),0) %} {% set myB3 = float(states('sensor.solaredge_b3_dc_power'),0) %} {% set myValue = ((myB1 + myB2 + myB3)) %} {{ myValue }} # Average state of charge across the batteries - name: \"Calc Battery All State\" unique_id: calc_battery_all_state unit_of_measurement: \"%\" state: > {% set myB1 = float(states('sensor.solaredge_b1_state_of_energy'),0) %} {% set myB2 = float(states('sensor.solaredge_b2_state_of_energy'),0) %} {% set myB3 = float(states('sensor.solaredge_b3_state_of_energy'),0) %} {% set myValue = ((myB1 + myB2 + myB3) / 3) | round(0) %} {{ myValue }} # Total Energy Stored in the Batteries - name: \"Calc Battery Total Capacity\" unique_id: calc_battery_total_capacity unit_of_measurement: kWh state: > {% set myB1 = float(states('sensor.solaredge_b1_maximum_energy'),0) %} {% set myB2 = float(states('sensor.solaredge_b2_maximum_energy'),0) %} {% set myB3 = float(states('sensor.solaredge_b3_maximum_energy'),0) %} {% set myValue = ((myB1 + myB2 + myB3)) %} {{ myValue }} # Current Energy Stored in the Batteries - name: \"Calc Battery Current Capacity\" unique_id: calc_battery_current_capacity unit_of_measurement: kWh state: > {% set myValue = (float(states('sensor.calc_battery_all_state'),0) / 100) * float(states('sensor.calc_battery_total_capacity'),0) %} {{ myValue }} Solax Cloud Experimental Predbat now has a built-in Solax cloud integration. See the components documentation for details Components - Solax cloud Solax Gen4+ Inverters The Predbat Solax configuration can either either use the Mode1 remote control or the newer Mode8 option. Both should work with the SolaX Gen 4, 5 or 6 inverters. Thanks @TCWORLD for this configuration. Please copy the template https://github.com/springfall2008/batpred/blob/main/templates/solax_sx4.yaml over the top of your apps.yaml , and modify it for your system and the work mode that your inverter is set to Install and configure the Solax Modbus integration in Home Assistant and confirm that it is connected to your inverter The regular expressions in the custom SX4+ apps.yaml should auto-match to the entity names provided by your Solax Modbus integration, but do double-check that they do To use Mode 1 remote control, create and save the following automation script (Settings/Automations/Scripts) which will act as the interface between Predbat and the Solax Modbus integration. You can change the limits for the power field if you have a larger inverter, it doesn't matter if this limit is larger than the inverter can handle as the value gets clipped to the inverter limits by the Solax Modbus integration. You may need to amend the 'solax_' prefixes on the entity names that this script sets if your Modbus integration has slightly different entity names (e.g. 'solaxmodbus_' or 'solax_inverter_'): alias: SolaX Remote Control description: \"\" fields: power: selector: number: min: 0 max: 6600 default: 0 operation: selector: select: multiple: false options: - Disabled - Force Charge - Force Discharge - Freeze Charge - Freeze Discharge default: Disabled required: false duration: selector: number: min: 300 max: 86400 default: 28800 required: false sequence: - variables: defaultPower: \"{{ 200 }}\" mode: |- {% set map = { 'Disabled': 'Disabled', 'Force Charge': 'Enabled Battery Control', 'Force Discharge': 'Enabled Battery Control', 'Freeze Charge': 'Enabled No Discharge', 'Freeze Discharge': 'Enabled Feedin Priority'} %} {{ map.get( operation, 'Disabled' ) }} activeP: >- {% set chargePower = (power | int(defaultPower)) if power is defined else defaultPower %} {% set dischargePower = (0 - chargePower) %} {% set map = { 'Disabled': 0, 'Force Charge': chargePower, 'Force Discharge': dischargePower, 'Freeze Charge': 0, 'Freeze Discharge': 0} %} {{ map.get( operation, 0 ) }} - action: number.set_value data: value: \"{{ activeP }}\" target: entity_id: number.solax_remotecontrol_active_power - action: number.set_value data: value: \"60\" target: entity_id: number.solax_remotecontrol_duration - action: number.set_value data: value: \"{{ duration if duration is defined else 28800 }}\" target: entity_id: number.solax_remotecontrol_autorepeat_duration - action: select.select_option data: option: \"{{ mode if mode is defined else Disabled }}\" target: entity_id: select.solax_remotecontrol_power_control - action: button.press data: {} target: entity_id: button.solax_remotecontrol_trigger mode: queued max: 10 To use Mode 1 remote control, ensure the following entities are enabled: number.solax_remotecontrol_active_power number.solax_remotecontrol_duration number.solax_remotecontrol_autorepeat_duration select.solax_remotecontrol_power_control button.solax_remotecontrol_trigger To use Mode 8 power control API (Gen 4 or newer inverter) which has direct control over the battery charge/discharge rate, and can directly set the battery (dis)charge rate without limiting any PV generation, create and save the following automation script (Settings/Automations/Scripts) which will act as the interface between Predbat and the Solax Modbus integration. In the script, change 'maxPvPower: \"{{ 12000 }}\"' to a value larger than your PV array size so the script doesn't limit PV generation. Change 'max: 6600' - to a value larger than the maximum charge/discharge power for your battery (doesn't matter if higher). Note: Mode8 requires version 2025.10.7 or newer of the SolaX Modbus integration as there are some necessary Mode 8 improvements added: alias: SolaX Remote Control (Mode 8) description: \"\" fields: power: selector: number: min: 0 max: 6600 default: 0 operation: selector: select: multiple: false options: - Disabled - Force Charge - Force Discharge - Freeze Charge - Freeze Discharge default: Disabled required: false duration: selector: number: min: 60 max: 86400 default: 28800 sequence: - variables: maxPvPower: \"{{ 12000 }}\" defaultPower: \"{{ 200 }}\" mode: |- {% set map = { 'Disabled': 'Disabled', 'Force Charge': 'Mode 8 - PV and BAT control - Duration', 'Force Discharge': 'Mode 8 - PV and BAT control - Duration', 'Freeze Charge': 'Enabled No Discharge', 'Freeze Discharge': 'Export-First Battery Limit'} %} {{ map.get( operation, 'Disabled' ) }} activeP: >- {% set dischargePower = (power | int(defaultPower)) if power is defined else defaultPower %} {% set chargePower = (0 - dischargePower) %} {% set map = { 'Disabled': 0, 'Force Charge': chargePower, 'Force Discharge': dischargePower, 'Freeze Charge': 0, 'Freeze Discharge': 0} %} {{ map.get( operation, 0 ) }} - action: number.set_value data: value: \"{{ activeP }}\" target: entity_id: number.solax_remotecontrol_push_mode_power_8_9 - action: number.set_value data: value: \"{{ maxPvPower }}\" target: entity_id: number.solax_remotecontrol_pv_power_limit - action: number.set_value data: value: \"30\" target: entity_id: number.solax_remotecontrol_duration - action: number.set_value data: value: \"300\" target: entity_id: number.solax_remotecontrol_timeout - action: number.set_value data: value: \"{{ duration if duration is defined else 28800 }}\" target: entity_id: number.solax_remotecontrol_autorepeat_duration - action: select.select_option data: option: VPP Off target: entity_id: select.solax_inverter_remotecontrol_timeout_next_motion_mode_1_9 - action: select.select_option data: option: \"{{ mode if mode is defined else Disabled }}\" target: entity_id: select.solax_remotecontrol_power_control_mode - action: button.press data: {} enabled: true target: entity_id: button.solax_powercontrolmode8_trigger mode: queued max: 10 To use Mode 8 power control, ensure the following entities are enabled: number.solax_remotecontrol_push_mode_power_8_9 number.solax_remotecontrol_pv_power_limit number.solax_remotecontrol_duration number.solax_remotecontrol_timeout number.solax_remotecontrol_autorepeat_duration select.solax_inverter_remotecontrol_timeout_next_motion_mode_1_9 select.solax_remotecontrol_power_control_mode button.solax_powercontrolmode8_trigger Predbat needs a 'Todays House Load' sensor, this can be created from inverter-supplied information by creating two custom helper entities: Create a helper entity of type 'Integral', set the Name to 'Todays House Load Integral', Metric Prefix to 'k (kilo)', Time unit to 'Hours', Input sensor to 'House Load', Integration method to 'Trapezoidal', Precision to '2' and Max sub-interval to '0:05:00' Create a helper entity of type 'Utility Meter', set the Name to 'Todays House Load', Input sensor to 'Todays House Load Integral' (that you just created) and Meter Reset Cycle to 'Daily' If you are using the inverter in Backup mode then you will need to set input_number.predbat_set_reserve_min to no lower than 15% minimum SoC, other modes allow a lower minimum SoC of 10%. This is a Solax limitation. It has been reported by one Solax user that his inverter did not respond to commands from either the mode 1 or mode 8 scripts. The fix was to enable the hidden HA entity 'VPP Exit Idle Enable' and then change the entity value from Disabled to Enabled. Once this was Enabled the inverter responded correctly to Predbat commands. When you first start Predbat, check the Predbat log to confirm that the correct sensor names are identified by the regular expressions in apps.yaml . Any non-matching expressions should be investigated and resolved. Please see this ticket in Github for ongoing discussion: https://github.com/springfall2008/batpred/issues/259 Solis Cloud Experimental Predbat now has a built-in Solis cloud integration. See the components documentation for details Components - Solis cloud Solis Inverters before FB00 To run PredBat with Solis hybrid inverters with firmware level prior to FB00 (you can recognise these by having fewer than 6 slots for charging times), follow the following steps: Install PredBat as per the Installation Summary Ensure that you have the Solax Modbus integration running and select the inverter type solis. There are a number of entities which this integration disables by default that you will need to enable via the Home Assistant GUI: Name Description sensor.solis_rtc Real Time Clock sensor.solis_battery_power Battery Power Copy the template https://github.com/springfall2008/batpred/blob/main/templates/gilong_solis.yaml over the top of your apps.yaml , and modify it for your system Set solax_modbus_new in apps.yaml to True if you have integration version 2024.03.2 or greater Ensure that the inverter is set to Control Mode 35 - on the Solax integration this is Timed Charge/Discharge . If you want to use the Reserve functionality within PredBat you will need to select Backup/Reserve (code 51) instead but be aware that this is not fully tested. In due course, these mode settings will be incorporated into the code. Your inverter will require a \"button press\" triggered by Predbat to update the schedules. Some Solis inverter integrations feature a combined charge/discharge update button, in which case a single apps.yaml entry of: charge_discharge_update_button: - button.solis_update_charge_discharge_times Ensure the correct entity IDs are used for your specific inverter setup. These entries should correspond to the buttons exposed by your Home Assistant Solis integration. Solis Inverters FB00 or later To run PredBat with Solis hybrid inverters with firmware level FB00 or later (you can recognise these by having 6 slots for charging times), follow the following steps: Install PredBat as per the Installation Summary Ensure that you have the Solax Modbus integration running and select the inverter type solis_fb00. There are a number of entities which this integration disables by default that you will need to enable via the Home Assistant GUI: Name Description sensor.solisx_rtc Real Time Clock sensor.solisx_battery_power Battery Power Copy the template https://github.com/springfall2008/batpred/blob/main/templates/gilong_solis.yaml over the top of your apps.yaml , and modify it for your system. You will need to update these lines: Replace inverter_type: \"GS\" with inverter_type: \"GS_fb00\" to enable the inverter template for the newer firmware version of Solis inverters Un-comment charge_update_button and discharge_update_button and comment out charge_discharge_update_button to enable the two \"button presses\" needed for writing charge/discharge times to the inverter Un-comment scheduled_charge_enable and scheduled_discharge_enable to enable Predbat to enable/disable the charge/discharge slots Un-comment charge_limit to enable the charge limit through setting an upper SoC value Set solax_modbus_new to True if you have integration version 2024.03.2 or greater Lastly you will need to comment out or delete the template line to enable the configuration Save the file as apps.yaml to the appropriate Predbat software directory . Ensure that the inverter is set to Control Mode 35 - on the Solax integration this is Timed Charge/Discharge . If you want to use the Reserve functionality within PredBat you will need to select Backup/Reserve (code 51) instead but be aware that this is not fully tested. In due course, these mode settings will be incorporated into the code. Note: Predbat will read the minimum SoC level set on the inverter via sensor.solis_battery_minimum_soc configured in apps.yaml . You must set the minimum SoC level that Predbat will set in input_number.predbat_set_reserve_min to at least 1% more than the inverter minimum SoC. So for example, if the inverter minimum SoC is set to 20%, predbat_set_reserve_min must be set to at least 21%. If this is not done then when Predbat sets the reserve SoC, the instruction will be rejected by the inverter and Predbat will error. Ensure the correct entity IDs are used for your specific inverter setup. These entries should correspond to the buttons exposed by your Home Assistant Solis integration. Sunsynk Copy the Sunsynk template over the top of your apps.yaml , and edit for your system. Create the following Home Assistant automations: alias: Predbat Charge / Discharge Control description: \"Turn SunSynk charge/discharge on/off to mirror Predbat\" trigger: - platform: state entity_id: - binary_sensor.predbat_charging to: \"on\" id: predbat_charge_on - platform: state entity_id: - binary_sensor.predbat_charging to: \"off\" id: predbat_charge_off - platform: state entity_id: - binary_sensor.predbat_exporting to: \"on\" id: predbat_discharge_on - platform: state entity_id: - binary_sensor.predbat_exporting to: \"off\" id: predbat_discharge_off condition: [] action: - choose: - conditions: - condition: trigger id: - predbat_charge_on sequence: - service: switch.turn_on data: {} target: entity_id: switch.sunsynk_grid_charge_timezone1 - conditions: - condition: trigger id: - predbat_charge_off sequence: - service: switch.turn_off target: entity_id: - switch.sunsynk_grid_charge_timezone1 data: {} - conditions: - condition: trigger id: - predbat_discharge_on sequence: - service: switch.turn_on data: {} target: entity_id: switch.sunsynk_solar_sell - conditions: - condition: trigger id: - predbat_discharge_off sequence: - service: switch.turn_off target: entity_id: - switch.sunsynk_solar_sell data: {} mode: single alias: PredBat - Copy Charge Limit description: Copy Battery SoC to all timezone (time) slots trigger: - platform: state entity_id: - number.sunsynk_set_soc_timezone1 to: null condition: [] action: - service: number.set_value data_template: entity_id: - number.sunsynk_set_soc_timezone2 - number.sunsynk_set_soc_timezone3 - number.sunsynk_set_soc_timezone4 - number.sunsynk_set_soc_timezone5 - number.sunsynk_set_soc_timezone6 value: \"{{ states('number.sunsynk_set_soc_timezone1')|int(20) }}\" mode: single Create the following templates sensors in your configuration.yaml : template: sensor: - name: \"sunsynk_max_battery_charge_rate\" unit_of_measurement: \"w\" state_class: measurement state: > {{ [8000,[states('input_number.sunsynk_battery_max_charge_current_limit')|int,states('sensor.sunsynk_battery_charge_limit_current')|int]|min * states('sensor.sunsynk_battery_voltage')|float]|min }} - name: \"sunsynk_max_battery_discharge_rate\" unit_of_measurement: \"w\" state_class: measurement state: > {{ [8000,[states('input_number.sunsynk_battery_max_discharge_current_limit')|int,states('sensor.sunsynk_battery_discharge_limit_current')|int]|min * states('sensor.sunsynk_battery_voltage')|float]|min }} - name: \"sunsynk_charge_rate_calc\" unit_of_measurement: \"w\" state_class: measurement state: > {{ [8000,[states('input_number.test_sunsynk_battery_max_charge_current')|int,states('sensor.sunsynk_battery_charge_limit_current')|int]|min * states('sensor.sunsynk_battery_voltage')|float]|min }} - name: \"sunsynk_discharge_rate_calc\" unit_of_measurement: \"w\" state_class: measurement state: > {{ [8000,[states('input_number.test_sunsynk_battery_max_discharge_current')|int,states('sensor.sunsynk_battery_discharge_limit_current')|int]|min * states('sensor.sunsynk_battery_voltage')|float]|min }} Tesla Powerwall Integration of the Tesla Powerwall follows the approach outlined in Ed Hull's blog . Ed's setup only covered Predbat controlling charging the Powerwall, the below configuration (thanks @Slee2112) covers both charging and discharging (exporting). Note: This Predbat Tesla configuration has been developed with a Powerwall 3. It may require changes for older Powerwall models. Please raise a GitHub issue with details of any changes you find are required so the documentation can be updated. The Predbat Tesla apps.yaml configuration was developed using the Tesla Fleet integration, and you can use this, or you can use the Teslemetry integration which provides easier access to Tesla API's, but requires a Teslemetry subscription Install and configure either the Tesla Fleet integration or Teslemetry integration in Home Assistant Copy the template tesla_powerwall.yaml template over the top of your apps.yaml , and edit for your system Exporting with Powerwall is tricky, as there is no built in button as such to do it, you have to trick the Powerwall to export by changing the tariff options using the Tesla API. In order to do this you firstly need to create an API refresh token. Create 8 input_text helpers to hold the Tesla access and refresh security tokens and your Tesla site id. These can be created via the HA UI, or added to configuration.yaml : input_text: tesla_refresh_token_part1: name: \"Tesla Refresh Token - Part 1\" max: 255 mode: password tesla_refresh_token_part2: name: \"Tesla Refresh Token - Part 2\" max: 255 mode: password tesla_refresh_token_part3: name: \"Tesla Refresh Token - Part 3\" max: 255 mode: password tesla_refresh_token_part4: name: \"Tesla Refresh Token - Part 4\" max: 255 mode: password tesla_access_token_part1: name: \"Tesla Access Token - Part 1\" max: 255 mode: password tesla_access_token_part2: name: \"Tesla Access Token - Part 2\" max: 255 mode: password tesla_access_token_part3: name: \"Tesla Access Token - Part 3\" max: 255 mode: password tesla_access_token_part4: name: \"Tesla Access Token - Part 4\" max: 255 mode: password tesla_energy_site_id: name: \"Tesla Energy Site ID\" unit_of_measurement: \"\" icon: mdi:lightning-bolt-outline Use the Access Token Generator for Tesla to create a token This token needs to be copied, and then split into 4 parts (up to 255 characters long), so each part can be copied into the \"refresh\" input helpers An automation then uses the refresh token to generate an access token valid for 8 hours, and a new refresh token than is valid for ~30 days. Create the following automation using the HA UI or by adding to configuration.yaml , the automation triggers an automatic refresh of the access token every 8 hours: automation: alias: \"Refresh Tesla Access Token\" description: \"Refresh Tesla access token every 8 hours\" trigger: platform: time_pattern hours: \"/8\" action: - service: rest_command.tesla_refresh_token response_variable: tesla_response - service: input_text.set_value target: entity_id: input_text.tesla_access_token_part1 data: value: \"{{ tesla_response.content.access_token[0:250] }}\" - service: input_text.set_value target: entity_id: input_text.tesla_access_token_part2 data: value: \"{{ tesla_response.content.access_token[250:500] }}\" - service: input_text.set_value target: entity_id: input_text.tesla_access_token_part3 data: value: \"{{ tesla_response.content.access_token[500:750] }}\" - service: input_text.set_value target: entity_id: input_text.tesla_access_token_part4 data: value: \"{{ tesla_response.content.access_token[750:] }}\" - service: input_text.set_value target: entity_id: input_text.tesla_refresh_token_part1 data: value: \"{{ tesla_response.content.refresh_token[0:250] }}\" - service: input_text.set_value target: entity_id: input_text.tesla_refresh_token_part2 data: value: \"{{ tesla_response.content.refresh_token[250:500] }}\" - service: input_text.set_value target: entity_id: input_text.tesla_refresh_token_part3 data: value: \"{{ tesla_response.content.refresh_token[500:750] }}\" - service: input_text.set_value target: entity_id: input_text.tesla_refresh_token_part4 data: value: \"{{ tesla_response.content.refresh_token[750:] }}\" - service: persistent_notification.create data: title: \"Tesla Tokens Updated\" message: \"Access and refresh tokens have been successfully updated\" notification_id: \"tesla_token_update\" An automation executes every time HA starts and every midnight to populate the Tesla site id input_helper. Create the following automation using the HA UI or by adding to configuration.yaml : automation: - alias: \"Update Tesla Energy Site ID\" trigger: - platform: homeassistant event: start - platform: time at: \"00:00:00\" action: - service: rest_command.tesla_api_get_products response_variable: products_response - service: input_text.set_value target: entity_id: input_text.tesla_energy_site_id data: value: \"{{ products_response.content.response[0].energy_site_id }}\" A number of REST commands are required to communicate to the Tesla API's: tesla_refresh_token - automatically regenerates access and refresh tokens, tesla_api_get_products - used to retrieve your Tesla site id, tesla_api_get_current_tariff - retrieves your current Tariff information from the Powerwall, tesla_api_set_export_now_tariff - sets a custom export rate tariff to force the Powerwall to export, tesla_api_set_iog_custom_tariff - returns the Powerwall to the Octopus IOG tariff. If you are on a different tariff you will need to customise the REST payload to your tariff details In configuration.yaml add the following lines: rest_command: tesla_refresh_token: url: \"https://auth.tesla.com/oauth2/v3/token\" method: POST content_type: \"application/x-www-form-urlencoded\" payload: >- grant_type=refresh_token&client_id=ownerapi&refresh_token={{ (states('input_text.tesla_refresh_token_part1') or '') + (states('input_text.tesla_refresh_token_part2') or '') + (states('input_text.tesla_refresh_token_part3') or '') + (states('input_text.tesla_refresh_token_part4') or '') }}&scope=openid%20email%20offline_access\" tesla_api_get_products: url: \"https://owner-api.teslamotors.com/api/1/products\" method: GET headers: Authorization: >- Bearer {{ (states('input_text.tesla_access_token_part1') or '') + (states('input_text.tesla_access_token_part2') or '') + (states('input_text.tesla_access_token_part3') or '') + (states('input_text.tesla_access_token_part4') or '') }} tesla_api_get_current_tariff: url: \"https://owner-api.teslamotors.com/api/1/energy_sites/{{ states('input_text.tesla_energy_site_id') }}/tariff_rate\" method: GET headers: Authorization: >- Bearer {{ (states('input_text.tesla_access_token_part1') or '') + (states('input_text.tesla_access_token_part2') or '') + (states('input_text.tesla_access_token_part3') or '') + (states('input_text.tesla_access_token_part4') or '') }} tesla_api_set_export_now_tariff: url: \"https://owner-api.teslamotors.com/api/1/energy_sites/{{ states('input_text.tesla_energy_site_id') }}/time_of_use_settings\" method: POST headers: Authorization: >- Bearer {{ (states('input_text.tesla_access_token_part1') or '') + (states('input_text.tesla_access_token_part2') or '') + (states('input_text.tesla_access_token_part3') or '') + (states('input_text.tesla_access_token_part4') or '') }} Content-Type: application/json payload: > {% set now = now() %} {% set minute = now.minute %} {% set start = now.replace(minute=0) if minute < 30 else now.replace(minute=30) %} {% set end = start + timedelta(minutes=60) %} {% set ns = namespace(super_off_peak_periods=[]) %} {% if start.hour > 0 %} {% set ns.super_off_peak_periods = ns.super_off_peak_periods + [{\"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 0, \"fromMinute\": 0, \"toHour\": start.hour, \"toMinute\": start.minute}] %} {% endif %} {% if end.hour > 0 %} {% set ns.super_off_peak_periods = ns.super_off_peak_periods + [{\"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": end.hour, \"fromMinute\": end.minute, \"toHour\": 0, \"toMinute\": 0}] %} {% endif %} { \"tou_settings\": { \"tariff_content_v2\": { \"version\": 1, \"utility\": \"Octopus Energy\", \"code\": \"OCTO-IOG-CUSTOM\", \"name\": \"Octopus IOG (Force Export Now)\", \"currency\": \"GBP\", \"monthly_minimum_bill\": 0, \"min_applicable_demand\": 0, \"max_applicable_demand\": 0, \"monthly_charges\": 0, \"daily_charges\": [ { \"name\": \"Charge\", \"amount\": 0 } ], \"daily_demand_charges\": {}, \"demand_charges\": { \"ALL\": { \"rates\": { \"ALL\": 0 } }, \"AllYear\": { \"rates\": {} } }, \"energy_charges\": { \"ALL\": { \"rates\": { \"ALL\": 0 } }, \"AllYear\": { \"rates\": { \"SUPER_OFF_PEAK\": 0.07, \"ON_PEAK\": 0.31 } } }, \"seasons\": { \"AllYear\": { \"fromMonth\": 1, \"fromDay\": 1, \"toMonth\": 12, \"toDay\": 31, \"tou_periods\": { \"SUPER_OFF_PEAK\": { \"periods\": {{ ns.super_off_peak_periods | tojson }} }, \"ON_PEAK\": { \"periods\": [ { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": {{ start.hour }}, \"fromMinute\": {{ start.minute }}, \"toHour\": {{ end.hour }}, \"toMinute\": {{ end.minute }} } ] } } } }, \"sell_tariff\": { \"min_applicable_demand\": 0, \"max_applicable_demand\": 0, \"monthly_minimum_bill\": 0, \"monthly_charges\": 0, \"utility\": \"Octopus Energy\", \"daily_charges\": [ { \"name\": \"Charge\", \"amount\": 0 } ], \"demand_charges\": { \"ALL\": { \"rates\": { \"ALL\": 0 } }, \"AllYear\": { \"rates\": {} } }, \"energy_charges\": { \"ALL\": { \"rates\": { \"ALL\": 0 } }, \"AllYear\": { \"rates\": { \"SUPER_OFF_PEAK\": 0.07, \"ON_PEAK\": 0.30 } } }, \"seasons\": { \"AllYear\": { \"fromMonth\": 1, \"fromDay\": 1, \"toMonth\": 12, \"toDay\": 31, \"tou_periods\": { \"SUPER_OFF_PEAK\": { \"periods\": {{ ns.super_off_peak_periods | tojson }} }, \"ON_PEAK\": { \"periods\": [ { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": {{ start.hour }}, \"fromMinute\": {{ start.minute }}, \"toHour\": {{ end.hour }}, \"toMinute\": {{ end.minute }} } ] } } } } } } } } tesla_api_set_iog_custom_tariff: url: \"https://owner-api.teslamotors.com/api/1/energy_sites/{{ states('input_text.tesla_energy_site_id') }}/time_of_use_settings\" method: POST headers: Authorization: >- Bearer {{ (states('input_text.tesla_access_token_part1') or '') + (states('input_text.tesla_access_token_part2') or '') + (states('input_text.tesla_access_token_part3') or '') + (states('input_text.tesla_access_token_part4') or '') }} Content-Type: application/json payload: > { \"tou_settings\": { \"tariff_content_v2\": { \"version\": 1, \"monthly_minimum_bill\": 0, \"min_applicable_demand\": 0, \"max_applicable_demand\": 0, \"monthly_charges\": 0, \"utility\": \"Octopus Energy\", \"code\": \"OCTO-IOG-CUSTOM\", \"name\": \"Octopus IOG (Custom-restored)\", \"currency\": \"GBP\", \"daily_charges\": [ { \"name\": \"Charge\", \"amount\": 0 } ], \"daily_demand_charges\": {}, \"demand_charges\": { \"ALL\": { \"rates\": { \"ALL\": 0 } }, \"AllYear\": { \"rates\": {} } }, \"energy_charges\": { \"ALL\": { \"rates\": { \"ALL\": 0 } }, \"AllYear\": { \"rates\": { \"SUPER_OFF_PEAK\": 0.07, \"PARTIAL_PEAK\": 0.31, \"ON_PEAK\": 0.31 } } }, \"seasons\": { \"AllYear\": { \"fromMonth\": 1, \"fromDay\": 1, \"toMonth\": 12, \"toDay\": 31, \"tou_periods\": { \"SUPER_OFF_PEAK\": { \"periods\": [ { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 0, \"fromMinute\": 0, \"toHour\": 5, \"toMinute\": 30 }, { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 23, \"fromMinute\": 30, \"toHour\": 0, \"toMinute\": 0 } ] }, \"ON_PEAK\": { \"periods\": [ { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 2, \"fromMinute\": 0, \"toHour\": 3, \"toMinute\": 0 }, { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 5, \"fromMinute\": 30, \"toHour\": 16, \"toMinute\": 0 }, { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 16, \"fromMinute\": 0, \"toHour\": 19, \"toMinute\": 0 }, { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 19, \"fromMinute\": 0, \"toHour\": 23, \"toMinute\": 30 } ] } } } }, \"sell_tariff\": { \"min_applicable_demand\": 0, \"max_applicable_demand\": 0, \"monthly_minimum_bill\": 0, \"monthly_charges\": 0, \"utility\": \"Octopus Energy\", \"daily_charges\": [ { \"name\": \"Charge\", \"amount\": 0 } ], \"demand_charges\": { \"ALL\": { \"rates\": { \"ALL\": 0 } }, \"AllYear\": { \"rates\": {} } }, \"energy_charges\": { \"ALL\": { \"rates\": { \"ALL\": 0 } }, \"AllYear\": { \"rates\": { \"SUPER_OFF_PEAK\": 0.07, \"PARTIAL_PEAK\": 0.30, \"ON_PEAK\": 0.22 } } }, \"seasons\": { \"AllYear\": { \"fromMonth\": 1, \"fromDay\": 1, \"toMonth\": 12, \"toDay\": 31, \"tou_periods\": { \"SUPER_OFF_PEAK\": { \"periods\": [ { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 0, \"fromMinute\": 0, \"toHour\": 5, \"toMinute\": 30 }, { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 23, \"fromMinute\": 30, \"toHour\": 0, \"toMinute\": 0 } ] }, \"ON_PEAK\": { \"periods\": [ { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 2, \"fromMinute\": 0, \"toHour\": 3, \"toMinute\": 0 }, { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 5, \"fromMinute\": 30, \"toHour\": 16, \"toMinute\": 0 }, { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 16, \"fromMinute\": 0, \"toHour\": 19, \"toMinute\": 0 }, { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 19, \"fromMinute\": 0, \"toHour\": 23, \"toMinute\": 30 } ] } } } } } } } } Manually run the two automations to ensure the helper input_texts are all pre-populated before use. Victron This is at an early stage of development, see Github discussion #789 and #2846 I want to add an unsupported inverter to Predbat First copy one of the template configurations that is close to your system and try to configure it to match the sensors you have Create a GitHub ticket for support and add what you know to the ticket Then find out how to control your inverter inside Home Assistant, ideally share any automation you have to control the inverter You can create a new inverter type in apps.yaml and change the options as to which controls it has You must set inverter_type in apps.yaml with a custom name ('MINE' in the example below) - if you do not do this then Predbat will assume you have a GivEnergy inverter and will apply inverter limits for that inverter (e.g. max charge/discharge of 2600W) Configure Predbat with the appropriate Home Assistant services to start charges and discharges, etc. The following template can be used as a starting point: inverter_type: MINE inverter: name: \"MINE\" has_rest_api: False has_mqtt_api: False has_service_api: True output_charge_control: \"power\" charge_control_immediate: False current_dp: 1 charge_discharge_with_rate: False has_charge_enable_time: False has_discharge_enable_time: False has_target_soc: False target_soc_used_for_discharge: True has_reserve_soc: False has_timed_pause: False time_button_press: False support_charge_freeze: False support_discharge_freeze: False has_ge_inverter_mode: False has_fox_inverter_mode: False has_idle_time: False has_time_window: False charge_time_format: \"S\" charge_time_entity_is_option: False can_span_midnight: False clock_time_format: \"%Y-%m-%d %H:%M:%S\" num_load_entities: 1 soc_units: \"%\" write_and_poll_sleep: 2 # Services to control charging/discharging charge_start_service: service: select.select_option entity_id: \"select.solaredge_i1_storage_command_mode\" option: \"Charge from Solar Power and Grid\" charge_stop_service: service: select.select_option entity_id: \"select.solaredge_i1_storage_command_mode\" option: \"Charge from Solar Power\" discharge_start_service: service: select.select_option entity_id: \"select.solaredge_i1_storage_command_mode\" option: \"Maximize Self Consumption\" Inverter control options The following options are supported per inverter: has_rest_api When True the REST API will be used to fetch data/control the inverter. This is currently only for GivEnergy inverters with GivTCP and givtcp_rest must be set in apps.yaml has_mqtt_api When True the Home Assistant MQTT API will be used to issue control messages for the inverter The MQTT/publish service is used with the topic as defined by mqtt_topic in apps.yaml Messages will be sent through these controls: Values that are updated: topic /set/reserve - payload=reserve topic /set/charge_rate - payload=new_rate topic /set/discharge_rate - payload=new_rate topic /set/target_soc - payload=target_soc These three messages change between battery charge/discharge and auto (demand) mode: topic /set/charge - payload=charge_rate topic /set/discharge - payload=discharge_rate topic /set/auto - payload=true has_service_api When True a Home Assistant service will be used to issue control messages for the inverter. For each service you wish to use it must be defined in apps.yaml . There are two ways to define a service, the basic mode: charge_start_service: my_service_name_charge Will call my_service_name_charge for the charge start service. Or the custom method where you can define all the parameter values passed to the service and use the default values from the template, or define your own: charge_start_service: - service: my_charge_start_service device_id: \"{device_id}\" power: \"{power}\" soc: \"{target_soc}\" charge_start_time: \"{charge_start_time}\" charge_end_time: \"{charge_end_time}\" ```text You can also call more than one service e.g: ```yaml charge_start_service: - service: my_charge_start_service device_id: \"{device_id}\" power: \"{power}\" soc: \"{target_soc}\" - service: switch.turn_off entity_id: switch.tsunami_charger Note: By default the service will only be called once until things change, e.g. charge_start_service will be called once and then won't be called again until charge_stop_service stops the charge. If however, you want the service to be called on each Predbat run then you should set repeat to True for the given service e.g: yaml charge_start_service: - service: my_charge_start_service device_id: \"{device_id}\" power: \"{power}\" soc: \"{target_soc}\" repeat: True text charge_start_service Called to start a charge The default options passed in are: device_id - as defined in apps.yaml by device_id target_soc - The SoC to charge to power - The charge power to use charge_start_time - Start time for the charge charge_end_time - End time for the charge charge_freeze_service If defined will be called for freeze charge, otherwise, charge_start_service is used for freeze charge also. Note that switch.predbat_set_charge_freeze must be turned on for Predbat to plan Freeze Charge activity, and as this is an expert mode option, Predbat's Expert Mode must be turned on first. charge_stop_service Called to stop a charge device_id - as defined in apps.yaml by device_id discharge_start_service Called to start a discharge The default options passed in are: device_id - as defined in apps.yaml by device_id target_soc - The SoC to discharge to power - The discharge power to use discharge_freeze_service If defined will be called for Discharge freeze, otherwise, discharge_start_service is used for freeze discharge also. discharge_stop_service Called to stop a discharge, if not set then charge_stop_service will be used instead device_id - as defined in apps.yaml by device_id output_charge_control Controls what charge control units are to be used when starting charging. Set to \"power\", \"current\" or \"none\". When set to \"power\", Predbat will use the inverter sensors configured as charge_rate and discharge_rate in apps.yaml to set the inverter charge/discharge power levels. These inverter sensors must be in watts. When set to \"current\", Predbat will use the inverter sensors configured as timed_charge_current and timed_discharge_current in apps.yaml to set the inverter charge/discharge current levels. These inverter sensors must be in amps. Additionally if you are using \"current\" control for your inverter you must set battery_voltage in apps.yaml to your nominal maximum battery voltage (NB: not the current battery voltage) as Predbat will use this to convert its output commands from watts to amps for the inverter. charge_control_immediate When True, the inverter uses timed_charge_current and timed_discharge_current in apps.yaml to control charging and discharging by setting current levels directly, instead of following a time-based plan. current_dp Sets the number of decimal places to be used when setting the current in Amps, which should be 0 or 1. charge_discharge_with_rate When True, the inverter requires that when charging the discharge rate must set be 0; and vice-versa, when discharging the charge rate must be set to 0. When False, the charge/discharge rate does not have to change. has_charge_enable_time When True, Predbat uses the scheduled_charge_enable switch configured in apps.yaml to enable/disable timed charging on the inverter. has_discharge_enable_time When True, Predbat uses the scheduled_discharge_enable switch configured in apps.yaml to enable/disable timed discharging on the inverter. has_target_soc When True, Predbat uses the charge_limit sensor configured in apps.yaml to set the target charge SoC % setting for the inverter. The charge limit is the limit that the inverter will charge the battery up to. When False, charging will be turned on and off by Predbat rather than the inverter doing it based on the target SoC %. target_soc_used_for_discharge When True, Predbat will use the charge_limit sensor configured in apps.yaml to control the target discharge SoC% for the inverter. When False, Predbat will not adjust the charge_limit sensor when discharging. has_reserve_soc When True, Predbat uses the reserve sensor configured in apps.yaml to set the discharge reserve SoC % for the inverter. The reserve SoC is the target % to discharge the battery down to. When False, discharging will be turned on and off by Predbat rather than the inverter doing it based on discharge SoC %. has_timed_pause When True, Predbat uses the pause_mode and optional pause_start_time and pause_end_time settings in apps.yaml to pause the inverter from charging and discharging the battery. This setting is for GivEnergy systems only right now. time_button_press When True, the inverter requires a button press to update the inverter registers from the Home Assistant values. The apps.yaml setting charge_discharge_update_button is the entity name of the button that Predbat will \"push\" to update the inverter registers. support_charge_freeze When True, the inverter supports charge freeze modes. support_discharge_freeze When True, the inverter supports discharge freeze modes. has_ge_inverter_mode When True, the inverter supports the GivEnergy inverter modes (ECO, Timed Export etc). has_fox_inverter_mode When True, the inverter supports Fox inverter modes, i.e. Eco (Paused) is treated the same as Eco mode and the inverter mode is always set to \"SelfUse\" as all charging and discharging is controlled by schedule, not inverter modes. has_idle_time When True, the inverter has an idle time register which must be set to the start and end times for Eco mode (GivEnergy EMS). idle_start_time and idle_end_time must be configured in apps.yaml to the appropriate inverter controls. has_time_window Not currently used by Predbat. charge_time_format This setting is used to control what format of charge and discharge times the inverter requires. When set to \"HH:MM:SS\", Predbat will control the inverter charge/discharge start and end times by setting the entities defined by charge_start_time , charge_end_time , discharge_start_time and discharge_end_time in apps.yaml . The format of these entities depends on charge_time_entity_is_option as defined below. When set to \"H M\", Predbat will control the inverter charge/discharge start and end times by setting the entities defined by charge_start_hour , charge_start_minute , charge_end_hour , charge_end_minute , discharge_start_hour , discharge_start_minute , discharge_end_hour and discharge_end_minute in apps.yaml . These entities are used to set the start and end hours and minutes of charges and discharges. When set to \"H:M-H:M\", Predbat will control the inverter charge/discharge start and end times by setting the entities defined by charge_time and discharge_time in apps.yaml . The entities take a single time range value in the format \" start hour : start minute - end hour : end minute \" charge_time_entity_is_option When True, charge_start_time charge_end_time discharge_start_time and discharge_end_time are all option selectors for time in the format HH:MM:SS (e.g. 12:23:00) where seconds are always 00. When False, these entities are all number values. can_span_midnight When True, start and end times for charge and discharge can span midnight e.g. 23:00:00 - 01:00:00 is a 2-hour slot. When False, start and end times can't span midnight and Predbat will control the inverter with separate charges/discharges up to and then after midnight if required by the plan. clock_time_format Defines the time format of the inverter clock setting inverter_time in apps.yaml num_load_entities Enables you to define additional house load power sensors in apps.yaml in addition to the default load_power sensor. e.g. if set to 2 then Predbat will additionally use load_power_1 and load_power_2 settings in apps.yaml . This setting might be required for 3-phase inverters. soc_units Defines the units of the SoC setting (currently not used), it defaults to \"%\". write_and_poll_sleep Sets the number of seconds between polls of inverter settings.","title":"Inverter setup"},{"location":"inverter-setup/#inverter-setup","text":"PredBat was originally written for GivEnergy inverters using the GivTCP integration but has been extended to many other inverter models. The table below lists the inverters and required Home Assistant integrations that have had Predbat configurations developed. Follow the Predbat installation guide for full instructions to setup and configure Predbat. This document covers only the steps that are specific to different inverter types. Additionally, if your inverter type is not listed, you can create a custom inverter definition for Predbat . Once you get everything working please share the configuration as a github issue so it can be incorporated into the Predbat documentation. To setup the inverter with Predbat you will need to: Install the appropriate Home Assistant integration for your inverter Configure the integration according to its documentation Confirm that the integration is working. Are you receiving data from the various sensors (grid energy, charge limit, solar PV generated, etc)? Can you control the inverter using its Home Assistant controls? For each inverter there is a custom apps.yaml template configuration file that must be used in place of the GivTCP template file installed by default with Predbat: Open the inverter-specific template file with a browser Using a file editor in Home Assistant , edit the default apps.yaml configuration file Select-all in the default apps.yaml , and delete the entire template contents Select-all in the inverter-specific template file opened earlier, and copy and paste the contents into the Home Assistant file editor - if you copy but don't replace the standard apps.yaml template then Predbat will not function correctly. Follow the inverter-specific setup steps detailed below for each inverter (click on the inverter name in the table). Steps vary for each inverter, for some there are no additional steps, but for other inverters there are additional controls, scripts and automations that have to be created for Predbat to work with that inverter type. Follow the rest of the Predbat install instructions , in particular review that apps.yaml is configured correctly for your inverter. Name Integration Template GivEnergy with GivTCP GivTCP givenergy_givtcp.yaml Givenergy with GE Cloud ge_cloud givenergy_cloud.yaml [Givenergy with GE Cloud EMS](#givenergy-with-ge-cloud-ems ge_cloud EMS givenergy_ems.yaml Givenergy/Octopus No Home Assistant n/a ge_cloud_octopus_standalone.yaml Fox Foxess fox.yaml Fox Cloud Predbat fox_cloud.yaml Growatt with Solar Assistant Solar Assistant spa.yaml or sph.yaml Huawei Huawei Solar huawei.yaml Kostal Plenticore Kostal Plenticore kostal.yaml LuxPower LuxPython luxpower.yaml SigEnergy SigEnergy sigenergy_sigenstor.yaml Sofar inverters Sofar MQTT integration sofar.yaml SolarEdge inverters Solaredge Modbus Multi solaredge.yaml Solax Cloud Predbat solax_cloud.yaml Solax Gen4 inverters Solax Modbus integration in Modbus Power Control Mode solax_sx4.yaml Solis Cloud Predbat solis_cloud.yaml Solis Hybrid inverters (Firmware before FB00) Solax Modbus integration ginlong_solis.yaml Solis Hybrid inverters (Firmware FB00 and later) Solax Modbus integration ginlong_solis.yaml SunSynk Sunsynk sunsynk.yaml Tesla Powerwall Tesla Fleet or Teslemetry tesla_powerwall.yaml Victron Victron MQTT victron.yaml Note that support for all these inverters is in various stages of development. Please expect things to fail and report them as Issues on GitHub.","title":"Inverter setup"},{"location":"inverter-setup/#givenergy-with-givtcp","text":"It's recommended that you first watch the Installing GivTCP and Mosquitto Apps video from Speak to the Geek . Install Mosquitto Broker app: Go to Settings / Apps / Install app (bottom right) Scroll down the apps list, to find 'Mosquitto broker', click on the app, then click 'INSTALL' Once the Mosquitto broker has been installed, ensure that the 'Start on boot' and 'Watchdog' options are turned on, and click 'START' to start the app Next, configure Mosquitto broker by going to Settings / Devices and Services / Integrations. Mosquitto broker should appear as a Discovered integration so click the blue 'CONFIGURE' button, then SUBMIT to complete configuring Mosquitto broker Install the GivTCP app: Go to Settings / Apps / Install app Click the three dots in the top right corner, then Repositories You'll need to add the GivTCP repository as an additional custom repository so paste/type ' https://github.com/britkat1980/ha-addons ' into the text box and click 'Add' then 'Close' NB: this URL is for GivTCP v3, not v2 as covered in the video. Click the back button and then re-navigate to Settings / Apps / Install app so Home Assistant picks up the GivTCP app from the custom repository Scroll down the app list, to find 'GivTCP-V3', you should see the three addons; the production version, the latest beta and the latest dev versions. Click on the 'GivTCP' app, then click 'INSTALL' Once GivTCP has been installed, ensure that the 'Start on boot' and 'Watchdog' options are turned on Configure GivTCP: All configuration for GivTCP is done via the app Web interface On the GivTCP app, click 'START' to start the app Once the app has started, click 'Open Web UI' or go to http://homeassistant.local:8099/ , then click 'Go to Config Page' to configure GivTCP GivTCP will auto-discover your inverters and batteries so you shouldn't need to manually enter these, but check the IP address(s) it finds are correct If you have a single AIO then for Predbat to be able to communicate via REST to the AIO, it MUST be the first device configured in GivTCP. Conversely if you have a gateway and multiple AIO's then the gateway MUST be the first device in GivTCP If you have multiple inverters you may wish to change the default device prefixes that GivTCP assigns ('givtcp', 'givtcp2', 'givtcp3', etc) to make it easier to identify your devices within Home Assistant. For example, if you have a gateway and two AIOs you could use the prefixes 'GW', 'AIO-1' and 'AIO-2'. The prefixes should be set before you start using GivTCP in anger as changing the prefixes later on will result in both the old and new sensor names appearing in Home Assistant with the 'old' sensors being \"unavailable\". Note that if you do change the givtcp prefixes then you will also have to edit the apps.yaml configuration file to match, and change the sensor names that Predbat is looking for (by default prefixed 'givtcp_xxx') to your new sensor naming structure Click Next and Next to get to the Selfrun page, and turn on Self Run so that GivTCP automatically retrieves data from your inverter. The Self Run Loop Timer is how often GivTCP will retrieve data - it's recommended that set this to a value between 20 and 60, but not less than 15 seconds as otherwise the inverter will then spend all its time talking to GivTCP and won't communicate with the GivEnergy portal and app GivTCP auto-populates the MQTT page so as long as you're using Mosquitto broker within Home Assistant; you won't need to create a dedicated MQTT user or enter the details on the MQTT page You don't need to configure the Influx page. Tariff and Palm pages can also be skipped as these functions are done by Predbat (Optional) On the Web page, you can turn the Dashboard on to see a simple power flow diagram for your inverters (similar to the GivEnergy mobile app) On the 'Misc' page check that 'Print Raw' is set to on for added monitoring Finally, click 'Save and Restart' and GivTCP should start communicating with your inverters and will automatically create a set of 'givtcp_xxx' entities in Home Assistant for your inverter data, inverter controls and battery data Check the GivTCP Log tab that there aren't any errors; it should end with 'Publishing Home Assistant Discovery messages' Before you start using GivTCP to control your inverter Verify in the GivEnergy portal settings the following inverter settings are set correctly as these are settings that Predbat doesn't control, and if not set correctly could affect your battery activity: \"Inverter Charge Power Percentage\" is set to 100 (Predbat has its own low-rate charge control you can use if you wish) \"Inverter Discharge Power Percentage\" is set to 100. If you do wish to set a lower discharge rate then its recommended that instead you set inverter_limit_discharge in apps.yaml to the rate \"Battery Cutoff % Limit\" is set to 4 \"Enable AC Charge Upper Limit' is enabled (if you have this option) That charge slot 2 (or more) are disabled (as Predbat only uses slot1) That discharge slot 2 (or more) are disabled (as Predbat only uses slot1) Specific Predbat configuration requirements for certain GivEnergy equipment The rest of the Predbat installation instructions should now be followed, but its worth highlighting that there are a few specific settings that should be set for certain GivEnergy equipment. These settings are documented in the appropriate place in the documentation, but for ease of identification, are repeated here: If you are using GivTCP v3 and have an AIO or 3-phase inverter then you will need to manually set geserial in apps.yaml to your inverter serial number in lower case as the auto-detect doesn't work for this setup If you have a single AIO then control is directly to the AIO. Ensure geserial in apps.yaml is correctly picking the AIO and comment out geserial2 lines If you have multiple AIOs then all control of the AIOs is done through the Gateway so geserial in apps.yaml should be set to the Gateway serial number in lower case If you have multiple AIOs you might want to consider setting inverter charge and discharge limits unless you want to charge and discharge at the full 12kWh! If you have a 2.6kWh, 5.2kWh or AIO battery then you will need to set battery_scaling in apps.yaml as the battery size is incorrectly reported to GivTCP If you have an older inverter (AC3 or Gen 1 hybrid) with firmware that has battery pause support you may need to comment out pause start and end time controls in apps.yaml If you have a Gen 2, Gen 3 or AIO then you may need to set inverter_reserve_max in apps.yaml to 98. If you have a Gen 1 or a firmware version that allows the reserve being set to 100 then you can change the default from 98 to 100 If your inverter has been wired as an EPS (Emergency Power Supply) or AIO 'whole home backup', consider setting input_number.predbat_set_reserve_min to reserve some battery power for use in emergencies. NB: GivTCP and Predbat do not currently yet work together for 3-phase inverters . This is being worked on by the author of GivTCP, e.g. see GivTCP issue: unable to charge or discharge 3 phase inverters with Predbat","title":"GivEnergy with GivTCP"},{"location":"inverter-setup/#givenergy-with-ge-cloud","text":"This is an experimental system, please discuss it on the ticket: https://github.com/springfall2008/batpred/issues/905 First set up ge_cloud integration using your API key https://github.com/springfall2008/ge_cloud Now copy the template givenergy_cloud.yaml from templates over the top of your apps.yaml and edit Set geserial to your inverter serial number Make sure that the 'discharge down to' registers are set to 4% and slots 2, 3 and 4 for charge and discharge are disabled in the portal (if you have them)","title":"GivEnergy with GE Cloud"},{"location":"inverter-setup/#givenergy-with-ge-cloud-ems","text":"First set up ge_cloud integration using your API key https://github.com/springfall2008/ge_cloud Now copy the template givenergy_ems.yaml from templates over the top of your apps.yaml and edit Set geserial to your first inverter serial and geserial2 to the second (look in HA for entity names) Set geseriale to the EMS inverter serial number (look in HA for the entity names) Turn off charge, export and discharge slots 2, 3 and 4 as Predbat will only use slot 1 - set the start and end times for these to 00:00","title":"GivEnergy with GE Cloud EMS"},{"location":"inverter-setup/#givenergy-octopus-cloud-direct-no-home-assistant","text":"Take the template and enter your GivEnergy API key directly into apps.yaml Set your Octopus API key in apps.yaml Set your Solcast API key in apps.yaml Review any other configuration settings Launch Predbat with hass.py (from the Predbat-addon repository) either via a Docker or just on a Linux/MAC/WSL command line shell.","title":"GivEnergy Octopus Cloud Direct - No Home Assistant"},{"location":"inverter-setup/#fox","text":"Thanks to the work of @PeterHaban, for this Predbat configuration for Fox ESS inverters which Peter has working with a ECS4100h7 and UK Octopus Cosy. It runs off the work modes and charge/discharge rates. Copy the Fox template over the top of the supplied apps.yaml , and edit for your system. Create an input_number helper using the HA to hold the minimum battery soc level %, and set it to 10%: name: Battery Min SoC Min value: 0 Max value: 100 Create a template sensor helper using the HA UI to hold the SoC remaining percentage converted to kWh - sensor: - name: \"FoxESS SoC kWh remaining\" unit_of_measurement: \"kWh\" device_class: energy state_class: total state: > {{ ((float(states.sensor.foxess_battery_soc.state)/100) *float(states.sensor.foxess_bms_kwh_remaining.state)) }} Create a template sensor helper using the HA UI to hold the net grid power, combining the separate FoxESS integration import and export power sensors - sensor: - name: \"FoxESS Grid Power\" unit_of_measurement: \"kW\" device_class: power state_class: measurement state: > {% set import_p = states('sensor.foxess_grid_consumption') | float(0) %} {% set export_p = states('sensor.foxess_feed_in') | float(0) %} {{ import_p - export_p }} For an AC-coupled FoxESS inverter you will need a method to measure Solar Generation power and energy today for Predbat to use. The author of this configuration used an ESPHome flashed Emporia Vue 2, or you can use a Shelly EM or similar energy monitor. Replace the pv_today and pv_power entries in apps.yaml with the appropriate sensor names.","title":"Fox"},{"location":"inverter-setup/#fox-cloud","text":"Predbat now has a built-in Fox cloud integration. Today it requires a battery that supports the scheduler mode to function. See the components documentation for details Components - Fox cloud","title":"Fox Cloud"},{"location":"inverter-setup/#growatt-with-solar-assistant","text":"You need to have a Solar Assistant installation https://solar-assistant.io Growatt has two popular series of inverters, SPA and SPH. Copy the template that matches your model from templates over the top of your apps.yaml , and edit inverter and battery settings as required. Yours may have different entity IDs on Home Assistant.","title":"Growatt with Solar Assistant"},{"location":"inverter-setup/#huawei","text":"The discussion ticket is here: https://github.com/springfall2008/batpred/issues/684 Please copy the template https://github.com/springfall2008/batpred/blob/main/templates/huawei.yaml over the top of your apps.yaml , and modify it for your system Ensure you set input_number.predbat_set_reserve_min to the minimum value for your system which may be 12% Huawei inverters can charge the battery from DC solar and discharge at one power level (e.g. 5kWh), but have a lower limit (e.g. 3kWh) for AC charging. At present Predbat doesn't have the ability to model separate DC and AC charging limits, so battery_rate_max is set to the lower limit in watts (e.g. 3000) in the template apps.yaml to ensure that Predbat correctly plans AC charging of the battery at the right rate. However this means Predbat will also limit DC solar charging to this lower limit and to avoid that an automation is used to overwrite the inverter_limit_charge during the hours of sunrise and sunset: alias: Predbat change inverter charge rate at sunrise and sunset description: Using predbat_manual_api triggers: - trigger: time at: entity_id: sensor.sun_next_rising id: sunrise - trigger: time at: entity_id: sensor.sun_next_setting id: sunset conditions: [] actions: - choose: - conditions: - condition: trigger alias: Sunrise id: - sunrise sequence: - action: select.select_option alias: set inverter charge rate to 5000W at sunrise for maximum DC solar charging target: entity_id: - select.predbat_manual_api data: option: inverter_limit_charge(0)=5000 - conditions: - condition: trigger alias: Sunset id: - sunset sequence: - action: select.select_option alias: set inverter charge rate to 1500W at sunset for reduced AC charging rate target: entity_id: - select.predbat_manual_api data: option: inverter_limit_charge(0)=3000 mode: single Set the Huawei inverter work mode to 'TOU' (Time Of Use).","title":"Huawei"},{"location":"inverter-setup/#kostal-plenticore","text":"Thanks to the work of @mbuhansen for this Predbat configuration for Kostal Plenticore inverters. It should work with both the G1/G2 and G3 inverters. Copy the Kostal template over the top of your apps.yaml , and edit for your system. Create four new input_boolean and six input_number helpers using the HA UI: input_boolean.charge_start_service input_boolean.discharge_start_service input_boolean.charge_freeze_service input_boolean.discharge_freeze_service input_number.plenticore_max_charge # this is how fast inverter has to charge in %, is set to -100 when charge from grid Min value: -100 Max value: 0 input_number.plenticore_max_discharge # this is how fast inverter has to charge in %, is set to 100 when discharge to grid Min value: 0 Max value: 100 input_number.predbat_charge_limit # this is the limit % Predbat is charging the battery to, can be used if charge limit is set to true Min value: 0 Max value: 100 input_number.predbat_reserve # this is used to set Min_soc in inverter, the minimum level to discharge the battery to Min value: 0 Max value: 100 input_number.predbat_charge_rate # This is the rate Predbat is charging the battery at, can be used if low power charge mode is Enabled, remember to switch from \"write -100 charging\" to \"write power rate charging\" in automation Min value: 0 Max value: (Inverter Battery max charge in watt) input_number.predbat_discharge_rate # this is used to set battery discharge to zero Min value: 0 Max value: (Inverter Battery max discharge in watt) ```text - To control the Kostal inverter you need to use a modbus/tcp connection, this is not a part of the Kostal integration. Add the following modbus configuration to your `configuration.yaml`: ```yaml modbus: - name: kostalplenticore # name on modbus connection type: tcp # Use TCP host: 192.168.xxx.xxx # Modbus device IP-address port: 1502 # Port to Modbus-server Next, create the automation that sends the modbus commands to the Kostal inverter integration, when each input_boolean is activated from Predbat: alias: Predbat Charge / Discharge Control description: \"\" triggers: - trigger: state entity_id: - input_boolean.charge_start_service to: - \"on\" id: charge for: hours: 0 minutes: 0 seconds: 5 - trigger: state entity_id: - input_boolean.discharge_start_service to: \"on\" id: Discharge - trigger: state entity_id: - input_boolean.charge_freeze_service to: \"on\" id: Charge freeze - trigger: state entity_id: - input_boolean.discharge_freeze_service to: \"on\" id: Discharge freeze conditions: [] actions: - choose: - conditions: - condition: trigger id: - charge sequence: - repeat: sequence: - if: - condition: state entity_id: binary_sensor.predbat_charging state: \"on\" enabled: true then: - delay: hours: 0 minutes: 0 seconds: 45 milliseconds: 0 - repeat: sequence: - alias: Write -100 charging action: modbus.write_register metadata: {} data: slave: 71 address: 1028 hub: kostalplenticore value: > [ {{ '0x%x' % unpack(pack(states('input_number.plenticore_max_charge') |float(0), \">f\"), \">H\", offset=2) | abs }}, {{ '0x%04x' % unpack(pack(states('input_number.plenticore_max_charge')|float(0), \">f\"), \">H\")|abs }} ] enabled: true - alias: Write power rate charging action: modbus.write_register metadata: {} data: slave: 71 address: 1034 hub: kostalplenticore value: |- [ {{ '0x%x' % unpack(pack((states('input_number.predbat_charge_rate')|float(0)) * -1, \">f\"), \">H\", offset=2) | abs }}, {{ '0x%04x' % unpack(pack((states('input_number.predbat_charge_rate')|float(0)) * -1, \">f\"), \">H\") | abs }} ] enabled: false - delay: hours: 0 minutes: 0 seconds: 15 milliseconds: 0 while: - condition: state entity_id: input_boolean.charge_start_service state: \"on\" - condition: state entity_id: binary_sensor.predbat_charging state: \"on\" enabled: true enabled: true else: - delay: hours: 0 minutes: 0 seconds: 45 milliseconds: 0 - repeat: sequence: - alias: Write discharge rate zero action: modbus.write_register metadata: {} data: hub: kostalplenticore address: 1040 slave: 71 value: > [ {{ '0x%x' % unpack(pack(states('input_number.predbat_discharge_rate') |float(0), \">f\"), \">H\", offset=2) | abs }}, {{ '0x%04x' % unpack(pack(states('input_number.predbat_discharge_rate') |float(0), \">f\"), \">H\")|abs }} ] enabled: false - alias: Write min SOC action: modbus.write_register metadata: {} data: hub: kostalplenticore address: 1042 slave: 71 value: > [ {{ '0x%x' % unpack(pack((states('input_number.predbat_reserve') |float(0) - 1), \">f\"), \">H\", offset=2) | abs }}, {{ '0x%04x' % unpack(pack((states('input_number.predbat_reserve') |float(0) - 1), \">f\"), \">H\")|abs }} ] enabled: true - delay: hours: 0 minutes: 0 seconds: 15 milliseconds: 0 while: - condition: template value_template: >- {{ states('sensor.scb_battery_soc') | float <= (states('predbat.best_charge_limit') | float + 1.0) }} - condition: state entity_id: binary_sensor.predbat_charging state: - \"off\" enabled: true enabled: true while: - condition: state entity_id: input_boolean.charge_start_service state: \"on\" - conditions: - condition: trigger id: - Discharge sequence: - delay: hours: 0 minutes: 0 seconds: 40 milliseconds: 0 enabled: true - repeat: sequence: - action: modbus.write_register metadata: {} data: slave: 71 address: 1028 hub: kostalplenticore value: > [ {{ '0x%x' % unpack(pack(states('input_number.plenticore_max_discharge') |float(0), \">f\"), \">H\", offset=2) | abs }}, {{ '0x%04x' % unpack(pack(states('input_number.plenticore_max_discharge')|float(0), \">f\"), \">H\")|abs }} ] alias: Write 100 Discharge - delay: hours: 0 minutes: 0 seconds: 15 milliseconds: 0 while: - condition: state entity_id: input_boolean.discharge_start_service state: \"on\" - conditions: - condition: trigger id: - Charge freeze - condition: template value_template: |2- {% set rate = states('sensor.predbat_rates') | float(0) %} {% set high_rate = states('sensor.predbat_high_rate_export_cost_2') | float(0) %} {{ rate < high_rate }} enabled: false sequence: - delay: hours: 0 minutes: 0 seconds: 45 milliseconds: 0 - repeat: sequence: - action: modbus.write_register data: address: 1040 hub: kostalplenticore slave: 71 value: > [{{ '0x%04x' % unpack(pack(states('input_number.predbat_discharge_rate') |float(0), \">f\"), \">H\", offset=2) | abs }}, {{ '0x%04x' % unpack(pack(states('input_number.predbat_discharge_rate')|float(0), \">f\"), \">H\")|abs }}] metadata: {} alias: Write discharge rate enabled: false - alias: Write min. SOC action: modbus.write_register data: address: 1042 hub: kostalplenticore slave: 71 value: > [ {{ '0x%x' % unpack(pack((states('input_number.predbat_reserve') |float(0) - 1), \">f\"), \">H\", offset=2) | abs }}, {{ '0x%04x' % unpack(pack((states('input_number.predbat_reserve')|float(0) - 1), \">f\"), \">H\")|abs }} ] metadata: {} enabled: true - delay: hours: 0 minutes: 0 seconds: 15 milliseconds: 0 while: - condition: state entity_id: input_boolean.charge_freeze_service state: \"on\" - conditions: - condition: trigger id: - Discharge freeze sequence: - delay: hours: 0 minutes: 0 seconds: 45 milliseconds: 0 - repeat: sequence: - action: modbus.write_register data: address: 1038 hub: kostalplenticore slave: 71 value: > [{{ '0x%04x' % unpack(pack(states('input_number.predbat_charge_rate') |float(0), \">f\"), \">H\", offset=2) | abs }}, {{ '0x%04x' % unpack(pack(states('input_number.predbat_charge_rate')|float(0), \">f\"), \">H\")|abs }}] metadata: {} alias: Write charge rate - delay: hours: 0 minutes: 0 seconds: 15 milliseconds: 0 while: - condition: state entity_id: input_boolean.discharge_freeze_service state: \"on\" mode: queued max: 10","title":"Kostal Plenticore"},{"location":"inverter-setup/#luxpower","text":"This requires the LuxPython component which integrates with your Lux Power inverter Copy the template luxpower.yaml from templates over the top of your apps.yaml , and edit inverter and battery settings as required Predbat should have access to the full usable capacity of your battery system. In the LuxPowerTek web portal (not the app), ensure that: System Charge SOC Limit (%) is set to 100% (default). On-Grid Cut-Off SOC (%) is set to 100% minus battery depth of discharge(%). Depending on your battery, this is typically between 20% and 0%. If you want to use Predbat in Control charge mode, go to the LuxPowerTek app or web portal and set all start and end time slots for AC Charge to 00:00 . For Control charge and discharge mode, set all AC Charge and Forced Discharge slots to 00:00 . Predbat only uses the first time slots and will set these automatically. LuxPower does not have a SoC max entity in kWh and the SoC percentage entity never reports the battery reaching 100%, so create the following template helper sensors: name: Lux SoC Max kWh template: {{ (states(\"sensor.lux_battery_capacity_ah\") |float) * (states(\"sensor.lux_battery_voltage_live\") | float) / 1000}} unit of measurement: kWh device class: Energy state class: Total name: Lux Battery SoC Corrected template: {% set soc = states('sensor.lux_battery')|int %} {% set charging_stopped = states('sensor.lux_bms_limit_charge_live')|float == 0 %} {% if charging_stopped and soc > 97 %} 100 {% else %} {{ soc }} {% endif %} unit of measurement: % device class: Battery state class: Measurement Create the following number helper. The maximum value (in Watts) can be found in your inverter data sheet. A more accurate figure can be obtained by observing the flow chart in the Monitor section of the LuxPower app/portal or by inspecting sensor.lux_battery_flow_live when the battery is force charging or discharging. name: Battery Rate Max entity_id: input_number.battery_rate_max minimum value: 0 maximum value: YOUR_INVERTER_MAXIMUM_CHARGE/DISCHARGE_RATE unit of measurement: W Thanks to the work of @brickatius , the following automations and configurations enable LuxPower inverters to provide Freeze Charging and Freeze Exporting functionality when Predbat is operating in Control charge and discharge mode. Important: The Freeze Charging and Freeze Exporting setup described below relies on a set of carefully designed helpers and automations that work together. Each component has a specific role in safely entering, maintaining, and exiting Freeze Charging mode. Removing or skipping any part can lead to missed triggers, stuck AC charging, or incomplete cleanup. For reliable operation, make sure all helpers and automations in this section are created exactly as described before using Freeze Charging or Freeze Exporting modes. All of the automations apart from LuxPower HA Startup Reset remain disabled when Predbat is not Freeze Charging.","title":"LuxPower"},{"location":"inverter-setup/#freeze-charging","text":"Note: Although LuxPower inverters have the Charge first / Charge priority feature, Predbat achieves a similar outcome by directly manipulating AC charge settings. This is why the following implementation is required. Set up your LuxPower Integration as follows: - - If you have not already done so, set up the blueprint for changing the refresh interval as described in the LuxPython_DEV README. - In the LUX Refresh Interval automation set the refresh interval to **20 seconds**. Freeze Charging relies on frequent state updates; intervals above 30 seconds may result in delayed or missed AC arbitration. In your apps.yaml file: Look for support_charge_freeze in the inverter section and change False to True . Uncomment the three lines of the charge_freeze_service section so that Predbat turns on automation.luxpower_freeze_charge when Freeze Charging starts. Ensure the indentation and alignment match the other service entries. Helpers Create the following Freeze Charge Guard toggle helper and Solar compare Home binary sensor helper using the HA user interface. Toggle helper name: Freeze Charge Guard entity_id: input_boolean.freeze_charge_guard The freeze_charge_guard helper acts as a lifecycle gate. It is enabled only when Predbat explicitly requests Freeze Charging and is cleared on exit, watchdog abort, or Home Assistant restart. All Freeze Charging automations check this guard to prevent unintended operation. Binary sensor template helper \u00b9 name: Solar compare Home entity_id: binary_sensor.solar_compare_home template options: state: > {{ 'on' if states('sensor.lux_solar_output_live') | float(0) <= states('sensor.lux_home_consumption_live') | float(0) else 'off' }} Automations Create the following Freeze Charge \u00b2 and Freeze Charge Predbat Override automations. These are enabled when Predbat enters Freeze Charging mode and disabled when it exits. Note: The Freeze Charge automation uses sensor.lux_battery_soc_corrected as described above. alias: LuxPower Freeze Charge description: > Controls AC charging during Predbat freeze charge mode. Arms and triggers freeze subsystems and watchdog via freeze guard. triggers: - entity_id: automation.luxpower_freeze_charge from: \"off\" to: \"on\" id: freeze_enabled trigger: state - entity_id: binary_sensor.solar_compare_home to: \"on\" for: \"00:00:10\" id: solar_on trigger: state - entity_id: binary_sensor.solar_compare_home to: \"off\" for: \"00:00:10\" id: solar_off trigger: state conditions: - condition: state entity_id: input_boolean.predbat_ready state: \"on\" actions: - choose: - conditions: - condition: trigger id: freeze_enabled sequence: - alias: \"FreezeEntry: Enable exit & override automations\" action: automation.turn_on target: entity_id: - automation.luxpower_freeze_charge_exit - automation.luxpower_freeze_charge_predbat_override - alias: \"FreezeEntry: Arm watchdog\" action: automation.turn_on target: entity_id: automation.luxpower_freeze_charge_watchdog - alias: \"FreezeEntry: Set freeze guard ON (triggers watchdog)\" action: input_boolean.turn_on target: entity_id: input_boolean.freeze_charge_guard - alias: \"FreezeEntry: Set initial SOC charge level\" action: number.set_value target: entity_id: number.lux_ac_battery_charge_level data: value: \"{{ states('sensor.lux_battery_soc_corrected') | float(0) }}\" - alias: \"FreezeEntry: Initial AC arbitration\" choose: - conditions: - condition: state entity_id: binary_sensor.solar_compare_home state: \"on\" - condition: state entity_id: switch.lux_ac_charge_enable state: \"off\" sequence: - action: switch.turn_on target: entity_id: switch.lux_ac_charge_enable - conditions: - condition: state entity_id: binary_sensor.solar_compare_home state: \"off\" - condition: state entity_id: switch.lux_ac_charge_enable state: \"on\" sequence: - action: switch.turn_off target: entity_id: switch.lux_ac_charge_enable - conditions: - condition: trigger id: - solar_on - solar_off - condition: state entity_id: input_boolean.freeze_charge_guard state: \"on\" sequence: - alias: \"FreezeSolar: AC arbitration\" choose: - conditions: - condition: state entity_id: binary_sensor.solar_compare_home state: \"on\" - condition: state entity_id: switch.lux_ac_charge_enable state: \"off\" sequence: - action: switch.turn_on target: entity_id: switch.lux_ac_charge_enable - conditions: - condition: state entity_id: binary_sensor.solar_compare_home state: \"off\" - condition: state entity_id: switch.lux_ac_charge_enable state: \"on\" sequence: - action: switch.turn_off target: entity_id: switch.lux_ac_charge_enable mode: single alias: LuxPower Freeze Charge Predbat Override description: > Handles Predbat forcing AC ON during Freeze Charge. Uses template trigger to avoid repeated retriggers every few seconds. triggers: - value_template: | {{ is_state('switch.lux_ac_charge_enable', 'on') and is_state('binary_sensor.solar_compare_home', 'off') and is_state('input_boolean.freeze_charge_guard', 'on') and is_state('input_boolean.predbat_ready', 'on') }} trigger: template conditions: [] actions: - delay: \"00:00:10\" - alias: \"Predbat Override: Turn AC OFF due to Solar > Home\" action: switch.turn_off target: entity_id: switch.lux_ac_charge_enable - alias: \"Predbat Override: Log AC override\" action: system_log.write data: level: debug message: > FreezeCharge: Predbat forced AC ON \u2192 overridden OFF (Solar=OFF, FreezeGuard=ON, PredbatReady=ON) mode: single Create the Freeze Charge Exit automation to cleanly restore inverter state when Freeze Charging ends. yaml alias: LuxPower Freeze Charge Exit description: | Cleanup when Predbat leaves Freeze charging. triggers: - entity_id: predbat.status trigger: state conditions: - condition: state entity_id: input_boolean.freeze_charge_guard state: \"on\" - condition: template value_template: | {% set new = trigger.to_state.state | default('') %} {{ new not in ['unknown','unavailable'] and not new.startswith('Warn:') and not new.startswith('Error:') and 'Freeze charging' not in new }} actions: - target: entity_id: - automation.luxpower_freeze_charge - automation.luxpower_freeze_charge_predbat_override - automation.luxpower_freeze_charge_watchdog action: automation.turn_off - target: entity_id: input_boolean.freeze_charge_guard action: input_boolean.turn_off - choose: - conditions: - condition: template value_template: | {{ trigger.to_state.state.startswith('Charging') or trigger.to_state.state == 'Hold charging' }} sequence: - target: entity_id: switch.lux_ac_charge_enable action: switch.turn_on default: - target: entity_id: switch.lux_ac_charge_enable action: switch.turn_off - choose: - conditions: - condition: template value_template: | {{ trigger.to_state.state.startswith('Charging') }} sequence: - target: entity_id: number.lux_ac_battery_charge_level data: value: \"{{ states('number.lux_system_charge_soc_limit') | int(0) }}\" action: number.set_value - conditions: - condition: template value_template: | {{ trigger.to_state.state == 'Hold charging' }} sequence: - target: entity_id: number.lux_ac_battery_charge_level data: value: >- {{ states('number.lux_on_grid_discharge_cut_off_soc') | int(0) }} action: number.set_value - target: entity_id: automation.luxpower_freeze_charge_exit action: automation.turn_off mode: single Occasionally, when a Manual Freeze Charge is requested, Predbat may immediately decide that Hold Charging is the more appropriate state based on current conditions. In this case, Freeze Charging automations may remain enabled even though Predbat reports Hold Charging. The watchdog safely exits Freeze Charging after a short grace period. Create the Freeze Charge Watchdog automation to handle cases where Manual Freeze Charging immediately transitions to Hold Charging . alias: LuxPower Freeze Charge Watchdog description: > Cancels freeze charge if Predbat does not commit to Freeze charging. Triggered by freeze guard Boolean; self-disarms after execution. triggers: - entity_id: input_boolean.freeze_charge_guard from: \"off\" to: \"on\" trigger: state conditions: [] actions: - alias: \"Watchdog: Grace period\" delay: \"00:00:30\" - alias: \"Watchdog: Abort if no Freeze charging\" if: - condition: template value_template: | {{ not states('predbat.status').startswith('Freeze charging') }} then: - alias: \"Watchdog: Trace cancellation\" action: system_log.write data: level: warning message: > Predbat never entered Freeze charging (status=\"{{ states('predbat.status') }}\") \u2192 cancelling freeze - alias: \"Watchdog: Disable freeze automations\" action: automation.turn_off target: entity_id: - automation.luxpower_freeze_charge - automation.luxpower_freeze_charge_predbat_override - automation.luxpower_freeze_charge_exit - alias: \"Watchdog: Reset guard Boolean\" action: input_boolean.turn_off target: entity_id: input_boolean.freeze_charge_guard - alias: \"Watchdog: AC handling\" choose: - conditions: - condition: template value_template: | {{ states('predbat.status').startswith('Charging') or states('predbat.status') == 'Hold charging' }} sequence: - if: - condition: state entity_id: switch.lux_ac_charge_enable state: \"off\" then: - action: switch.turn_on target: entity_id: switch.lux_ac_charge_enable default: - if: - condition: state entity_id: switch.lux_ac_charge_enable state: \"on\" then: - action: switch.turn_off target: entity_id: switch.lux_ac_charge_enable - alias: \"Watchdog: Restore SOC limits\" choose: - conditions: - condition: template value_template: | {{ states('predbat.status').startswith('Charging') }} sequence: - action: number.set_value target: entity_id: number.lux_ac_battery_charge_level data: value: \"{{ states('number.lux_system_charge_soc_limit') | int(0) }}\" - conditions: - condition: template value_template: | {{ states('predbat.status') == 'Hold charging' }} sequence: - action: number.set_value target: entity_id: number.lux_ac_battery_charge_level data: value: >- {{ states('number.lux_on_grid_discharge_cut_off_soc') | int(0) }} - alias: \"Watchdog: Disarm self\" action: automation.turn_off target: entity_id: automation.luxpower_freeze_charge_watchdog mode: single ``` **Enable Freeze Charging** - Ensure **`switch.predbat_set_charge_freeze`** is turned On. Note that as this is an expert mode option, Predbat's [Expert Mode](customisation.md#expert-mode) must be turned on first. After Predbat recomputes, you may see some light grey **FrzChrg** slots in the state column of the plan. To disable Freeze Charging simply turn the switch Off. Predbat will no longer schedule any FrzChrg slots. --- ### Freeze Exporting If you have a LuxPower inverter with the **Charge Last** feature, enable the Predbat `discharge_freeze_service`. **Note** Freeze Exporting requires fewer supporting automations than Freeze Charging, as it relies primarily on inverter-side behaviour. No additional watchdog or guard logic is required. In your `apps.yaml` file: - Look for `support_discharge_freeze` in the inverter section and change `False` to `True` - Uncomment the last two lines of the `discharge_stop_service` section so Predbat turns `switch.lux_charge_last` off when Freeze exporting stops. - Uncomment the three lines of the `discharge_freeze_service` section so that Predbat turns on the LuxPower Charge Last switch. - Ensure the indentation and alignment match the other service entries. **Enable Freeze Exporting** - Ensure **`switch.predbat_set_export_freeze`** is turned On. After Predbat recomputes, you may see some dark grey **FrzExp** slots in the state column of the plan. To disable Freeze Exporting simply turn the switch Off. Predbat will no longer schedule any FrzExp slots. --- ### Home Assistant restart recovery - Create the following toggle helper and automation to ensure the inverter and Predbat return to a known safe state after a Home Assistant restart. This automation should be created even if you only set up one of the 'Freeze' services above. It must always be enabled. ```yaml name: Predbat Ready entity_id: input_boolean.predbat_ready ```text The `predbat_ready` helper prevents automation actions until LuxPower entities are fully available after startup. Ensure it is On after it has been created. ```yaml alias: LuxPower HA Startup Reset description: > On Home Assistant restart, wait for LuxPower entities to be available, then safely disable freeze charge, override, watchdog, guard boolean, AC/charge and charge last switches, and reset discharge current limit. Marks Predbat ready only after HA and Lux are stable. triggers: - event: start trigger: homeassistant actions: - alias: \"StartupReset: Mark Predbat NOT ready\" target: entity_id: input_boolean.predbat_ready action: input_boolean.turn_off - alias: \"StartupReset: Wait for Lux entities\" wait_template: | {{ states('switch.lux_ac_charge_enable') not in ['unknown','unavailable'] and states('switch.lux_charge_last') not in ['unknown','unavailable'] and states('switch.lux_force_discharge_enable') not in ['unknown','unavailable'] and states('number.lux_discharge_current_limit') not in ['unknown','unavailable'] }} timeout: \"00:02:00\" continue_on_timeout: true - alias: \"StartupReset: Disable freeze/override/watchdog\" target: entity_id: - automation.luxpower_freeze_charge - automation.luxpower_freeze_charge_predbat_override - automation.luxpower_freeze_charge_exit - automation.luxpower_freeze_charge_watchdog action: automation.turn_off - alias: \"StartupReset: Reset guard boolean\" target: entity_id: input_boolean.freeze_charge_guard action: input_boolean.turn_off - alias: \"StartupReset: Wait for battery voltage to be > 0\" wait_template: \"{{ states('sensor.lux_battery_voltage_live') | float > 0 }}\" timeout: \"00:01:00\" continue_on_timeout: true - alias: \"StartupReset: Set discharge current limit from battery_rate_max\" target: entity_id: number.lux_discharge_current_limit data: value: | {{ (states('input_number.battery_rate_max') | float / states('sensor.lux_battery_voltage_live') | float(1)) | round(0) }} action: number.set_value - alias: \"StartupReset: Turn off AC if on\" if: - condition: state entity_id: switch.lux_ac_charge_enable state: \"on\" then: - target: entity_id: switch.lux_ac_charge_enable action: switch.turn_off - alias: \"StartupReset: Turn off charge last if on\" if: - condition: state entity_id: switch.lux_charge_last state: \"on\" then: - target: entity_id: switch.lux_charge_last action: switch.turn_off - alias: \"StartupReset: Turn off force discharge if on\" if: - condition: state entity_id: switch.lux_force_discharge_enable state: \"on\" then: - target: entity_id: switch.lux_force_discharge_enable action: switch.turn_off - alias: \"StartupReset: Final settle delay\" delay: \"00:01:30\" - alias: \"StartupReset: Mark Predbat ready\" target: entity_id: input_boolean.predbat_ready action: input_boolean.turn_on - alias: \"StartupReset: Log completion\" data: level: debug message: \"StartupReset: cleanup complete, watchdog and guard OFF, Predbat ready\" action: system_log.write mode: single","title":"Freeze Charging"},{"location":"inverter-setup/#notes","text":"If you do not need to record the binary sensor, you can exclude it from the HA recorder by adding the following to your configuration.yaml file: (HA restart required) recorder: exclude: entities: - binary_sensor.solar_compare_home While LuxPower inverters cannot exactly replicate Predbat\u2019s native Freeze Charging behaviour, these automations achieve an equivalent outcome. Any small differences are corrected the next time Predbat recalculates its plan.","title":"Notes"},{"location":"inverter-setup/#troubleshooting","text":"If you see recurring Predbat log warnings mentioning scheduled_charge_enable every few minutes, and Predbat switches to Warn during Freeze Charging when solar generation exceeds house load, increase the delay in the LuxPower Freeze Predbat Override automation. Open the automation and locate the delay: \"00:00:10\" entry Increase the delay by a few additional seconds. Save the updated automation. Confirm that the warnings stop appearing when Freeze Charging is active and solar generation exceeds house load.","title":"Troubleshooting"},{"location":"inverter-setup/#sigenergy-sigenstor","text":"To integrate your Sigenergy Sigenstor inverter with Predbat, you will need to follow the steps below: make sure the inverter is already integrated into Home Assistant. The Predbat configuration has been developed with the SigEnergy local modbus integration (the Python version of the Sigenergy HA integration). Copy the template sigenergy_sigenstor.yaml template over your apps.yaml , and edit for your system. All the Sigenergy entities referenced in apps.yaml need to be enabled for Predbat to use them. The following are disabled by default and will need enabling: sensor.sigen_plant_available_max_discharging_capacity sensor.sigen_plant_daily_consumed_energy number.sigen_plant_ess_backup_state_of_charge number.sigen_plant_ess_charge_cut_off_state_of_charge number.sigen_plant_ess_discharge_cut_off_state_of_charge sensor.sigen_plant_ess_max_charging_limit sensor.sigen_plant_ess_max_discharging_limit sensor.sigen_plant_max_active_power The following additions are needed to facilitate integration with Predbat and need to be put into Home Assistant's configuration.yaml or configured via the HA user interface: input_select: predbat_requested_mode: name: \"Predbat Requested Mode\" options: - \"Demand\" - \"Charging\" - \"Freeze Charging\" - \"Discharging\" - \"Freeze Discharging\" initial: \"Demand\" icon: mdi:battery-unknown input_number: charge_rate: name: Battery charge rate initial: 6950 min: 0 max: 20000 step: 1 mode: box unit_of_measurement: W discharge_rate: name: Battery discharge rate initial: 8000 min: 0 max: 20000 step: 1 mode: box unit_of_measurement: W Add the following automations to automations.yaml (or configure via the UI): - id: predbat_requested_mode_action alias: \"Predbat Requested Mode Action\" description: \"Acts as a mapper for the input_select.predbat_requested_mode to the select.sigen_plant_remote_ems_control_mode\" mode: restart triggers: - trigger: state entity_id: - input_select.predbat_requested_mode conditions: [] actions: - action: select.select_option metadata: {} target: entity_id: select.sigen_plant_remote_ems_control_mode data: option: > {% if is_state('input_select.predbat_requested_mode', \"Demand\") %}Maximum Self Consumption {% elif is_state('input_select.predbat_requested_mode', \"Charging\") %}Command Charging (PV First) {% elif is_state('input_select.predbat_requested_mode', \"Freeze Charging\") %}Maximum Self Consumption {% elif is_state('input_select.predbat_requested_mode', \"Discharging\") %}Command Discharging (PV First) {% elif is_state('input_select.predbat_requested_mode', \"Freeze Discharging\") %}Maximum Self Consumption {% endif %} - choose: # Freeze Charging # Docs: # Freeze charging - The battery is charging but the current battery level (SoC) is frozen (held). Think of it # as a charge to the current battery level. The grid or solar covers any house load. If there is a shortfall of # Solar power to meet house load, the excess house load is met from grid import, but if there is excess Solar # power above the house load, the excess solar will be used to charge the battery # In Sigenergy, this is effectively \"self consumption\" mode with discharging prohibited - conditions: - condition: state entity_id: input_select.predbat_requested_mode state: \"Freeze Charging\" sequence: - service: number.set_value data_template: entity_id: number.sigen_plant_ess_charge_cut_off_state_of_charge value: 100 - service: number.set_value data_template: entity_id: number.sigen_plant_ess_discharge_cut_off_state_of_charge value: 100 - service: number.set_value data_template: entity_id: number.sigen_plant_grid_import_limitation value: 0 # Freeze Discharging # Docs: # Freeze exporting (mapped to Freeze Discharging in sigenergy_sigenstor.yaml) - The battery is in demand mode, # but with charging disabled. The battery or solar covers the house load. As charging is disabled, if there is # excess solar generated, the current SoC level will be held and the excess solar will be exported. If there is # a shortfall of generated solar power to meet the house load, the battery will discharge to meet the extra load. # In Sigenergy, this is effectively \"self consumption\" mode with charging prohibited - conditions: - condition: state entity_id: input_select.predbat_requested_mode state: \"Freeze Discharging\" sequence: - service: number.set_value data_template: entity_id: number.sigen_plant_ess_charge_cut_off_state_of_charge value: 0 - service: number.set_value data_template: entity_id: number.sigen_plant_ess_discharge_cut_off_state_of_charge value: 0 - service: number.set_value data_template: entity_id: number.sigen_plant_grid_import_limitation value: 0 # If neither of the above conditions are met, set the limits to the input numbers - conditions: - condition: not conditions: - condition: state entity_id: input_select.predbat_requested_mode state: \"Freeze Charging\" - condition: state entity_id: input_select.predbat_requested_mode state: \"Freeze Discharging\" sequence: - service: number.set_value data_template: entity_id: number.sigen_plant_ess_charge_cut_off_state_of_charge value: 100 - service: number.set_value data_template: entity_id: number.sigen_plant_ess_discharge_cut_off_state_of_charge value: 0 - service: number.set_value data_template: entity_id: number.sigen_plant_grid_import_limitation value: 100 - id: automation_sigen_ess_max_charging_limit_input_number_action alias: Predbat max charging limit action description: Mapper from input_number.charge_rate to number sigen_plant_ess_max_charging_limit triggers: - trigger: state entity_id: input_number.charge_rate actions: - action: number.set_value target: entity_id: number.sigen_plant_ess_max_charging_limit data: value: '{{ [(states(''input_number.charge_rate'') | float / 1000) | round(2), states(''sensor.sigen_inverter_ess_rated_charging_power'') | float] | min}}' mode: single - id: automation_sigen_ess_max_discharging_limit_input_number_action alias: Predbat max discharging limit action description: Mapper from input_number.discharge_rate to number.sigen_plant_ess_max_discharging_limit triggers: - trigger: state entity_id: input_number.discharge_rate actions: - action: number.set_value target: entity_id: number.sigen_plant_ess_max_discharging_limit data: value: '{{ [(states(''input_number.discharge_rate'') | float / 1000) | round(2), states(''sensor.sigen_inverter_ess_rated_discharging_power'') | float] | min}}' mode: single Note: Some Sigenergy Predbat users have reported that their Sigenergy modbus integration has created some of the entities that Predbat requires with different names so you may need to adapt the above automations and apps.yaml (or rename your entities) to match: sensor.sigen_inverter_ess_rated_discharging_power is instead named sensor.sigen_inverter_ess_rated_discharge_power sensor.sigen_inverter_ess_rated_charging_power is sensor.sigen_inverter_ess_rated_charge_power sensor.sigen_plant_daily_consumed_energy is sensor.sigen_plant_daily_load_consumption Important: Depending upon your electricity supply, you may need to change where number.sigen_plant_grid_import_limitation is set to 100 in the first integration to any lower import limit that your electricity supplier may have imposed, e.g. 18kW roughly corresponds to an 80A supply.","title":"SigEnergy Sigenstor"},{"location":"inverter-setup/#sofar-inverters","text":"For this integration, the key elements are: Hardware - sofar2mqtt EPS board - Relatively easy to solder and flash, or can be bought pre-made. Software - Sofar MQTT integration - MQTT integration Home Assistant configuration - sofar_inverter.yaml (in templates directory), defines the custom HA entities and should be added to HA's configuration.yaml . This is the default Sofar HA configuration with a couple of additional inputs to support battery capacity. Predbat configuration - sofar.yaml template for Predbat (in templates directory). This file should be copied over the top of your apps.yaml and edited for your installation Please note that the inverter needs to be put into \"Passive Mode\" for the sofar2mqtt to control the inverter. This integration has various limitations, it can charge and discharge the battery but does not have finer control over reserve and target SoC% Note: You will need to change the min reserve in Home Assistant to match your minimum battery level ( input_number.predbat_set_reserve_min ). Please see this ticket in Github for ongoing discussions: https://github.com/springfall2008/batpred/issues/395","title":"Sofar Inverters"},{"location":"inverter-setup/#solaredge-inverters","text":"Please copy the template https://github.com/springfall2008/batpred/blob/main/templates/solaredge.yaml over the top of your apps.yaml and modify it for your system The default entity name prefix for the integration is 'solaredge' but if you have changed this on installation then you will need to amend the apps.yaml template and the template sensors to match your new prefix Ensure that number.solaredge_i1_storage_command_timeout is set to a reasonably high value e.g. 3600 seconds to avoid the commands issued being cancelled Power Control Options, as well as Enable Battery Control, must be enabled in the Solaredge Modbus Multi integration configuration, and switch.solaredge_i1_advanced_power_control must be on. For pv_today , pv_power and load_power sensors to work you need to create these as a template entities within your Home Assistant configuration.yaml . These sensors are not critical so you can just comment them out in apps.yaml if you can't get them to work: template: - sensor: - name: \"Solar Panel Production W\" unique_id: solar_panel_production_w unit_of_measurement: \"W\" icon: mdi:solar-power state: > {% set i1_dc_power = states('sensor.solaredge_i1_dc_power') | float(0) %} {% set b1_dc_power = states('sensor.solaredge_b1_dc_power') | float(0) %} {% if (i1_dc_power + b1_dc_power <= 0) %} 0 {% else %} {{ (i1_dc_power + b1_dc_power) }} {% endif %} availability: > {{ states('sensor.solaredge_i1_dc_power') | is_number and states('sensor.solaredge_b1_dc_power') | is_number }} - name: \"Solar House Consumption W\" unique_id: solar_house_consumption_w unit_of_measurement: \"W\" icon: mdi:home state: > {% set i1_ac_power = states('sensor.solaredge_i1_ac_power') | float(0) %} {% set m1_ac_power = states('sensor.solaredge_m1_ac_power') | float(0) %} {% if (i1_ac_power - m1_ac_power <= 0) %} 0 {% else %} {{ (i1_ac_power - m1_ac_power) }} {% endif %} availability: > {{ states('sensor.solaredge_i1_ac_power') | is_number and states('sensor.solaredge_m1_ac_power') | is_number }} sensor: - platform: integration source: sensor.solar_panel_production_w method: left unit_prefix: k name: solar_panel_production_kwh sensor: - platform: integration source: sensor.solar_house_consumption_w method: left unit_prefix: k name: solar_house_consumption_kwh ```text If you have multiple batteries connected to your SolarEdge inverter and are using the SolarEdge Modbus Multi integration, this enumerates the multiple batteries as b1, b2, b3, etc with separate entities per battery. You will need to make a number of changes to the solaredge apps.yaml, replacing the following entries: ```yaml battery_rate_max: - sensor.calc_power_batteries_max_charge_power # maximum charge power of all the batteries battery_power: - sensor.calc_power_batteries_dc_power soc_percent: - sensor.calc_battery_all_state # average SoC of the batteries soc_max: - sensor.calc_battery_total_capacity # combined kWh maximum value of all the batteries soc_kw: - sensor.calc_battery_current_capacity Set charge_rate and discharge_rate to the SolarEdge inverter values, e.g. 5000 And add the following additional template sensors to configuration.yaml after the existing 'template:' line (from the earlier template sensor definitions): - sensor: # Template sensor for Max Battery Charge rate # This is the sum of all three batteries charge rate as the max charge rate can be higher than inverter capacity (e.g. 8k) when charging from AC+Solar # Returns 5000W as the minimum max value, the single battery charge/discharge limit to ensure at least one battery can always be charged if one or more batteries have 'gone offline' to modbus # Remove all 'B3' entries if you only have two batteries, or follow the same pattern for adding 'B4', etc if you have more than 3 batteries - name: \"Calc Power - Batteries Max Charge Power\" unique_id: calc_power_batteries_max_charge_power unit_of_measurement: \"W\" device_class: \"power\" state_class: \"measurement\" state: > {% set myB1 = float(states('sensor.solaredge_b1_max_charge_power'),0) %} {% set myB2 = float(states('sensor.solaredge_b2_max_charge_power'),0) %} {% set myB3 = float(states('sensor.solaredge_b3_max_charge_power'),0) %} {% set myValue = ((myB1 + myB2 + myB3)) | int %} {{ (myValue if (myValue) > 5000 else 5000) }} # Calculate Total Battery Power Value - name: \"Calc Power - Batteries DC Power\" unique_id: calc_power_batteries_dc_power unit_of_measurement: \"W\" device_class: \"power\" state_class: \"measurement\" state: > {% set myB1 = float(states('sensor.solaredge_b1_dc_power'),0) %} {% set myB2 = float(states('sensor.solaredge_b2_dc_power'),0) %} {% set myB3 = float(states('sensor.solaredge_b3_dc_power'),0) %} {% set myValue = ((myB1 + myB2 + myB3)) %} {{ myValue }} # Average state of charge across the batteries - name: \"Calc Battery All State\" unique_id: calc_battery_all_state unit_of_measurement: \"%\" state: > {% set myB1 = float(states('sensor.solaredge_b1_state_of_energy'),0) %} {% set myB2 = float(states('sensor.solaredge_b2_state_of_energy'),0) %} {% set myB3 = float(states('sensor.solaredge_b3_state_of_energy'),0) %} {% set myValue = ((myB1 + myB2 + myB3) / 3) | round(0) %} {{ myValue }} # Total Energy Stored in the Batteries - name: \"Calc Battery Total Capacity\" unique_id: calc_battery_total_capacity unit_of_measurement: kWh state: > {% set myB1 = float(states('sensor.solaredge_b1_maximum_energy'),0) %} {% set myB2 = float(states('sensor.solaredge_b2_maximum_energy'),0) %} {% set myB3 = float(states('sensor.solaredge_b3_maximum_energy'),0) %} {% set myValue = ((myB1 + myB2 + myB3)) %} {{ myValue }} # Current Energy Stored in the Batteries - name: \"Calc Battery Current Capacity\" unique_id: calc_battery_current_capacity unit_of_measurement: kWh state: > {% set myValue = (float(states('sensor.calc_battery_all_state'),0) / 100) * float(states('sensor.calc_battery_total_capacity'),0) %} {{ myValue }}","title":"SolarEdge Inverters"},{"location":"inverter-setup/#solax-cloud","text":"Experimental Predbat now has a built-in Solax cloud integration. See the components documentation for details Components - Solax cloud","title":"Solax Cloud"},{"location":"inverter-setup/#solax-gen4-inverters","text":"The Predbat Solax configuration can either either use the Mode1 remote control or the newer Mode8 option. Both should work with the SolaX Gen 4, 5 or 6 inverters. Thanks @TCWORLD for this configuration. Please copy the template https://github.com/springfall2008/batpred/blob/main/templates/solax_sx4.yaml over the top of your apps.yaml , and modify it for your system and the work mode that your inverter is set to Install and configure the Solax Modbus integration in Home Assistant and confirm that it is connected to your inverter The regular expressions in the custom SX4+ apps.yaml should auto-match to the entity names provided by your Solax Modbus integration, but do double-check that they do To use Mode 1 remote control, create and save the following automation script (Settings/Automations/Scripts) which will act as the interface between Predbat and the Solax Modbus integration. You can change the limits for the power field if you have a larger inverter, it doesn't matter if this limit is larger than the inverter can handle as the value gets clipped to the inverter limits by the Solax Modbus integration. You may need to amend the 'solax_' prefixes on the entity names that this script sets if your Modbus integration has slightly different entity names (e.g. 'solaxmodbus_' or 'solax_inverter_'): alias: SolaX Remote Control description: \"\" fields: power: selector: number: min: 0 max: 6600 default: 0 operation: selector: select: multiple: false options: - Disabled - Force Charge - Force Discharge - Freeze Charge - Freeze Discharge default: Disabled required: false duration: selector: number: min: 300 max: 86400 default: 28800 required: false sequence: - variables: defaultPower: \"{{ 200 }}\" mode: |- {% set map = { 'Disabled': 'Disabled', 'Force Charge': 'Enabled Battery Control', 'Force Discharge': 'Enabled Battery Control', 'Freeze Charge': 'Enabled No Discharge', 'Freeze Discharge': 'Enabled Feedin Priority'} %} {{ map.get( operation, 'Disabled' ) }} activeP: >- {% set chargePower = (power | int(defaultPower)) if power is defined else defaultPower %} {% set dischargePower = (0 - chargePower) %} {% set map = { 'Disabled': 0, 'Force Charge': chargePower, 'Force Discharge': dischargePower, 'Freeze Charge': 0, 'Freeze Discharge': 0} %} {{ map.get( operation, 0 ) }} - action: number.set_value data: value: \"{{ activeP }}\" target: entity_id: number.solax_remotecontrol_active_power - action: number.set_value data: value: \"60\" target: entity_id: number.solax_remotecontrol_duration - action: number.set_value data: value: \"{{ duration if duration is defined else 28800 }}\" target: entity_id: number.solax_remotecontrol_autorepeat_duration - action: select.select_option data: option: \"{{ mode if mode is defined else Disabled }}\" target: entity_id: select.solax_remotecontrol_power_control - action: button.press data: {} target: entity_id: button.solax_remotecontrol_trigger mode: queued max: 10 To use Mode 1 remote control, ensure the following entities are enabled: number.solax_remotecontrol_active_power number.solax_remotecontrol_duration number.solax_remotecontrol_autorepeat_duration select.solax_remotecontrol_power_control button.solax_remotecontrol_trigger To use Mode 8 power control API (Gen 4 or newer inverter) which has direct control over the battery charge/discharge rate, and can directly set the battery (dis)charge rate without limiting any PV generation, create and save the following automation script (Settings/Automations/Scripts) which will act as the interface between Predbat and the Solax Modbus integration. In the script, change 'maxPvPower: \"{{ 12000 }}\"' to a value larger than your PV array size so the script doesn't limit PV generation. Change 'max: 6600' - to a value larger than the maximum charge/discharge power for your battery (doesn't matter if higher). Note: Mode8 requires version 2025.10.7 or newer of the SolaX Modbus integration as there are some necessary Mode 8 improvements added: alias: SolaX Remote Control (Mode 8) description: \"\" fields: power: selector: number: min: 0 max: 6600 default: 0 operation: selector: select: multiple: false options: - Disabled - Force Charge - Force Discharge - Freeze Charge - Freeze Discharge default: Disabled required: false duration: selector: number: min: 60 max: 86400 default: 28800 sequence: - variables: maxPvPower: \"{{ 12000 }}\" defaultPower: \"{{ 200 }}\" mode: |- {% set map = { 'Disabled': 'Disabled', 'Force Charge': 'Mode 8 - PV and BAT control - Duration', 'Force Discharge': 'Mode 8 - PV and BAT control - Duration', 'Freeze Charge': 'Enabled No Discharge', 'Freeze Discharge': 'Export-First Battery Limit'} %} {{ map.get( operation, 'Disabled' ) }} activeP: >- {% set dischargePower = (power | int(defaultPower)) if power is defined else defaultPower %} {% set chargePower = (0 - dischargePower) %} {% set map = { 'Disabled': 0, 'Force Charge': chargePower, 'Force Discharge': dischargePower, 'Freeze Charge': 0, 'Freeze Discharge': 0} %} {{ map.get( operation, 0 ) }} - action: number.set_value data: value: \"{{ activeP }}\" target: entity_id: number.solax_remotecontrol_push_mode_power_8_9 - action: number.set_value data: value: \"{{ maxPvPower }}\" target: entity_id: number.solax_remotecontrol_pv_power_limit - action: number.set_value data: value: \"30\" target: entity_id: number.solax_remotecontrol_duration - action: number.set_value data: value: \"300\" target: entity_id: number.solax_remotecontrol_timeout - action: number.set_value data: value: \"{{ duration if duration is defined else 28800 }}\" target: entity_id: number.solax_remotecontrol_autorepeat_duration - action: select.select_option data: option: VPP Off target: entity_id: select.solax_inverter_remotecontrol_timeout_next_motion_mode_1_9 - action: select.select_option data: option: \"{{ mode if mode is defined else Disabled }}\" target: entity_id: select.solax_remotecontrol_power_control_mode - action: button.press data: {} enabled: true target: entity_id: button.solax_powercontrolmode8_trigger mode: queued max: 10 To use Mode 8 power control, ensure the following entities are enabled: number.solax_remotecontrol_push_mode_power_8_9 number.solax_remotecontrol_pv_power_limit number.solax_remotecontrol_duration number.solax_remotecontrol_timeout number.solax_remotecontrol_autorepeat_duration select.solax_inverter_remotecontrol_timeout_next_motion_mode_1_9 select.solax_remotecontrol_power_control_mode button.solax_powercontrolmode8_trigger Predbat needs a 'Todays House Load' sensor, this can be created from inverter-supplied information by creating two custom helper entities: Create a helper entity of type 'Integral', set the Name to 'Todays House Load Integral', Metric Prefix to 'k (kilo)', Time unit to 'Hours', Input sensor to 'House Load', Integration method to 'Trapezoidal', Precision to '2' and Max sub-interval to '0:05:00' Create a helper entity of type 'Utility Meter', set the Name to 'Todays House Load', Input sensor to 'Todays House Load Integral' (that you just created) and Meter Reset Cycle to 'Daily' If you are using the inverter in Backup mode then you will need to set input_number.predbat_set_reserve_min to no lower than 15% minimum SoC, other modes allow a lower minimum SoC of 10%. This is a Solax limitation. It has been reported by one Solax user that his inverter did not respond to commands from either the mode 1 or mode 8 scripts. The fix was to enable the hidden HA entity 'VPP Exit Idle Enable' and then change the entity value from Disabled to Enabled. Once this was Enabled the inverter responded correctly to Predbat commands. When you first start Predbat, check the Predbat log to confirm that the correct sensor names are identified by the regular expressions in apps.yaml . Any non-matching expressions should be investigated and resolved. Please see this ticket in Github for ongoing discussion: https://github.com/springfall2008/batpred/issues/259","title":"Solax Gen4+ Inverters"},{"location":"inverter-setup/#solis-cloud","text":"Experimental Predbat now has a built-in Solis cloud integration. See the components documentation for details Components - Solis cloud","title":"Solis Cloud"},{"location":"inverter-setup/#solis-inverters-before-fb00","text":"To run PredBat with Solis hybrid inverters with firmware level prior to FB00 (you can recognise these by having fewer than 6 slots for charging times), follow the following steps: Install PredBat as per the Installation Summary Ensure that you have the Solax Modbus integration running and select the inverter type solis. There are a number of entities which this integration disables by default that you will need to enable via the Home Assistant GUI: Name Description sensor.solis_rtc Real Time Clock sensor.solis_battery_power Battery Power Copy the template https://github.com/springfall2008/batpred/blob/main/templates/gilong_solis.yaml over the top of your apps.yaml , and modify it for your system Set solax_modbus_new in apps.yaml to True if you have integration version 2024.03.2 or greater Ensure that the inverter is set to Control Mode 35 - on the Solax integration this is Timed Charge/Discharge . If you want to use the Reserve functionality within PredBat you will need to select Backup/Reserve (code 51) instead but be aware that this is not fully tested. In due course, these mode settings will be incorporated into the code. Your inverter will require a \"button press\" triggered by Predbat to update the schedules. Some Solis inverter integrations feature a combined charge/discharge update button, in which case a single apps.yaml entry of: charge_discharge_update_button: - button.solis_update_charge_discharge_times Ensure the correct entity IDs are used for your specific inverter setup. These entries should correspond to the buttons exposed by your Home Assistant Solis integration.","title":"Solis Inverters before FB00"},{"location":"inverter-setup/#solis-inverters-fb00-or-later","text":"To run PredBat with Solis hybrid inverters with firmware level FB00 or later (you can recognise these by having 6 slots for charging times), follow the following steps: Install PredBat as per the Installation Summary Ensure that you have the Solax Modbus integration running and select the inverter type solis_fb00. There are a number of entities which this integration disables by default that you will need to enable via the Home Assistant GUI: Name Description sensor.solisx_rtc Real Time Clock sensor.solisx_battery_power Battery Power Copy the template https://github.com/springfall2008/batpred/blob/main/templates/gilong_solis.yaml over the top of your apps.yaml , and modify it for your system. You will need to update these lines: Replace inverter_type: \"GS\" with inverter_type: \"GS_fb00\" to enable the inverter template for the newer firmware version of Solis inverters Un-comment charge_update_button and discharge_update_button and comment out charge_discharge_update_button to enable the two \"button presses\" needed for writing charge/discharge times to the inverter Un-comment scheduled_charge_enable and scheduled_discharge_enable to enable Predbat to enable/disable the charge/discharge slots Un-comment charge_limit to enable the charge limit through setting an upper SoC value Set solax_modbus_new to True if you have integration version 2024.03.2 or greater Lastly you will need to comment out or delete the template line to enable the configuration Save the file as apps.yaml to the appropriate Predbat software directory . Ensure that the inverter is set to Control Mode 35 - on the Solax integration this is Timed Charge/Discharge . If you want to use the Reserve functionality within PredBat you will need to select Backup/Reserve (code 51) instead but be aware that this is not fully tested. In due course, these mode settings will be incorporated into the code. Note: Predbat will read the minimum SoC level set on the inverter via sensor.solis_battery_minimum_soc configured in apps.yaml . You must set the minimum SoC level that Predbat will set in input_number.predbat_set_reserve_min to at least 1% more than the inverter minimum SoC. So for example, if the inverter minimum SoC is set to 20%, predbat_set_reserve_min must be set to at least 21%. If this is not done then when Predbat sets the reserve SoC, the instruction will be rejected by the inverter and Predbat will error. Ensure the correct entity IDs are used for your specific inverter setup. These entries should correspond to the buttons exposed by your Home Assistant Solis integration.","title":"Solis Inverters FB00 or later"},{"location":"inverter-setup/#sunsynk","text":"Copy the Sunsynk template over the top of your apps.yaml , and edit for your system. Create the following Home Assistant automations: alias: Predbat Charge / Discharge Control description: \"Turn SunSynk charge/discharge on/off to mirror Predbat\" trigger: - platform: state entity_id: - binary_sensor.predbat_charging to: \"on\" id: predbat_charge_on - platform: state entity_id: - binary_sensor.predbat_charging to: \"off\" id: predbat_charge_off - platform: state entity_id: - binary_sensor.predbat_exporting to: \"on\" id: predbat_discharge_on - platform: state entity_id: - binary_sensor.predbat_exporting to: \"off\" id: predbat_discharge_off condition: [] action: - choose: - conditions: - condition: trigger id: - predbat_charge_on sequence: - service: switch.turn_on data: {} target: entity_id: switch.sunsynk_grid_charge_timezone1 - conditions: - condition: trigger id: - predbat_charge_off sequence: - service: switch.turn_off target: entity_id: - switch.sunsynk_grid_charge_timezone1 data: {} - conditions: - condition: trigger id: - predbat_discharge_on sequence: - service: switch.turn_on data: {} target: entity_id: switch.sunsynk_solar_sell - conditions: - condition: trigger id: - predbat_discharge_off sequence: - service: switch.turn_off target: entity_id: - switch.sunsynk_solar_sell data: {} mode: single alias: PredBat - Copy Charge Limit description: Copy Battery SoC to all timezone (time) slots trigger: - platform: state entity_id: - number.sunsynk_set_soc_timezone1 to: null condition: [] action: - service: number.set_value data_template: entity_id: - number.sunsynk_set_soc_timezone2 - number.sunsynk_set_soc_timezone3 - number.sunsynk_set_soc_timezone4 - number.sunsynk_set_soc_timezone5 - number.sunsynk_set_soc_timezone6 value: \"{{ states('number.sunsynk_set_soc_timezone1')|int(20) }}\" mode: single Create the following templates sensors in your configuration.yaml : template: sensor: - name: \"sunsynk_max_battery_charge_rate\" unit_of_measurement: \"w\" state_class: measurement state: > {{ [8000,[states('input_number.sunsynk_battery_max_charge_current_limit')|int,states('sensor.sunsynk_battery_charge_limit_current')|int]|min * states('sensor.sunsynk_battery_voltage')|float]|min }} - name: \"sunsynk_max_battery_discharge_rate\" unit_of_measurement: \"w\" state_class: measurement state: > {{ [8000,[states('input_number.sunsynk_battery_max_discharge_current_limit')|int,states('sensor.sunsynk_battery_discharge_limit_current')|int]|min * states('sensor.sunsynk_battery_voltage')|float]|min }} - name: \"sunsynk_charge_rate_calc\" unit_of_measurement: \"w\" state_class: measurement state: > {{ [8000,[states('input_number.test_sunsynk_battery_max_charge_current')|int,states('sensor.sunsynk_battery_charge_limit_current')|int]|min * states('sensor.sunsynk_battery_voltage')|float]|min }} - name: \"sunsynk_discharge_rate_calc\" unit_of_measurement: \"w\" state_class: measurement state: > {{ [8000,[states('input_number.test_sunsynk_battery_max_discharge_current')|int,states('sensor.sunsynk_battery_discharge_limit_current')|int]|min * states('sensor.sunsynk_battery_voltage')|float]|min }}","title":"Sunsynk"},{"location":"inverter-setup/#tesla-powerwall","text":"Integration of the Tesla Powerwall follows the approach outlined in Ed Hull's blog . Ed's setup only covered Predbat controlling charging the Powerwall, the below configuration (thanks @Slee2112) covers both charging and discharging (exporting). Note: This Predbat Tesla configuration has been developed with a Powerwall 3. It may require changes for older Powerwall models. Please raise a GitHub issue with details of any changes you find are required so the documentation can be updated. The Predbat Tesla apps.yaml configuration was developed using the Tesla Fleet integration, and you can use this, or you can use the Teslemetry integration which provides easier access to Tesla API's, but requires a Teslemetry subscription Install and configure either the Tesla Fleet integration or Teslemetry integration in Home Assistant Copy the template tesla_powerwall.yaml template over the top of your apps.yaml , and edit for your system Exporting with Powerwall is tricky, as there is no built in button as such to do it, you have to trick the Powerwall to export by changing the tariff options using the Tesla API. In order to do this you firstly need to create an API refresh token. Create 8 input_text helpers to hold the Tesla access and refresh security tokens and your Tesla site id. These can be created via the HA UI, or added to configuration.yaml : input_text: tesla_refresh_token_part1: name: \"Tesla Refresh Token - Part 1\" max: 255 mode: password tesla_refresh_token_part2: name: \"Tesla Refresh Token - Part 2\" max: 255 mode: password tesla_refresh_token_part3: name: \"Tesla Refresh Token - Part 3\" max: 255 mode: password tesla_refresh_token_part4: name: \"Tesla Refresh Token - Part 4\" max: 255 mode: password tesla_access_token_part1: name: \"Tesla Access Token - Part 1\" max: 255 mode: password tesla_access_token_part2: name: \"Tesla Access Token - Part 2\" max: 255 mode: password tesla_access_token_part3: name: \"Tesla Access Token - Part 3\" max: 255 mode: password tesla_access_token_part4: name: \"Tesla Access Token - Part 4\" max: 255 mode: password tesla_energy_site_id: name: \"Tesla Energy Site ID\" unit_of_measurement: \"\" icon: mdi:lightning-bolt-outline Use the Access Token Generator for Tesla to create a token This token needs to be copied, and then split into 4 parts (up to 255 characters long), so each part can be copied into the \"refresh\" input helpers An automation then uses the refresh token to generate an access token valid for 8 hours, and a new refresh token than is valid for ~30 days. Create the following automation using the HA UI or by adding to configuration.yaml , the automation triggers an automatic refresh of the access token every 8 hours: automation: alias: \"Refresh Tesla Access Token\" description: \"Refresh Tesla access token every 8 hours\" trigger: platform: time_pattern hours: \"/8\" action: - service: rest_command.tesla_refresh_token response_variable: tesla_response - service: input_text.set_value target: entity_id: input_text.tesla_access_token_part1 data: value: \"{{ tesla_response.content.access_token[0:250] }}\" - service: input_text.set_value target: entity_id: input_text.tesla_access_token_part2 data: value: \"{{ tesla_response.content.access_token[250:500] }}\" - service: input_text.set_value target: entity_id: input_text.tesla_access_token_part3 data: value: \"{{ tesla_response.content.access_token[500:750] }}\" - service: input_text.set_value target: entity_id: input_text.tesla_access_token_part4 data: value: \"{{ tesla_response.content.access_token[750:] }}\" - service: input_text.set_value target: entity_id: input_text.tesla_refresh_token_part1 data: value: \"{{ tesla_response.content.refresh_token[0:250] }}\" - service: input_text.set_value target: entity_id: input_text.tesla_refresh_token_part2 data: value: \"{{ tesla_response.content.refresh_token[250:500] }}\" - service: input_text.set_value target: entity_id: input_text.tesla_refresh_token_part3 data: value: \"{{ tesla_response.content.refresh_token[500:750] }}\" - service: input_text.set_value target: entity_id: input_text.tesla_refresh_token_part4 data: value: \"{{ tesla_response.content.refresh_token[750:] }}\" - service: persistent_notification.create data: title: \"Tesla Tokens Updated\" message: \"Access and refresh tokens have been successfully updated\" notification_id: \"tesla_token_update\" An automation executes every time HA starts and every midnight to populate the Tesla site id input_helper. Create the following automation using the HA UI or by adding to configuration.yaml : automation: - alias: \"Update Tesla Energy Site ID\" trigger: - platform: homeassistant event: start - platform: time at: \"00:00:00\" action: - service: rest_command.tesla_api_get_products response_variable: products_response - service: input_text.set_value target: entity_id: input_text.tesla_energy_site_id data: value: \"{{ products_response.content.response[0].energy_site_id }}\" A number of REST commands are required to communicate to the Tesla API's: tesla_refresh_token - automatically regenerates access and refresh tokens, tesla_api_get_products - used to retrieve your Tesla site id, tesla_api_get_current_tariff - retrieves your current Tariff information from the Powerwall, tesla_api_set_export_now_tariff - sets a custom export rate tariff to force the Powerwall to export, tesla_api_set_iog_custom_tariff - returns the Powerwall to the Octopus IOG tariff. If you are on a different tariff you will need to customise the REST payload to your tariff details In configuration.yaml add the following lines: rest_command: tesla_refresh_token: url: \"https://auth.tesla.com/oauth2/v3/token\" method: POST content_type: \"application/x-www-form-urlencoded\" payload: >- grant_type=refresh_token&client_id=ownerapi&refresh_token={{ (states('input_text.tesla_refresh_token_part1') or '') + (states('input_text.tesla_refresh_token_part2') or '') + (states('input_text.tesla_refresh_token_part3') or '') + (states('input_text.tesla_refresh_token_part4') or '') }}&scope=openid%20email%20offline_access\" tesla_api_get_products: url: \"https://owner-api.teslamotors.com/api/1/products\" method: GET headers: Authorization: >- Bearer {{ (states('input_text.tesla_access_token_part1') or '') + (states('input_text.tesla_access_token_part2') or '') + (states('input_text.tesla_access_token_part3') or '') + (states('input_text.tesla_access_token_part4') or '') }} tesla_api_get_current_tariff: url: \"https://owner-api.teslamotors.com/api/1/energy_sites/{{ states('input_text.tesla_energy_site_id') }}/tariff_rate\" method: GET headers: Authorization: >- Bearer {{ (states('input_text.tesla_access_token_part1') or '') + (states('input_text.tesla_access_token_part2') or '') + (states('input_text.tesla_access_token_part3') or '') + (states('input_text.tesla_access_token_part4') or '') }} tesla_api_set_export_now_tariff: url: \"https://owner-api.teslamotors.com/api/1/energy_sites/{{ states('input_text.tesla_energy_site_id') }}/time_of_use_settings\" method: POST headers: Authorization: >- Bearer {{ (states('input_text.tesla_access_token_part1') or '') + (states('input_text.tesla_access_token_part2') or '') + (states('input_text.tesla_access_token_part3') or '') + (states('input_text.tesla_access_token_part4') or '') }} Content-Type: application/json payload: > {% set now = now() %} {% set minute = now.minute %} {% set start = now.replace(minute=0) if minute < 30 else now.replace(minute=30) %} {% set end = start + timedelta(minutes=60) %} {% set ns = namespace(super_off_peak_periods=[]) %} {% if start.hour > 0 %} {% set ns.super_off_peak_periods = ns.super_off_peak_periods + [{\"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 0, \"fromMinute\": 0, \"toHour\": start.hour, \"toMinute\": start.minute}] %} {% endif %} {% if end.hour > 0 %} {% set ns.super_off_peak_periods = ns.super_off_peak_periods + [{\"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": end.hour, \"fromMinute\": end.minute, \"toHour\": 0, \"toMinute\": 0}] %} {% endif %} { \"tou_settings\": { \"tariff_content_v2\": { \"version\": 1, \"utility\": \"Octopus Energy\", \"code\": \"OCTO-IOG-CUSTOM\", \"name\": \"Octopus IOG (Force Export Now)\", \"currency\": \"GBP\", \"monthly_minimum_bill\": 0, \"min_applicable_demand\": 0, \"max_applicable_demand\": 0, \"monthly_charges\": 0, \"daily_charges\": [ { \"name\": \"Charge\", \"amount\": 0 } ], \"daily_demand_charges\": {}, \"demand_charges\": { \"ALL\": { \"rates\": { \"ALL\": 0 } }, \"AllYear\": { \"rates\": {} } }, \"energy_charges\": { \"ALL\": { \"rates\": { \"ALL\": 0 } }, \"AllYear\": { \"rates\": { \"SUPER_OFF_PEAK\": 0.07, \"ON_PEAK\": 0.31 } } }, \"seasons\": { \"AllYear\": { \"fromMonth\": 1, \"fromDay\": 1, \"toMonth\": 12, \"toDay\": 31, \"tou_periods\": { \"SUPER_OFF_PEAK\": { \"periods\": {{ ns.super_off_peak_periods | tojson }} }, \"ON_PEAK\": { \"periods\": [ { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": {{ start.hour }}, \"fromMinute\": {{ start.minute }}, \"toHour\": {{ end.hour }}, \"toMinute\": {{ end.minute }} } ] } } } }, \"sell_tariff\": { \"min_applicable_demand\": 0, \"max_applicable_demand\": 0, \"monthly_minimum_bill\": 0, \"monthly_charges\": 0, \"utility\": \"Octopus Energy\", \"daily_charges\": [ { \"name\": \"Charge\", \"amount\": 0 } ], \"demand_charges\": { \"ALL\": { \"rates\": { \"ALL\": 0 } }, \"AllYear\": { \"rates\": {} } }, \"energy_charges\": { \"ALL\": { \"rates\": { \"ALL\": 0 } }, \"AllYear\": { \"rates\": { \"SUPER_OFF_PEAK\": 0.07, \"ON_PEAK\": 0.30 } } }, \"seasons\": { \"AllYear\": { \"fromMonth\": 1, \"fromDay\": 1, \"toMonth\": 12, \"toDay\": 31, \"tou_periods\": { \"SUPER_OFF_PEAK\": { \"periods\": {{ ns.super_off_peak_periods | tojson }} }, \"ON_PEAK\": { \"periods\": [ { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": {{ start.hour }}, \"fromMinute\": {{ start.minute }}, \"toHour\": {{ end.hour }}, \"toMinute\": {{ end.minute }} } ] } } } } } } } } tesla_api_set_iog_custom_tariff: url: \"https://owner-api.teslamotors.com/api/1/energy_sites/{{ states('input_text.tesla_energy_site_id') }}/time_of_use_settings\" method: POST headers: Authorization: >- Bearer {{ (states('input_text.tesla_access_token_part1') or '') + (states('input_text.tesla_access_token_part2') or '') + (states('input_text.tesla_access_token_part3') or '') + (states('input_text.tesla_access_token_part4') or '') }} Content-Type: application/json payload: > { \"tou_settings\": { \"tariff_content_v2\": { \"version\": 1, \"monthly_minimum_bill\": 0, \"min_applicable_demand\": 0, \"max_applicable_demand\": 0, \"monthly_charges\": 0, \"utility\": \"Octopus Energy\", \"code\": \"OCTO-IOG-CUSTOM\", \"name\": \"Octopus IOG (Custom-restored)\", \"currency\": \"GBP\", \"daily_charges\": [ { \"name\": \"Charge\", \"amount\": 0 } ], \"daily_demand_charges\": {}, \"demand_charges\": { \"ALL\": { \"rates\": { \"ALL\": 0 } }, \"AllYear\": { \"rates\": {} } }, \"energy_charges\": { \"ALL\": { \"rates\": { \"ALL\": 0 } }, \"AllYear\": { \"rates\": { \"SUPER_OFF_PEAK\": 0.07, \"PARTIAL_PEAK\": 0.31, \"ON_PEAK\": 0.31 } } }, \"seasons\": { \"AllYear\": { \"fromMonth\": 1, \"fromDay\": 1, \"toMonth\": 12, \"toDay\": 31, \"tou_periods\": { \"SUPER_OFF_PEAK\": { \"periods\": [ { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 0, \"fromMinute\": 0, \"toHour\": 5, \"toMinute\": 30 }, { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 23, \"fromMinute\": 30, \"toHour\": 0, \"toMinute\": 0 } ] }, \"ON_PEAK\": { \"periods\": [ { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 2, \"fromMinute\": 0, \"toHour\": 3, \"toMinute\": 0 }, { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 5, \"fromMinute\": 30, \"toHour\": 16, \"toMinute\": 0 }, { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 16, \"fromMinute\": 0, \"toHour\": 19, \"toMinute\": 0 }, { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 19, \"fromMinute\": 0, \"toHour\": 23, \"toMinute\": 30 } ] } } } }, \"sell_tariff\": { \"min_applicable_demand\": 0, \"max_applicable_demand\": 0, \"monthly_minimum_bill\": 0, \"monthly_charges\": 0, \"utility\": \"Octopus Energy\", \"daily_charges\": [ { \"name\": \"Charge\", \"amount\": 0 } ], \"demand_charges\": { \"ALL\": { \"rates\": { \"ALL\": 0 } }, \"AllYear\": { \"rates\": {} } }, \"energy_charges\": { \"ALL\": { \"rates\": { \"ALL\": 0 } }, \"AllYear\": { \"rates\": { \"SUPER_OFF_PEAK\": 0.07, \"PARTIAL_PEAK\": 0.30, \"ON_PEAK\": 0.22 } } }, \"seasons\": { \"AllYear\": { \"fromMonth\": 1, \"fromDay\": 1, \"toMonth\": 12, \"toDay\": 31, \"tou_periods\": { \"SUPER_OFF_PEAK\": { \"periods\": [ { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 0, \"fromMinute\": 0, \"toHour\": 5, \"toMinute\": 30 }, { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 23, \"fromMinute\": 30, \"toHour\": 0, \"toMinute\": 0 } ] }, \"ON_PEAK\": { \"periods\": [ { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 2, \"fromMinute\": 0, \"toHour\": 3, \"toMinute\": 0 }, { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 5, \"fromMinute\": 30, \"toHour\": 16, \"toMinute\": 0 }, { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 16, \"fromMinute\": 0, \"toHour\": 19, \"toMinute\": 0 }, { \"fromDayOfWeek\": 0, \"toDayOfWeek\": 6, \"fromHour\": 19, \"fromMinute\": 0, \"toHour\": 23, \"toMinute\": 30 } ] } } } } } } } } Manually run the two automations to ensure the helper input_texts are all pre-populated before use.","title":"Tesla Powerwall"},{"location":"inverter-setup/#victron","text":"This is at an early stage of development, see Github discussion #789 and #2846","title":"Victron"},{"location":"inverter-setup/#i-want-to-add-an-unsupported-inverter-to-predbat","text":"First copy one of the template configurations that is close to your system and try to configure it to match the sensors you have Create a GitHub ticket for support and add what you know to the ticket Then find out how to control your inverter inside Home Assistant, ideally share any automation you have to control the inverter You can create a new inverter type in apps.yaml and change the options as to which controls it has You must set inverter_type in apps.yaml with a custom name ('MINE' in the example below) - if you do not do this then Predbat will assume you have a GivEnergy inverter and will apply inverter limits for that inverter (e.g. max charge/discharge of 2600W) Configure Predbat with the appropriate Home Assistant services to start charges and discharges, etc. The following template can be used as a starting point: inverter_type: MINE inverter: name: \"MINE\" has_rest_api: False has_mqtt_api: False has_service_api: True output_charge_control: \"power\" charge_control_immediate: False current_dp: 1 charge_discharge_with_rate: False has_charge_enable_time: False has_discharge_enable_time: False has_target_soc: False target_soc_used_for_discharge: True has_reserve_soc: False has_timed_pause: False time_button_press: False support_charge_freeze: False support_discharge_freeze: False has_ge_inverter_mode: False has_fox_inverter_mode: False has_idle_time: False has_time_window: False charge_time_format: \"S\" charge_time_entity_is_option: False can_span_midnight: False clock_time_format: \"%Y-%m-%d %H:%M:%S\" num_load_entities: 1 soc_units: \"%\" write_and_poll_sleep: 2 # Services to control charging/discharging charge_start_service: service: select.select_option entity_id: \"select.solaredge_i1_storage_command_mode\" option: \"Charge from Solar Power and Grid\" charge_stop_service: service: select.select_option entity_id: \"select.solaredge_i1_storage_command_mode\" option: \"Charge from Solar Power\" discharge_start_service: service: select.select_option entity_id: \"select.solaredge_i1_storage_command_mode\" option: \"Maximize Self Consumption\"","title":"I want to add an unsupported inverter to Predbat"},{"location":"inverter-setup/#inverter-control-options","text":"The following options are supported per inverter:","title":"Inverter control options"},{"location":"inverter-setup/#has_rest_api","text":"When True the REST API will be used to fetch data/control the inverter. This is currently only for GivEnergy inverters with GivTCP and givtcp_rest must be set in apps.yaml","title":"has_rest_api"},{"location":"inverter-setup/#has_mqtt_api","text":"When True the Home Assistant MQTT API will be used to issue control messages for the inverter The MQTT/publish service is used with the topic as defined by mqtt_topic in apps.yaml Messages will be sent through these controls: Values that are updated: topic /set/reserve - payload=reserve topic /set/charge_rate - payload=new_rate topic /set/discharge_rate - payload=new_rate topic /set/target_soc - payload=target_soc These three messages change between battery charge/discharge and auto (demand) mode: topic /set/charge - payload=charge_rate topic /set/discharge - payload=discharge_rate topic /set/auto - payload=true","title":"has_mqtt_api"},{"location":"inverter-setup/#has_service_api","text":"When True a Home Assistant service will be used to issue control messages for the inverter. For each service you wish to use it must be defined in apps.yaml . There are two ways to define a service, the basic mode: charge_start_service: my_service_name_charge Will call my_service_name_charge for the charge start service. Or the custom method where you can define all the parameter values passed to the service and use the default values from the template, or define your own: charge_start_service: - service: my_charge_start_service device_id: \"{device_id}\" power: \"{power}\" soc: \"{target_soc}\" charge_start_time: \"{charge_start_time}\" charge_end_time: \"{charge_end_time}\" ```text You can also call more than one service e.g: ```yaml charge_start_service: - service: my_charge_start_service device_id: \"{device_id}\" power: \"{power}\" soc: \"{target_soc}\" - service: switch.turn_off entity_id: switch.tsunami_charger Note: By default the service will only be called once until things change, e.g. charge_start_service will be called once and then won't be called again until charge_stop_service stops the charge. If however, you want the service to be called on each Predbat run then you should set repeat to True for the given service e.g: yaml charge_start_service: - service: my_charge_start_service device_id: \"{device_id}\" power: \"{power}\" soc: \"{target_soc}\" repeat: True text","title":"has_service_api"},{"location":"inverter-setup/#charge_start_service","text":"Called to start a charge The default options passed in are: device_id - as defined in apps.yaml by device_id target_soc - The SoC to charge to power - The charge power to use charge_start_time - Start time for the charge charge_end_time - End time for the charge","title":"charge_start_service"},{"location":"inverter-setup/#charge_freeze_service","text":"If defined will be called for freeze charge, otherwise, charge_start_service is used for freeze charge also. Note that switch.predbat_set_charge_freeze must be turned on for Predbat to plan Freeze Charge activity, and as this is an expert mode option, Predbat's Expert Mode must be turned on first.","title":"charge_freeze_service"},{"location":"inverter-setup/#charge_stop_service","text":"Called to stop a charge device_id - as defined in apps.yaml by device_id","title":"charge_stop_service"},{"location":"inverter-setup/#discharge_start_service","text":"Called to start a discharge The default options passed in are: device_id - as defined in apps.yaml by device_id target_soc - The SoC to discharge to power - The discharge power to use","title":"discharge_start_service"},{"location":"inverter-setup/#discharge_freeze_service","text":"If defined will be called for Discharge freeze, otherwise, discharge_start_service is used for freeze discharge also.","title":"discharge_freeze_service"},{"location":"inverter-setup/#discharge_stop_service","text":"Called to stop a discharge, if not set then charge_stop_service will be used instead device_id - as defined in apps.yaml by device_id","title":"discharge_stop_service"},{"location":"inverter-setup/#output_charge_control","text":"Controls what charge control units are to be used when starting charging. Set to \"power\", \"current\" or \"none\". When set to \"power\", Predbat will use the inverter sensors configured as charge_rate and discharge_rate in apps.yaml to set the inverter charge/discharge power levels. These inverter sensors must be in watts. When set to \"current\", Predbat will use the inverter sensors configured as timed_charge_current and timed_discharge_current in apps.yaml to set the inverter charge/discharge current levels. These inverter sensors must be in amps. Additionally if you are using \"current\" control for your inverter you must set battery_voltage in apps.yaml to your nominal maximum battery voltage (NB: not the current battery voltage) as Predbat will use this to convert its output commands from watts to amps for the inverter.","title":"output_charge_control"},{"location":"inverter-setup/#charge_control_immediate","text":"When True, the inverter uses timed_charge_current and timed_discharge_current in apps.yaml to control charging and discharging by setting current levels directly, instead of following a time-based plan.","title":"charge_control_immediate"},{"location":"inverter-setup/#current_dp","text":"Sets the number of decimal places to be used when setting the current in Amps, which should be 0 or 1.","title":"current_dp"},{"location":"inverter-setup/#charge_discharge_with_rate","text":"When True, the inverter requires that when charging the discharge rate must set be 0; and vice-versa, when discharging the charge rate must be set to 0. When False, the charge/discharge rate does not have to change.","title":"charge_discharge_with_rate"},{"location":"inverter-setup/#has_charge_enable_time","text":"When True, Predbat uses the scheduled_charge_enable switch configured in apps.yaml to enable/disable timed charging on the inverter.","title":"has_charge_enable_time"},{"location":"inverter-setup/#has_discharge_enable_time","text":"When True, Predbat uses the scheduled_discharge_enable switch configured in apps.yaml to enable/disable timed discharging on the inverter.","title":"has_discharge_enable_time"},{"location":"inverter-setup/#has_target_soc","text":"When True, Predbat uses the charge_limit sensor configured in apps.yaml to set the target charge SoC % setting for the inverter. The charge limit is the limit that the inverter will charge the battery up to. When False, charging will be turned on and off by Predbat rather than the inverter doing it based on the target SoC %.","title":"has_target_soc"},{"location":"inverter-setup/#target_soc_used_for_discharge","text":"When True, Predbat will use the charge_limit sensor configured in apps.yaml to control the target discharge SoC% for the inverter. When False, Predbat will not adjust the charge_limit sensor when discharging.","title":"target_soc_used_for_discharge"},{"location":"inverter-setup/#has_reserve_soc","text":"When True, Predbat uses the reserve sensor configured in apps.yaml to set the discharge reserve SoC % for the inverter. The reserve SoC is the target % to discharge the battery down to. When False, discharging will be turned on and off by Predbat rather than the inverter doing it based on discharge SoC %.","title":"has_reserve_soc"},{"location":"inverter-setup/#has_timed_pause","text":"When True, Predbat uses the pause_mode and optional pause_start_time and pause_end_time settings in apps.yaml to pause the inverter from charging and discharging the battery. This setting is for GivEnergy systems only right now.","title":"has_timed_pause"},{"location":"inverter-setup/#time_button_press","text":"When True, the inverter requires a button press to update the inverter registers from the Home Assistant values. The apps.yaml setting charge_discharge_update_button is the entity name of the button that Predbat will \"push\" to update the inverter registers.","title":"time_button_press"},{"location":"inverter-setup/#support_charge_freeze","text":"When True, the inverter supports charge freeze modes.","title":"support_charge_freeze"},{"location":"inverter-setup/#support_discharge_freeze","text":"When True, the inverter supports discharge freeze modes.","title":"support_discharge_freeze"},{"location":"inverter-setup/#has_ge_inverter_mode","text":"When True, the inverter supports the GivEnergy inverter modes (ECO, Timed Export etc).","title":"has_ge_inverter_mode"},{"location":"inverter-setup/#has_fox_inverter_mode","text":"When True, the inverter supports Fox inverter modes, i.e. Eco (Paused) is treated the same as Eco mode and the inverter mode is always set to \"SelfUse\" as all charging and discharging is controlled by schedule, not inverter modes.","title":"has_fox_inverter_mode"},{"location":"inverter-setup/#has_idle_time","text":"When True, the inverter has an idle time register which must be set to the start and end times for Eco mode (GivEnergy EMS). idle_start_time and idle_end_time must be configured in apps.yaml to the appropriate inverter controls.","title":"has_idle_time"},{"location":"inverter-setup/#has_time_window","text":"Not currently used by Predbat.","title":"has_time_window"},{"location":"inverter-setup/#charge_time_format","text":"This setting is used to control what format of charge and discharge times the inverter requires. When set to \"HH:MM:SS\", Predbat will control the inverter charge/discharge start and end times by setting the entities defined by charge_start_time , charge_end_time , discharge_start_time and discharge_end_time in apps.yaml . The format of these entities depends on charge_time_entity_is_option as defined below. When set to \"H M\", Predbat will control the inverter charge/discharge start and end times by setting the entities defined by charge_start_hour , charge_start_minute , charge_end_hour , charge_end_minute , discharge_start_hour , discharge_start_minute , discharge_end_hour and discharge_end_minute in apps.yaml . These entities are used to set the start and end hours and minutes of charges and discharges. When set to \"H:M-H:M\", Predbat will control the inverter charge/discharge start and end times by setting the entities defined by charge_time and discharge_time in apps.yaml . The entities take a single time range value in the format \" start hour : start minute - end hour : end minute \"","title":"charge_time_format"},{"location":"inverter-setup/#charge_time_entity_is_option","text":"When True, charge_start_time charge_end_time discharge_start_time and discharge_end_time are all option selectors for time in the format HH:MM:SS (e.g. 12:23:00) where seconds are always 00. When False, these entities are all number values.","title":"charge_time_entity_is_option"},{"location":"inverter-setup/#can_span_midnight","text":"When True, start and end times for charge and discharge can span midnight e.g. 23:00:00 - 01:00:00 is a 2-hour slot. When False, start and end times can't span midnight and Predbat will control the inverter with separate charges/discharges up to and then after midnight if required by the plan.","title":"can_span_midnight"},{"location":"inverter-setup/#clock_time_format","text":"Defines the time format of the inverter clock setting inverter_time in apps.yaml","title":"clock_time_format"},{"location":"inverter-setup/#num_load_entities","text":"Enables you to define additional house load power sensors in apps.yaml in addition to the default load_power sensor. e.g. if set to 2 then Predbat will additionally use load_power_1 and load_power_2 settings in apps.yaml . This setting might be required for 3-phase inverters.","title":"num_load_entities"},{"location":"inverter-setup/#soc_units","text":"Defines the units of the SoC setting (currently not used), it defaults to \"%\".","title":"soc_units"},{"location":"inverter-setup/#write_and_poll_sleep","text":"Sets the number of seconds between polls of inverter settings.","title":"write_and_poll_sleep"},{"location":"load-ml/","text":"ML Load Prediction Predbat includes a neural network-based machine learning component that can predict your household energy consumption for the next 48 hours. This prediction is based on historical load patterns, time-of-day patterns, day-of-week patterns, and optionally PV generation history and temperature forecasts. Table of Contents Overview How the Neural Network Works Configuration Setup Instructions Understanding the Model Monitoring and Troubleshooting Model Persistence Overview The ML Load Prediction component uses a lightweight multi-layer perceptron (MLP) neural network implemented in pure NumPy. It learns from your historical energy consumption patterns and makes predictions about future load. Key Features: Predicts 48 hours of load data in 5-minute intervals Learns daily and weekly patterns automatically Supports historical PV generation data as an input feature Supports temperature forecast data for improved accuracy Uses historical and future energy import/export rates as input features Deep neural network with 4 hidden layers [512, 256, 128, 64 neurons] Optimized with He initialization and AdamW weight decay for robust training Automatically trains on historical data (requires at least 1 day, recommended 7+ days, up to 28 days configurable) Fine-tunes periodically (every 2 hours) using full dataset to adapt to changing patterns Time-weighted training prioritizes recent data while learning from historical patterns Model persists across restarts Falls back gracefully if predictions are unreliable How the Neural Network Works Architecture The ML Load Predictor uses a deep multi-layer perceptron (MLP) with the following architecture: Input Layer : 1444 features (288 load + 288 PV + 288 temperature + 288 import rates + 288 export rates + 4 time features) Hidden Layers : 4 layers with [512, 256, 128, 64] neurons using ReLU activation Output Layer : 1 neuron (predicts next 5-minute step) Total Parameters : ~500,000 trainable weights Optimization Techniques: He Initialization : Weights initialized using He/Kaiming method ( std = sqrt(2/fan_in) ), optimized for ReLU activations AdamW Optimizer : Adam optimization with weight decay (L2 regularization, default 0.01) to prevent overfitting Early Stopping : Training halts if validation error stops improving (patience=5 epochs) Weighted Samples : Recent data weighted more heavily (exponential decay over history period) Input Features The neural network uses several types of input features to make predictions: Historical Load Lookback - Past 24 hours of energy consumption at 5-minute intervals - Helps the network understand recent usage patterns Historical PV Generation - Past 24 hours of solar PV generation at 5-minute intervals - Helps correlate solar production with consumption patterns - Requires pv_today sensor to be configured Historical Temperature - Past 24 hours of temperature data at 5-minute intervals - Helps correlate temperature with energy usage (heating/cooling) - Requires the Temperature component to be enabled Historical Import/Export Energy Rates (288 + 288 features) - Past 24 hours of electricity import rates at 5-minute intervals - Past 24 hours of electricity export rates at 5-minute intervals - Helps the model learn consumption patterns based on time-of-use pricing - Automatically extracted from your configured Octopus Energy tariffs or other rate sources - Particularly useful for homes that shift usage to cheaper rate periods Cyclical Time Features (4 features) - Sin/Cos encoding of minute-of-day (captures daily patterns with 5-min precision) - Sin/Cos encoding of day-of-week (captures weekly patterns) - These features help the network understand that 23:55 is close to 00:05 Prediction Process The model uses an autoregressive approach: Takes the last 24 hours of historical data Predicts the next 5-minute step Adds that prediction to the history window Shifts the window forward and repeats Continues for 576 steps to cover 48 hours To prevent drift in long-range predictions, the model blends autoregressive predictions with historical daily patterns. Training Process Initial Training: Requires at least 1 day of historical data (7+ days recommended, up to 28 days configurable) Fetches up to 28 days of load history by default (configurable via load_ml_max_days_history ) Uses 100 epochs with early stopping (patience=5) Batch size: 128 samples AdamW optimizer with learning rate 0.001 and weight decay 0.01 Sample weighting: exponential time decay (recent data weighted more) Validates on the last 24 hours of data Saves model to disk: predbat_ml_model.npz Regularization: Weight Decay : L2 penalty (0.01) applied to network weights to prevent overfitting Early Stopping : Training halts if validation error doesn't improve for 5 consecutive epochs, selecting the best results so far. Time-Weighted Samples : Recent data has higher importance (7-day exponential decay constant) Today's data: 100% weight N days old: 37% weight (e^-1) Fine-tuning: Runs every 2 hours if enabled Uses full available dataset (same as initial training, up to 28 days) Uses 3 epochs to quickly adapt to recent changes Applies same time-weighted sampling to prioritize recent data Preserves learned patterns while adapting to new ones Same regularization techniques applied as initial training Each fine-tune cycle blends the current data's feature statistics (mean/std) with the stored normalization parameters via an exponential moving average (alpha=0.1). This lets the model slowly track long-term shifts in feature distributions (e.g. seasonal load changes, new tariff rates) without sudden jumps that could destabilise existing weights. Why Full Dataset for Fine-tuning? Although fine-tuning uses up to 20 epochs (vs 100 for initial training), it still uses the full dataset with time-weighted sampling. This approach: Prevents catastrophic forgetting : Using only recent data would cause the model to gradually forget older patterns Balances adaptation : Time weighting ensures recent changes are prioritized while maintaining long-term pattern knowledge Handles seasonal patterns : 28 days of history helps capture weekly cycles and early seasonal trends Provides stability : The model learns from a broader context, making predictions more robust With time-weighted sampling, training samples have these relative weights: This week : 100% - 50% (fully weighted) Last week : 50% - 20% (moderately weighted) 2 weeks ago : 20% - 7% (lightly weighted) 3-4 weeks ago : 7% - 1% (minimal weight, but still contributing to pattern learning) This allows the model to adapt quickly to recent changes (via time weighting) without losing the benefit of learning from historical patterns. Model Validation: Model is validated after each training session If validation error exceeds threshold (default 2.0 kWh MAE), predictions are disabled Model is considered stale after 48 hours and requires retraining Configuration Basic Setup To enable ML load prediction, add to your apps.yaml : predbat: module: predbat class: PredBat # Enable ML load prediction load_ml_enable: True # Use the output data in Predbat (can be False to explore the use without using the data) load_ml_source: True # Optional: Maximum days of historical data to use for training (default: 28) # load_ml_max_days_history: 28 Configuration Parameter Details: load_ml_enable : Enables the ML component (required) load_ml_source : When true , Predbat uses ML predictions for battery planning. Set to false to test predictions without affecting battery control load_ml_max_days_history : Maximum days of historical data to fetch and train on Default : 28 days Minimum : 1 day (not recommended for production) Recommended : 7-28 days depending on your consumption patterns When to increase : If you have very regular weekly patterns or want seasonal awareness When to decrease : If your consumption patterns change frequently, or you have limited historical data storage Note : Training time increases slightly with more data, but fine-tuning remains fast (3 epochs) For best results: Ensure you have a least a weeks worth of data before enabling load_ml_source. Make sure you do not have PredAI enabled at the same time Disable in day adjustment (switch.predbat_calculate_inday_adjustment) as the AI model will do that for you. Recommended: Enable Temperature Predictions For best results, enable the Temperature component to provide temperature forecasts: predbat: # ... other config ... # Enable temperature predictions (RECOMMENDED for ML load prediction) temperature_enable: true # Optional: specify coordinates (defaults to zone.home) # temperature_latitude: 51.5074 # temperature_longitude: -0.1278 The temperature data significantly improves prediction accuracy for homes with heating/cooling systems, as energy consumption is often correlated with outside temperature. Optional: Add PV Generation Data Your PV data will be picked from the pv_today setting in Predbat already predbat: # ... other config ... pv_today: - sensor.my_solar_generation_today Optional: Subtract Car Charging If you have an EV charger set in Predbat then this will be subtracted from predictions. If this is not set then the default EV charging threshold is used if car_charging_hold is True. predbat: # ... other config ... # Optional: subtract car charging from load history car_charging_energy: - sensor.my_ev_charger_energy Setup Instructions Step 1: Verify Prerequisites Before enabling ML load prediction: Ensure you have a load_today sensor that tracks cumulative daily energy consumption Optionally configure pv_today if you have solar panels Recommended : Enable the Temperature component (Temperature Component in components documentation) Ensure you have at least 1 day of historical data (7+ days recommended, up to 28 days by default) Step 2: Enable the Component Add load_ml_enable: true to your apps.yaml and restart Predbat. Step 3: Wait for Initial Training On first run, the component will: Fetch historical load data (default: up to 28 days, configurable) Train the neural network (takes 1-5 minutes depending on data) Validate the model Begin making predictions if validation passes Check the Predbat logs for training progress: ML Component: Starting initial training ML Predictor: Starting initial training with 100 epochs ML Predictor: Training complete, final val_mae=0.3245 kWh ML Component: Initial training completed, validation MAE=0.3245 kWh Step 4: Monitor Predictions Once trained, the component publishes predictions to: sensor.predbat_load_ml_forecast - Contains 48-hour prediction in results attribute You can visualize these predictions in the Predbat web interface or by creating charts in Home Assistant. Understanding the Model Model Status The ML component tracks several status indicators: Model Status : not_initialized , training , active , validation_failed , stale Validation MAE : Mean Absolute Error on validation data (see Understanding MAE for details) Model Age : How long since the model was last trained You can check model status in the Predbat logs or via the component status page in the web interface. What Makes Good Predictions? Good predictions require: Sufficient Historical Data : At least 7 days recommended for stable patterns (supports up to 28 days by default) Consistent Patterns : Regular daily/weekly routines improve accuracy Temperature Data : Especially important for homes with electric heating/cooling (requires Temperature component) Energy Rate Data : Automatically included - helps model learn consumption patterns based on time-of-use tariffs PV Generation Data : If you have solar panels, include pv_today sensor for better correlation Clean Data : Avoid gaps or incorrect readings in historical data Recent Training : Model retrains every 2 hours using full dataset with time-weighted sampling to adapt to changing patterns Understanding MAE (Mean Absolute Error) The model's accuracy is measured using MAE (Mean Absolute Error) , which is the primary metric used for validation and monitoring. What is MAE? MAE measures the average absolute difference between predicted and actual energy consumption values. For example: If the model predicts 0.5 kWh for a 5-minute period and actual consumption is 0.7 kWh, the error is 0.2 kWh MAE is the average of these errors across all predictions How to interpret MAE: MAE is in kWh per 5-minute step - this is the average prediction error for each 5-minute interval Lower is better - an MAE of 0.3 kWh means predictions are typically off by \u00b10.3 kWh per 5-minute period Scale matters - a 0.3 kWh error means different things for different households: Low consumption home (2 kW average): 0.3 kWh per 5-min \u2248 3.6 kW error \u2192 significant High consumption home (8 kW average): 0.3 kWh per 5-min \u2248 3.6 kW error \u2192 moderate Practical example: If your validation MAE is 0.4 kWh per 5-min step: Each 5-minute prediction is off by an average of 0.4 kWh (\u00b124 Wh/min) This translates to roughly \u00b14.8 kW average power error Over 1 hour (12 steps), cumulative error averages out but could be up to \u00b14.8 kWh The model learns patterns, so errors tend to cancel out over longer periods Why MAE is used: Easy to interpret : Errors are in the same units as predictions (kWh) Robust to outliers : Unlike squared errors, large mistakes don't dominate the metric Practical measure : Directly relates to how much your battery plan might be affected Expected Accuracy Typical validation MAE values: Excellent : < 0.3 kWh per 5-min step (~ 3.6 kW average) Good : 0.3 - 0.5 kWh per 5-min step Fair : 0.5 - 1.0 kWh per 5-min step Poor : > 1.0 kWh per 5-min step (may indicate issues) If validation MAE exceeds the threshold (default 2.0 kWh), predictions are disabled and the model will attempt to retrain. Monitoring and Troubleshooting Charts The Predbat WebUI has two charts associated with LoadML: The LoadML chart shows the correlation between your actual load and the predictions by charting this against the prediction 1 hour in the future and 8 hours in the future. The LoadMLPower chart shows a similar view as power, but also plots PV production, predicted PV production and temperature predictions. Check Model Status View model status in Predbat logs: ML Component: Model status: active, last trained: 2024-02-07 10:30:00 ML Component: Validation MAE: 0.3245 kWh Tracking Normalization Drift Each time the model trains (initial fit) or fine-tunes (EMA update), it logs a normalization stats line that summarises the mean and standard deviation for each input feature group. You can search for Normalization stats in the logfile for this information. Large shifts in mean or std for a group (e.g. import_rate after a tariff change, or load after a new appliance) will be visible here and confirm the EMA is tracking the drift correctly. Common Issues Issue : Model never trains Cause : Insufficient historical data Solution : Wait until you have at least 1 day of data, preferably 7+ days Issue : Validation MAE too high (predictions disabled) Cause : Inconsistent load patterns, poor data quality, or insufficient training data Solution : Ensure historical data is accurate Add temperature data if not already enabled Wait for more historical data to accumulate Check for gaps or anomalies in historical data Issue : Model becomes stale Cause : No training for 48+ hours Solution : Check logs for training failures, ensure Predbat is running continuously Issue : Predictions seem inaccurate Cause : Changing household patterns, insufficient features, or missing temperature data Solution : Enable temperature predictions for better accuracy Wait for fine-tuning to adapt to new patterns Verify historical data quality Consider adding PV data if you have solar panels Viewing Predictions Access predictions via: Web Interface : Navigate to the battery plan view to see ML predictions Home Assistant : Check sensor.predbat_load_ml_forecast and its results attribute Logs : Look for \"ML Predictor: Generated predictions\" messages Model Persistence The trained model is saved to disk as predbat_ml_model.npz in your Predbat config directory. This file contains: Network weights and biases : All 4 hidden layers plus output layer Optimizer state : Adam momentum terms for continuing fine-tuning Normalization parameters : Feature and target mean/standard deviation (updated via EMA each fine-tune cycle to track distribution drift) Training metadata : Epochs trained, timestamp, model version, architecture details The model is automatically loaded on Predbat restart, allowing predictions to continue immediately without retraining. The EMA-updated normalization parameters are saved and restored with the model, so drift tracking is preserved across restarts. Note : If you update Predbat and the model architecture or version changes, the old model will be rejected and a new model will be trained from scratch. If the model becomes unstable, you can manually delete predbat_ml_model.npz to force retraining. See Also Components Documentation - Overview of all Predbat components Configuration Guide - General configuration guidance Temperature Component - Setup guide for temperature forecasts Customisation Guide - Advanced customisation options","title":"ML Load Prediction"},{"location":"load-ml/#ml-load-prediction","text":"Predbat includes a neural network-based machine learning component that can predict your household energy consumption for the next 48 hours. This prediction is based on historical load patterns, time-of-day patterns, day-of-week patterns, and optionally PV generation history and temperature forecasts.","title":"ML Load Prediction"},{"location":"load-ml/#table-of-contents","text":"Overview How the Neural Network Works Configuration Setup Instructions Understanding the Model Monitoring and Troubleshooting Model Persistence","title":"Table of Contents"},{"location":"load-ml/#overview","text":"The ML Load Prediction component uses a lightweight multi-layer perceptron (MLP) neural network implemented in pure NumPy. It learns from your historical energy consumption patterns and makes predictions about future load. Key Features: Predicts 48 hours of load data in 5-minute intervals Learns daily and weekly patterns automatically Supports historical PV generation data as an input feature Supports temperature forecast data for improved accuracy Uses historical and future energy import/export rates as input features Deep neural network with 4 hidden layers [512, 256, 128, 64 neurons] Optimized with He initialization and AdamW weight decay for robust training Automatically trains on historical data (requires at least 1 day, recommended 7+ days, up to 28 days configurable) Fine-tunes periodically (every 2 hours) using full dataset to adapt to changing patterns Time-weighted training prioritizes recent data while learning from historical patterns Model persists across restarts Falls back gracefully if predictions are unreliable","title":"Overview"},{"location":"load-ml/#how-the-neural-network-works","text":"","title":"How the Neural Network Works"},{"location":"load-ml/#architecture","text":"The ML Load Predictor uses a deep multi-layer perceptron (MLP) with the following architecture: Input Layer : 1444 features (288 load + 288 PV + 288 temperature + 288 import rates + 288 export rates + 4 time features) Hidden Layers : 4 layers with [512, 256, 128, 64] neurons using ReLU activation Output Layer : 1 neuron (predicts next 5-minute step) Total Parameters : ~500,000 trainable weights Optimization Techniques: He Initialization : Weights initialized using He/Kaiming method ( std = sqrt(2/fan_in) ), optimized for ReLU activations AdamW Optimizer : Adam optimization with weight decay (L2 regularization, default 0.01) to prevent overfitting Early Stopping : Training halts if validation error stops improving (patience=5 epochs) Weighted Samples : Recent data weighted more heavily (exponential decay over history period)","title":"Architecture"},{"location":"load-ml/#input-features","text":"The neural network uses several types of input features to make predictions: Historical Load Lookback - Past 24 hours of energy consumption at 5-minute intervals - Helps the network understand recent usage patterns Historical PV Generation - Past 24 hours of solar PV generation at 5-minute intervals - Helps correlate solar production with consumption patterns - Requires pv_today sensor to be configured Historical Temperature - Past 24 hours of temperature data at 5-minute intervals - Helps correlate temperature with energy usage (heating/cooling) - Requires the Temperature component to be enabled Historical Import/Export Energy Rates (288 + 288 features) - Past 24 hours of electricity import rates at 5-minute intervals - Past 24 hours of electricity export rates at 5-minute intervals - Helps the model learn consumption patterns based on time-of-use pricing - Automatically extracted from your configured Octopus Energy tariffs or other rate sources - Particularly useful for homes that shift usage to cheaper rate periods Cyclical Time Features (4 features) - Sin/Cos encoding of minute-of-day (captures daily patterns with 5-min precision) - Sin/Cos encoding of day-of-week (captures weekly patterns) - These features help the network understand that 23:55 is close to 00:05","title":"Input Features"},{"location":"load-ml/#prediction-process","text":"The model uses an autoregressive approach: Takes the last 24 hours of historical data Predicts the next 5-minute step Adds that prediction to the history window Shifts the window forward and repeats Continues for 576 steps to cover 48 hours To prevent drift in long-range predictions, the model blends autoregressive predictions with historical daily patterns.","title":"Prediction Process"},{"location":"load-ml/#training-process","text":"Initial Training: Requires at least 1 day of historical data (7+ days recommended, up to 28 days configurable) Fetches up to 28 days of load history by default (configurable via load_ml_max_days_history ) Uses 100 epochs with early stopping (patience=5) Batch size: 128 samples AdamW optimizer with learning rate 0.001 and weight decay 0.01 Sample weighting: exponential time decay (recent data weighted more) Validates on the last 24 hours of data Saves model to disk: predbat_ml_model.npz Regularization: Weight Decay : L2 penalty (0.01) applied to network weights to prevent overfitting Early Stopping : Training halts if validation error doesn't improve for 5 consecutive epochs, selecting the best results so far. Time-Weighted Samples : Recent data has higher importance (7-day exponential decay constant) Today's data: 100% weight N days old: 37% weight (e^-1) Fine-tuning: Runs every 2 hours if enabled Uses full available dataset (same as initial training, up to 28 days) Uses 3 epochs to quickly adapt to recent changes Applies same time-weighted sampling to prioritize recent data Preserves learned patterns while adapting to new ones Same regularization techniques applied as initial training Each fine-tune cycle blends the current data's feature statistics (mean/std) with the stored normalization parameters via an exponential moving average (alpha=0.1). This lets the model slowly track long-term shifts in feature distributions (e.g. seasonal load changes, new tariff rates) without sudden jumps that could destabilise existing weights. Why Full Dataset for Fine-tuning? Although fine-tuning uses up to 20 epochs (vs 100 for initial training), it still uses the full dataset with time-weighted sampling. This approach: Prevents catastrophic forgetting : Using only recent data would cause the model to gradually forget older patterns Balances adaptation : Time weighting ensures recent changes are prioritized while maintaining long-term pattern knowledge Handles seasonal patterns : 28 days of history helps capture weekly cycles and early seasonal trends Provides stability : The model learns from a broader context, making predictions more robust With time-weighted sampling, training samples have these relative weights: This week : 100% - 50% (fully weighted) Last week : 50% - 20% (moderately weighted) 2 weeks ago : 20% - 7% (lightly weighted) 3-4 weeks ago : 7% - 1% (minimal weight, but still contributing to pattern learning) This allows the model to adapt quickly to recent changes (via time weighting) without losing the benefit of learning from historical patterns. Model Validation: Model is validated after each training session If validation error exceeds threshold (default 2.0 kWh MAE), predictions are disabled Model is considered stale after 48 hours and requires retraining","title":"Training Process"},{"location":"load-ml/#configuration","text":"","title":"Configuration"},{"location":"load-ml/#basic-setup","text":"To enable ML load prediction, add to your apps.yaml : predbat: module: predbat class: PredBat # Enable ML load prediction load_ml_enable: True # Use the output data in Predbat (can be False to explore the use without using the data) load_ml_source: True # Optional: Maximum days of historical data to use for training (default: 28) # load_ml_max_days_history: 28 Configuration Parameter Details: load_ml_enable : Enables the ML component (required) load_ml_source : When true , Predbat uses ML predictions for battery planning. Set to false to test predictions without affecting battery control load_ml_max_days_history : Maximum days of historical data to fetch and train on Default : 28 days Minimum : 1 day (not recommended for production) Recommended : 7-28 days depending on your consumption patterns When to increase : If you have very regular weekly patterns or want seasonal awareness When to decrease : If your consumption patterns change frequently, or you have limited historical data storage Note : Training time increases slightly with more data, but fine-tuning remains fast (3 epochs) For best results: Ensure you have a least a weeks worth of data before enabling load_ml_source. Make sure you do not have PredAI enabled at the same time Disable in day adjustment (switch.predbat_calculate_inday_adjustment) as the AI model will do that for you.","title":"Basic Setup"},{"location":"load-ml/#recommended-enable-temperature-predictions","text":"For best results, enable the Temperature component to provide temperature forecasts: predbat: # ... other config ... # Enable temperature predictions (RECOMMENDED for ML load prediction) temperature_enable: true # Optional: specify coordinates (defaults to zone.home) # temperature_latitude: 51.5074 # temperature_longitude: -0.1278 The temperature data significantly improves prediction accuracy for homes with heating/cooling systems, as energy consumption is often correlated with outside temperature.","title":"Recommended: Enable Temperature Predictions"},{"location":"load-ml/#optional-add-pv-generation-data","text":"Your PV data will be picked from the pv_today setting in Predbat already predbat: # ... other config ... pv_today: - sensor.my_solar_generation_today","title":"Optional: Add PV Generation Data"},{"location":"load-ml/#optional-subtract-car-charging","text":"If you have an EV charger set in Predbat then this will be subtracted from predictions. If this is not set then the default EV charging threshold is used if car_charging_hold is True. predbat: # ... other config ... # Optional: subtract car charging from load history car_charging_energy: - sensor.my_ev_charger_energy","title":"Optional: Subtract Car Charging"},{"location":"load-ml/#setup-instructions","text":"","title":"Setup Instructions"},{"location":"load-ml/#step-1-verify-prerequisites","text":"Before enabling ML load prediction: Ensure you have a load_today sensor that tracks cumulative daily energy consumption Optionally configure pv_today if you have solar panels Recommended : Enable the Temperature component (Temperature Component in components documentation) Ensure you have at least 1 day of historical data (7+ days recommended, up to 28 days by default)","title":"Step 1: Verify Prerequisites"},{"location":"load-ml/#step-2-enable-the-component","text":"Add load_ml_enable: true to your apps.yaml and restart Predbat.","title":"Step 2: Enable the Component"},{"location":"load-ml/#step-3-wait-for-initial-training","text":"On first run, the component will: Fetch historical load data (default: up to 28 days, configurable) Train the neural network (takes 1-5 minutes depending on data) Validate the model Begin making predictions if validation passes Check the Predbat logs for training progress: ML Component: Starting initial training ML Predictor: Starting initial training with 100 epochs ML Predictor: Training complete, final val_mae=0.3245 kWh ML Component: Initial training completed, validation MAE=0.3245 kWh","title":"Step 3: Wait for Initial Training"},{"location":"load-ml/#step-4-monitor-predictions","text":"Once trained, the component publishes predictions to: sensor.predbat_load_ml_forecast - Contains 48-hour prediction in results attribute You can visualize these predictions in the Predbat web interface or by creating charts in Home Assistant.","title":"Step 4: Monitor Predictions"},{"location":"load-ml/#understanding-the-model","text":"","title":"Understanding the Model"},{"location":"load-ml/#model-status","text":"The ML component tracks several status indicators: Model Status : not_initialized , training , active , validation_failed , stale Validation MAE : Mean Absolute Error on validation data (see Understanding MAE for details) Model Age : How long since the model was last trained You can check model status in the Predbat logs or via the component status page in the web interface.","title":"Model Status"},{"location":"load-ml/#what-makes-good-predictions","text":"Good predictions require: Sufficient Historical Data : At least 7 days recommended for stable patterns (supports up to 28 days by default) Consistent Patterns : Regular daily/weekly routines improve accuracy Temperature Data : Especially important for homes with electric heating/cooling (requires Temperature component) Energy Rate Data : Automatically included - helps model learn consumption patterns based on time-of-use tariffs PV Generation Data : If you have solar panels, include pv_today sensor for better correlation Clean Data : Avoid gaps or incorrect readings in historical data Recent Training : Model retrains every 2 hours using full dataset with time-weighted sampling to adapt to changing patterns","title":"What Makes Good Predictions?"},{"location":"load-ml/#understanding-mae-mean-absolute-error","text":"The model's accuracy is measured using MAE (Mean Absolute Error) , which is the primary metric used for validation and monitoring. What is MAE? MAE measures the average absolute difference between predicted and actual energy consumption values. For example: If the model predicts 0.5 kWh for a 5-minute period and actual consumption is 0.7 kWh, the error is 0.2 kWh MAE is the average of these errors across all predictions How to interpret MAE: MAE is in kWh per 5-minute step - this is the average prediction error for each 5-minute interval Lower is better - an MAE of 0.3 kWh means predictions are typically off by \u00b10.3 kWh per 5-minute period Scale matters - a 0.3 kWh error means different things for different households: Low consumption home (2 kW average): 0.3 kWh per 5-min \u2248 3.6 kW error \u2192 significant High consumption home (8 kW average): 0.3 kWh per 5-min \u2248 3.6 kW error \u2192 moderate Practical example: If your validation MAE is 0.4 kWh per 5-min step: Each 5-minute prediction is off by an average of 0.4 kWh (\u00b124 Wh/min) This translates to roughly \u00b14.8 kW average power error Over 1 hour (12 steps), cumulative error averages out but could be up to \u00b14.8 kWh The model learns patterns, so errors tend to cancel out over longer periods Why MAE is used: Easy to interpret : Errors are in the same units as predictions (kWh) Robust to outliers : Unlike squared errors, large mistakes don't dominate the metric Practical measure : Directly relates to how much your battery plan might be affected","title":"Understanding MAE (Mean Absolute Error)"},{"location":"load-ml/#expected-accuracy","text":"Typical validation MAE values: Excellent : < 0.3 kWh per 5-min step (~ 3.6 kW average) Good : 0.3 - 0.5 kWh per 5-min step Fair : 0.5 - 1.0 kWh per 5-min step Poor : > 1.0 kWh per 5-min step (may indicate issues) If validation MAE exceeds the threshold (default 2.0 kWh), predictions are disabled and the model will attempt to retrain.","title":"Expected Accuracy"},{"location":"load-ml/#monitoring-and-troubleshooting","text":"","title":"Monitoring and Troubleshooting"},{"location":"load-ml/#charts","text":"The Predbat WebUI has two charts associated with LoadML: The LoadML chart shows the correlation between your actual load and the predictions by charting this against the prediction 1 hour in the future and 8 hours in the future. The LoadMLPower chart shows a similar view as power, but also plots PV production, predicted PV production and temperature predictions.","title":"Charts"},{"location":"load-ml/#check-model-status","text":"View model status in Predbat logs: ML Component: Model status: active, last trained: 2024-02-07 10:30:00 ML Component: Validation MAE: 0.3245 kWh","title":"Check Model Status"},{"location":"load-ml/#tracking-normalization-drift","text":"Each time the model trains (initial fit) or fine-tunes (EMA update), it logs a normalization stats line that summarises the mean and standard deviation for each input feature group. You can search for Normalization stats in the logfile for this information. Large shifts in mean or std for a group (e.g. import_rate after a tariff change, or load after a new appliance) will be visible here and confirm the EMA is tracking the drift correctly.","title":"Tracking Normalization Drift"},{"location":"load-ml/#common-issues","text":"Issue : Model never trains Cause : Insufficient historical data Solution : Wait until you have at least 1 day of data, preferably 7+ days Issue : Validation MAE too high (predictions disabled) Cause : Inconsistent load patterns, poor data quality, or insufficient training data Solution : Ensure historical data is accurate Add temperature data if not already enabled Wait for more historical data to accumulate Check for gaps or anomalies in historical data Issue : Model becomes stale Cause : No training for 48+ hours Solution : Check logs for training failures, ensure Predbat is running continuously Issue : Predictions seem inaccurate Cause : Changing household patterns, insufficient features, or missing temperature data Solution : Enable temperature predictions for better accuracy Wait for fine-tuning to adapt to new patterns Verify historical data quality Consider adding PV data if you have solar panels","title":"Common Issues"},{"location":"load-ml/#viewing-predictions","text":"Access predictions via: Web Interface : Navigate to the battery plan view to see ML predictions Home Assistant : Check sensor.predbat_load_ml_forecast and its results attribute Logs : Look for \"ML Predictor: Generated predictions\" messages","title":"Viewing Predictions"},{"location":"load-ml/#model-persistence","text":"The trained model is saved to disk as predbat_ml_model.npz in your Predbat config directory. This file contains: Network weights and biases : All 4 hidden layers plus output layer Optimizer state : Adam momentum terms for continuing fine-tuning Normalization parameters : Feature and target mean/standard deviation (updated via EMA each fine-tune cycle to track distribution drift) Training metadata : Epochs trained, timestamp, model version, architecture details The model is automatically loaded on Predbat restart, allowing predictions to continue immediately without retraining. The EMA-updated normalization parameters are saved and restored with the model, so drift tracking is preserved across restarts. Note : If you update Predbat and the model architecture or version changes, the old model will be rejected and a new model will be trained from scratch. If the model becomes unstable, you can manually delete predbat_ml_model.npz to force retraining.","title":"Model Persistence"},{"location":"load-ml/#see-also","text":"Components Documentation - Overview of all Predbat components Configuration Guide - General configuration guidance Temperature Component - Setup guide for temperature forecasts Customisation Guide - Advanced customisation options","title":"See Also"},{"location":"manual-api/","text":"Manual API CAUTION This is an expert feature only, you can break Predbat if you set the wrong things here. While for most people Predbat will do what you want without any adjustments there are some special cases where users wish to write some more complex automations which override Predbat settings. For settings inside Home Assistant e.g. switch.predbat_ , select.predbat_ and input_number.predbat_* you can already use an automation to change these values. For settings in apps.yaml it's very difficult or impossible to update them via an automation. For this reason, there is a selector called select.predbat_manual_api which works a bit like the manual override ones but this can have new values added using the select API in Home Assistant. The only function the selector itself serves is to store override commands, you can clear from the selector but you have to set them using a service call. Certain settings in apps.yaml may be overridden using this method. Each override is in a string format and works a bit like a web URL, setting the command and the values. Data retention The data for overrides is kept inside the Home Assistant selector itself and so will survive a reboot. There is likely a limit to the size of this data so be sure to remove old overrides when you are done with them. Keep in mind it's easy to lose all of the overrides with the 'off' option so do not keep important data here only use it for short-term automations. Supported command formats The supported formats are: off <command>=<value> <command>(index)=<value> <command>?<name>=<value> <command>(index)?<name>=<value> <command>?<name>=<value>&<name2>=<value2> <command>(index)?<name>=<value>&<name2>=<value2> Commands are disabled again by putting them in square brackets e.g: [<command>?<name>=<value>&<name2>=<value2>] ```` Below is an example of setting a rate override, you can clear all overrides by calling 'off' or this specific one only by calling the same thing again but in square brackets [] For the rates you can use **rates_export_override** or **rates_import_override** with all the [same rate override options as apps.yaml](energy-rates.md#manually-over-riding-energy-rates), but in a URL type format: ```text rates_export_override?start=17:00:00&end=19:00:00&rate=0 See below for an [example of using the API to over-ride predicted house load] If you override a single value item in a list with something like: inverter_limit(0)=4000 To disable this override again: [inverter_limit(0)=4000] If you omit the index then all entries in the list will be overridden. To disable all overrides off Supported overrides The following apps.yaml settings can be overridden using predbat_manual_api: rates_export_override rates_import_override inverter_limit export_limit days_previous days_previous_weight inverter_battery_rate_min inverter_reserve_max battery_rate_max car_charging_soc car_charging_limit car_charging_battery_size battery_scaling forecast_hours import_export_scaling inverter_limit_charge inverter_limit_discharge Example solution to over-ride predicted house load Prior to the addition of select.predbat_manual_load_adjust a common feedback was that there was no mechanism in Predbat to alter the predicted house load, for example ignoring the effects of extra washing load in the past, or to take account of planned extra load such as cooking a big Sunday dinner. The Predbat manual API provides a mechanism to meet this need by setting an export (or import) rates override. Now that you can use the manual load adjust selector to overwrite predicted load this example solution is retained as a worked example of how you can use the manual API to overwrite apps.yaml settings. Control variables Create a date/time helper called predbat_override_date of type date, another called predbat_override_start_time of type time, and a third called predbat_override_end_time also of type time. Create an input number helper called predbat_override_load_percent. I made it an input field and with a maximum value of 5. These will hold the date, start time, end time and load adjustment percentage. Create an automation script to send the event details to Predbat: alias: Send Load Adjustment details to Predbat manual API sequence: - action: select.select_option data: option: >- rates_export_override?date={{ states('input_datetime.predbat_override_date')| as_timestamp | timestamp_custom('%Y-%m-%d') }}&start={{ states('input_datetime.predbat_override_start_time') }}&end={{ states('input_datetime.predbat_override_end_time') }}&load_scaling={{ states('input_number.predbat_override_load_percent')|float }} target: entity_id: select.predbat_manual_api mode: single description: \"\" The script collects the above input variables, and sends these to Predbat as an export rate override. Dashboard: On an existing Home Assistant dashboard, or on a new one, create a control of type 'entities' and paste the following in: type: entities entities: - entity: input_datetime.predbat_override_session_date - entity: input_datetime.predbat_override_start_time - entity: input_datetime.predbat_override_end_time - entity: input_number.predbat_override_load_percent - type: button name: Send Load Adjustment details to Predbat icon: mdi:script-text-play-outline action_name: Execute tap_action: action: perform-action perform_action: script.send_load_adjustment_details_to_predbat_manual_api You simply enter the date, start time, end time and load percentage adjustment (e.g. 0.5=50%), then click the 'Execute' button. The load adjustment details will be sent to the Predbat manual API and you will see the load change and a small +/- symbol against the export rate in the Predbat plan.","title":"Manual API"},{"location":"manual-api/#manual-api","text":"CAUTION This is an expert feature only, you can break Predbat if you set the wrong things here. While for most people Predbat will do what you want without any adjustments there are some special cases where users wish to write some more complex automations which override Predbat settings. For settings inside Home Assistant e.g. switch.predbat_ , select.predbat_ and input_number.predbat_* you can already use an automation to change these values. For settings in apps.yaml it's very difficult or impossible to update them via an automation. For this reason, there is a selector called select.predbat_manual_api which works a bit like the manual override ones but this can have new values added using the select API in Home Assistant. The only function the selector itself serves is to store override commands, you can clear from the selector but you have to set them using a service call. Certain settings in apps.yaml may be overridden using this method. Each override is in a string format and works a bit like a web URL, setting the command and the values.","title":"Manual API"},{"location":"manual-api/#data-retention","text":"The data for overrides is kept inside the Home Assistant selector itself and so will survive a reboot. There is likely a limit to the size of this data so be sure to remove old overrides when you are done with them. Keep in mind it's easy to lose all of the overrides with the 'off' option so do not keep important data here only use it for short-term automations.","title":"Data retention"},{"location":"manual-api/#supported-command-formats","text":"The supported formats are: off <command>=<value> <command>(index)=<value> <command>?<name>=<value> <command>(index)?<name>=<value> <command>?<name>=<value>&<name2>=<value2> <command>(index)?<name>=<value>&<name2>=<value2> Commands are disabled again by putting them in square brackets e.g: [<command>?<name>=<value>&<name2>=<value2>] ```` Below is an example of setting a rate override, you can clear all overrides by calling 'off' or this specific one only by calling the same thing again but in square brackets [] For the rates you can use **rates_export_override** or **rates_import_override** with all the [same rate override options as apps.yaml](energy-rates.md#manually-over-riding-energy-rates), but in a URL type format: ```text rates_export_override?start=17:00:00&end=19:00:00&rate=0 See below for an [example of using the API to over-ride predicted house load] If you override a single value item in a list with something like: inverter_limit(0)=4000 To disable this override again: [inverter_limit(0)=4000] If you omit the index then all entries in the list will be overridden. To disable all overrides off","title":"Supported command formats"},{"location":"manual-api/#supported-overrides","text":"The following apps.yaml settings can be overridden using predbat_manual_api: rates_export_override rates_import_override inverter_limit export_limit days_previous days_previous_weight inverter_battery_rate_min inverter_reserve_max battery_rate_max car_charging_soc car_charging_limit car_charging_battery_size battery_scaling forecast_hours import_export_scaling inverter_limit_charge inverter_limit_discharge","title":"Supported overrides"},{"location":"manual-api/#example-solution-to-over-ride-predicted-house-load","text":"Prior to the addition of select.predbat_manual_load_adjust a common feedback was that there was no mechanism in Predbat to alter the predicted house load, for example ignoring the effects of extra washing load in the past, or to take account of planned extra load such as cooking a big Sunday dinner. The Predbat manual API provides a mechanism to meet this need by setting an export (or import) rates override. Now that you can use the manual load adjust selector to overwrite predicted load this example solution is retained as a worked example of how you can use the manual API to overwrite apps.yaml settings. Control variables Create a date/time helper called predbat_override_date of type date, another called predbat_override_start_time of type time, and a third called predbat_override_end_time also of type time. Create an input number helper called predbat_override_load_percent. I made it an input field and with a maximum value of 5. These will hold the date, start time, end time and load adjustment percentage. Create an automation script to send the event details to Predbat: alias: Send Load Adjustment details to Predbat manual API sequence: - action: select.select_option data: option: >- rates_export_override?date={{ states('input_datetime.predbat_override_date')| as_timestamp | timestamp_custom('%Y-%m-%d') }}&start={{ states('input_datetime.predbat_override_start_time') }}&end={{ states('input_datetime.predbat_override_end_time') }}&load_scaling={{ states('input_number.predbat_override_load_percent')|float }} target: entity_id: select.predbat_manual_api mode: single description: \"\" The script collects the above input variables, and sends these to Predbat as an export rate override. Dashboard: On an existing Home Assistant dashboard, or on a new one, create a control of type 'entities' and paste the following in: type: entities entities: - entity: input_datetime.predbat_override_session_date - entity: input_datetime.predbat_override_start_time - entity: input_datetime.predbat_override_end_time - entity: input_number.predbat_override_load_percent - type: button name: Send Load Adjustment details to Predbat icon: mdi:script-text-play-outline action_name: Execute tap_action: action: perform-action perform_action: script.send_load_adjustment_details_to_predbat_manual_api You simply enter the date, start time, end time and load percentage adjustment (e.g. 0.5=50%), then click the 'Execute' button. The load adjustment details will be sent to the Predbat manual API and you will see the load change and a small +/- symbol against the export rate in the Predbat plan.","title":"Example solution to over-ride predicted house load"},{"location":"output-data/","text":"Output data Each time Predbat runs it outputs a lot of information about the current performance of your solar/battery system and the predicted load, PV, cost, CO2, car charging, etc. This section of the documentation explains the different output and logging data that Predbat produces and gives an overview of how to display that information within Home Assistant. There can never be a single Predbat dashboard that suits every user, so instead Predbat gives a starter set of displays that can be adapted to your individual needs. Web interface The Predbat Web Interface provides an easy to use way to see and change different aspects of your Predbat system including view the current plan, adjust the configuration, view the charts, check your apps.yaml and view the logfiles. Displaying output data Each Predbat configuration item is named input_number.predbat_xxx , switch.predbat_yyy or select.predbat_zzz depending on the control type. Creating a simple Predbat dashboard Each time Predbat runs it auto-generates a dashboard with the filename predbat_dashboard.yaml that can be used as a starter for your own Predbat dashboard. Depending on how you installed Predbat this predbat_dashboard.yaml file will be held in one of three different directories in Home Assistant: if you have used the Predbat app installation method , it will be in the directory /addon_configs/6adb4f0d_predbat/ , or, with the deprecated HACS, Appdaemon app then Predbat installation method , it's /config/appdaemon/apps/batpred/config/ . You will need to use a file editor within Home Assistant (e.g. either the File editor or Studio Code Server apps) to open the predbat_dashboard.yaml file - see editing configuration files within Home Assistant if you need to install an editor. Once opened, select and copy all the contents of the predbat_dashboard.yaml file and add the contents to a new dashboard page: Go to Settings/Dashboards, double click an existing dashboard name or 'Add Dashboard'/'New dashboard from scratch'/enter a name/click Create, then double click the newly created dashboard Click the pencil icon in the top right corner, click the lower dashed box (Create section), click the solid blue boxed plus symbol to 'Add card', scroll down the list of cards to the bottom and click 'Manual', delete all the template card configuration and paste the contents of the predbat_dashboard.yaml file copied earlier, then 'Save' and 'Done' in the top right. This will give you a simple Predbat control and output dashboard that you can then resequence and customise as you wish. Creating a compact Predbat control dashboard You can also create a dashboard page that's dynamically generated to automatically include all the Predbat control and output entities, so when new entities are added in future Predbat releases, you don't have to edit the dashboard. Firstly you need to install HACS if it isn't already installed, and then install two HACS front-end components: Auto Entities ( https://github.com/thomasloven/lovelace-auto-entities ) automatically generates a list of entities that match a wildcard expression Lovelace Collapsable Cards ( https://github.com/RossMcMillan92/lovelace-collapsable-cards ) wraps the entity lists within a drop-down toggle Installation steps: Click the HACS icon on the left-hand side panel Click the three dots in the top right corner then 'Custom Repositories' Paste (or type) in the following repository name https://github.com/RossMcMillan92/lovelace-collapsable-cards , choose Type 'Dashboard', and click Add Close the Custom Repositories dialogue Click 'Explore & Download Repositories' Search for 'collapsable cards', click the name of it, check it's the right one, click 'Download', 'Download' again, then 'Reload' Click 'Explore & Download Repositories' again, search for 'auto-entities', then 'Download', 'Download', 'Reload' Now create the dynamic dashboard: Go to Settings/Dashboards, double click an existing dashboard or 'Add Dashboard'/'New dashboard from scratch'/enter a name/click Create, then double click click the new dashboard Click the pencil icon in the top right corner, then the plus symbol on the far right of the next row to create a new View Enter a title of the View, then Save Click the pencil icon in the top right corner, click the lower dashed box (Create section), click the solid blue boxed plus symbol to 'Add card', scroll down the list of cards to the bottom and click 'Manual', delete all the template card configuration and copy/paste the following YAML into the dashboard and click 'Save': type: vertical-stack title: Predbat \ud83e\udd87 cards: - type: entities entities: - entity: predbat.status - type: weblink name: Predbat Web Console url: /hassio/ingress/6adb4f0d_predbat - entity: update.predbat_version - entity: select.predbat_update - entity: select.predbat_mode - entity: select.predbat_saverestore - entity: switch.predbat_active - type: custom:collapsable-cards title: \ud83d\udd00 Control defaultOpen: false cards: - type: custom:collapsable-cards title: \ud83d\udd22 Input Variables defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: input_number.predbat* exclude: [] unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: \ud83d\udd00 Switches defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: switch.predbat* exclude: [] unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: \ud83d\udd22 Selectors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: select.predbat* exclude: [] unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: '#\ufe0f\u20e3 Sensors' defaultOpen: false cards: - type: custom:collapsable-cards title: \ud83d\udcb7 Cost Sensors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: predbat.*cost* - entity_id: predbat.*rate* - entity_id: predbat.*metric* exclude: - entity_id: predbat.*start* - entity_id: predbat.*end* - entity_id: predbat.*duration* unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: \ud83d\udcb7 Saving Sensors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: predbat.*saving* exclude: - entity_id: predbat.*start* - entity_id: predbat.*end* - entity_id: predbat.*duration* unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: \ud83d\udd5b Time/Duration Sensors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: predbat.*start* - entity_id: predbat.*end* - entity_id: predbat.*duration* - entity_id: predbat.*record* exclude: [] unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: \u26a1 Power Sensors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: predbat.*soc* - entity_id: predbat.*energy* - entity_id: predbat.*load* - entity_id: predbat.*battery* - entity_id: predbat.*kw* - entity_id: predbat.*power* - entity_id: predbat.*charge* - entity_id: predbat.*iboost* - entity_id: predbat.*grid* - entity_id: sensor.predbat_pv* exclude: - entity_id: predbat.*savings* - entity_id: predbat.*start* - entity_id: predbat.*end* - entity_id: predbat.*duration* - entity_id: predbat.*record* unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: 1\ufe0f\u20e3 Binary Sensors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: binary_sensor.predbat* exclude: [] unique: true sort: method: friendly_name numeric: false This will give you a compact dynamically created list of all Predbat entities which groups the entities by type and is collapsed by default to prevent screen clutter. Credit @DJBenson for the code. Viewing the Predbat plan predbat.plan_html - A sensor that contains an HTML render of the Predbat predicted best plan, detailing import and export rates, predicted house load, solar generation, any solar clipping, battery SoC, car and iBoost charging, and Predbat's planned charging and discharging activities. The plan is contained in the 'html' attribute, and its recommended to Create the Predbat Plan card as an easy way to see the plan that Predbat has created. The sensor also contains the 'text' attribute which gives a HTML formatted brief text description of the Predbat plan, and the 'raw' attribute which repeats the plan data but in raw (unformatted) JSON format. If you are using the Predbat app or docker then the Predbat plan can also be viewed via the 'Plan' view of the Predbat web interface , and the text description via the 'Dash' view . Graphing the Predbat predictions A set of Apex Charts can also be created to see graphically what Predbat plans to do - Creating the charts . Renditions of the key charts can also be seen in the 'Charts' view of the Predbat web interface . Basic status switch.predbat_active - Automatically set by Predbat to On when Predbat is busy calculating or controlling your inverter, or Off when Predbat is waiting for the next time it needs to perform a plan calculation update. If you toggle this switch in Home Assistant it will force Predbat to perform an update now (useful for automations). predbat.status - Gives the current status & errors and logs any changes that Predbat makes to your inverter. The different Predbat status values and their meanings are detailed in what does Predbat do . predbat.status additionally has the following attributes that are automatically populated: Last updated - date and time that Predbat last updated the plan Debug - A set of arrays containing Predbat's planned charging and discharging time windows and battery limits (in kWh) Version - version of Predbat that's running Error - binary value true or false depending upon whether Predbat is in an error status or nor Sensor data Predbat outputs the values it read from your inverters as totals, this gives the current power flow: predbat.load_power - The current house load in Watts predbat.battery_power - The current power of your battery (charging or discharging) in Watts predbat.pv_power - The current power of your PV system in Watts predbat.grid_power - The current grid power flow (import or export) in Watts Baseline data Predbat outputs the following sensors to predict what your battery is expected to do over the forecast_hours duration of the plan with no changes made by Predbat. This is considered to be the 'baseline' plan: NB: All of Predbat's forecasts are from midnight today to the forecast_hours duration (set in apps.yaml) into the future and shouldn't be confused with 'today' figures. e.g. predbat.pv_energy is the actual PV energy from midnight today, and for the predicted forecast_hours (typically 48) ahead so will be much larger than sensor.solcast_pv_forecast_today which is today's Solcast PV forecast. predbat.battery_cycle - Predicted baseline battery cycle in kWh (total kWh processed) with attributes of the prediction every 5 minutes to the end of the plan predbat.battery_hours_left - The number of hours left until your home battery is predicted to run out under the baseline plan (stops at the maximum prediction time) predbat.car_soc - The expected charge level of your car at the end of the baseline plan. Can also be charted predbat.charge_end - Predicted end time of the next forced battery charging under the baseline plan predbat.charge_limit - Predicted baseline battery charge limit for the next charge in percent with attributes of all future battery charging times & limits predbat.charge_limit_kw - Predicted baseline battery charge limit for the next charge in kWh with attributes of future charging times & limits predbat.charge_start - Predicted start time of the next forced battery charging under the baseline plan predbat.duration - The duration of the prediction maximum in hours predbat.export_energy - Total kWh of predicted exports under the baseline plan with attributes of the predicted export kWh and their time slots in kW per 5-minute slots to the end of the baseline plan for charting predbat.import_energy - Total kWh of predicted imports under baseline plan with attributes of the predicted import kWh and their time slots predbat.import_energy_battery - Total kWh of predicted import energy used to charge the home battery under the baseline plan predbat.import_energy_house - Predicted import energy used by the home under the baseline plan that is not provided by your home battery (e.g. due to a flat battery or load above the maximum discharge rate) predbat.load_energy - Total kWh of predicted house load under the baseline plan with attributes of the predicted load kWh in 5-minute slots to the end of the plan with attributes of the average instantaneous house load power in kW in 5-minute slots to the end of the plan predbat.metric - Total predicted cost for the baseline plan, taking account of predicted solar generation, house load, import and export rates. Attributes contain data for charting the cost prediction in 5-minute slots to the end of the plan predbat.pv_energy - Predicted PV energy in kWh under the baseline plan with attributes of the predicted PV generation in kWh with time slots predbat.soc_kw - Predicted state of charge (in kWh) at the end of the baseline plan prediction, not very useful in itself, but the attributes hold prediction data in 5-minute intervals which can be charted with Apex Charts (or similar) predbat.soc_min_kwh - Predicted lowest battery SoC value in kWh under the baseline plan with attribute of the date/time that that lowest SoC occurs at PV 10% Baseline data Predbat outputs the following baseline results under the PV 10% scenario for the forecast_hours duration of the plan, these are known as the 'base10' predictions: predbat.base10_export_energy- Total predicted export energy in kWh for the PV 10% scenario, with attributes of the predicted export kWh and their time slots predbat.base10_import_energy- Total predicted import energy in kWh for the PV 10% scenario, with attributes of the predicted import kWh and their time slots predbat.base10_load_energy - Total predicted house load in kWh for the PV 10% scenario predbat.base10_metric - Total predicted cost for the PV 10% scenario, with attributes of the cost prediction in 5-minute slots to the end of the plan for charting predbat.base10_pv_energy - Predicted PV 10% energy in kWh with attributes of the predicted PV generation in kWh with time slots predbat.soc_kw_base10 - Predicted final state of charge (in kWh) of the battery, with attributes of the predicted SoC in 5-minute time slots to the end of the plan under the PV 10% scenario, for charting Best Prediction data Predbat outputs the following 'best' entities from the forecast (for the forecast_hours duration) based on the lowest cost consumption plan. The 'best' plan in Predbat parlance is simply Predbat's lowest cost predicted plan: predbat.battery_cycle_best - Predicted best battery cycle in kWh (total kWh processed) with attributes of the prediction in 5-minute slots. predbat.battery_power_best - Sensor gives the current battery power in watts, attributes give the future prediction of battery power in 5-minute slots predbat.best_battery_hours_left - Predicted total number of hours of battery capacity left under the best plan predbat.best_charge_end - Predicted end time of the next forced battery charging under the best plan predbat.best_charge_limit - Predicted best battery charge limit for the next charge in percent with attributes of all future battery charging times & limits predbat.best_charge_limit_kw - Predicted best battery charge limit for the next charge in kWh with attributes of future charging times & limits predbat.best_charge_start - Predicted start time of the next forced battery charging under the best plan predbat.best_export_end - Predicted end time of the next forced battery export under the best plan predbat.best_export_limit - Predicted best battery export limit in percent (will be 0% when discharging or 100% when not) with attributes of all future battery exports (kWh and time slots) predbat.best_export_limit_kw - Predicted best battery export limit in kWh predbat.best_export_start - Predicted start time of the next forced battery export under the best plan predbat.best_export_energy - Total kWh of predicted exports under the best plan, with attributes of the predicted export kWh and their time slots predbat.best_import_energy - Total kWh of predicted imports under the best plan, with attributes of the predicted import kWh and their time slots predbat.best_import_energy_battery - Total kWh of predicted import energy to charge the home battery under the best plan predbat.best_import_energy_house - Total kWh of predicted import energy used directly by the house under the best plan (e.g. due to a flat battery or the house load is greater than the max discharge rate) predbat.best_load_energy - Total kWh of predicted house load energy in kWh under the best plan with attributes of the predicted load kWh in 5 minute slots to the end of the plan predbat.best_metric - Total predicted cost for the best plan, taking account of predicted solar generation, house load, import and export rates. Attributes contain data for charting the cost prediction in 5-minute slots to the end of the plan predbat.best_pv_energy - Predicted PV energy in kWh under the best plan with attributes of the predicted PV generation in kWh with time slots predbat.best_soc_min_kwh - Predicted lowest battery SoC value in kWh under the best plan with attribute of the date/time that that lowest SoC occurs at predbat.car_soc_best - See Car data below predbat.carbon_best - See Carbon data below predbat.grid_power_best - The sensor gives the current grid power in Watts, attributes contain future prediction of battery power in 5 minute slots. in kW per 5 minute slots to the end of the best plan for charting predbat.iboost_best - See iBoost data below predbat.load_power_best - Gives the current grid power in W, attributes contain the predicted house load over time. with attributes of the average instantaneous house load power in kW in 5-minute slots to the end of the plan predbat.pv_power_best - Gives the current PV power in Watts, attributes contain the predicted PV power in kW per 5-minute slots to the end of the best plan for charting predbat.soc_kw_best - Predicted final state of charge (in kWh) with attributes of the predicted SoC in 5-minute time slots to the end of the best plan, for charting predbat.soc_kw_best_h1 - Single data point for the predicted state of charge in 1 hour (useful for calibration charts, predicted vs actual) predbat.soc_kw_best_h8 - Single data point for the predicted state of charge in 8 hours (useful for calibration charts, predicted vs actual) predbat.soc_kw_best_h12 - Single data point for the predicted state of charge in 12 hours (useful for calibration charts, predicted vs actual) Best PV 10% Prediction data Predbat outputs the following best results under the PV 10% scenario for the forecast_hours duration, these are known as the 'best10' prediction: predbat.best10_metric - Predicted best cost in pence using the PV 10% solar forecast predbat.best10_export_energy- Predicted best export energy in kWh for PV 10% predbat.best10_import_energy- Predicted best import energy in kWH for PV 10% predbat.best10_load_energy - Predicted best load energy in kWh for PV 10% predbat.best10_pv_energy - Predicted best PV 10% energy in kWh predbat.soc_kw_best10 - As soc_kw_best but using the PV 10%, also holds minute-by-minute data (in attributes) to be charted In-day load adjustment data The following sensors are used in the in-day adjustment chart - see creating the Predbat charts and in-day load adjustment : predbat.load_energy_actual - Total kWh of house load to end of plan, energy up to 'now' taken from today's actual energy, energy after 'now' from Predbat's prediction. Attributes of this actual/predicted energy in 5-minute slots from midnight today to the end of the plan for charting predbat.load_energy_adjusted - Total kWh of predicted house load to end of the plan, adjusted based on variance of today's actual load to the predicted load (based on historical data), dampened according to input_number.predbat_metric_inday_adjust_damping. Attributes contain the 5-minute slot forecasts to the end of the plan for charting predbat.load_energy_predicted - Total predicted kWh of house load to end of plan, attributes of predicted load in 5-minute slots from midnight today to the end of the plan for charting predbat.load_inday_adjustment - the % in-day adjustment factor used to adjust Predbat's predicted load by the actual load today. After midnight when insufficient data is available, this blends yesterday's final adjustment factor with today's developing factor: 0-3 hours : Uses 100% of yesterday's adjustment factor 3-24 hours : Blend of yesterday's adjustment factor with today's Additional attributes available: - yesterday_adjustment : Yesterday's final in-day adjustment factor as a percentage - yesterday_weight : The current blend weight applied to yesterday's factor as a percentage (100% at midnight, decreasing to 0% by 8 hours) 'Today' energy data The following sensor's output by Predbat give the 'today' energy readings. They mirror input sensors fed into Predbat in apps.yaml and are used in the data prediction chart - see creating the Predbat charts : predbat.export_energy_h0 - Mirrors the export_today sensor configured in apps.yaml and gives today's total kWh of export energy predbat.import_energy_h0 - Mirrors the import_today sensor configured in apps.yaml and gives today's total kWh of import energy predbat.load_energy_h0 - Mirrors the load_today sensor configured in apps.yaml and gives today's total kWh of house load energy. Note that if you have configured load scaling then load_energy_h0 will have been scaled by the scaling factor. predbat.pv_energy_h0 - Mirrors the pv_today sensor configured in apps.yaml and gives today's total kWh of generated PV energy predbat.soc_kw_h0 - Mirrors the soc_kwh sensor configured in apps.yaml and gives today's total kWh of battery state of charge (SoC). Note that if you have configured battery scaling then soc_kw_h0 will have been scaled by the configured scaling factor Battery status The following sensors are set based on what Predbat is currently controlling the battery to do: binary_sensor.predbat_charging - Set to 'on' when Predbat is force charging the battery (from solar, or if that is insufficient, from grid import), or 'off' otherwise binary_sensor.predbat_exporting - Set to 'on' when Predbat is force discharging the battery for export income, 'off' otherwise. These are useful for automations if for example, you want to turn off car charging when the battery is being exported. Export trigger binary_sensor.predbat_export_trigger_NAME - custom binary sensors that are set to On by Predbat when more than a specified amount of energy is being exported - see Triggers in apps.yaml Prediction window predbat.record - The sensor is always zero; attributes contain the time window for the current predicted plan Energy rate data Low-rate import entities predbat.low_rate_cost - The lowest import rate cost in Pence predbat.low_rate_duration - The time duration in minutes of the next low rate slot predbat.low_rate_end - End time of the next low import rate slot predbat.low_rate_start - Start time of the next low import rate slot predbat.low_rate_cost_2, predbat.low_rate_end_2, predbat.low_rate_start_2 - The cost and times of the following low import rate slot binary_sensor.predbat_low_rate_slot - A sensor that is 'on' to indicate when there is a low energy rate import slot active, 'off' otherwise High-rate export entities predbat.high_rate_export_cost - The highest export rate cost in Pence predbat.high_rate_export_duration - The time duration in minutes of the next high rate slot predbat.high_rate_export_end - End time of the next high export rate slot predbat.high_rate_export_start - Start time of the next high export rate slot predbat.high_rate_export_cost_2, predbat.high_rate_export_end_2, predbat.high_rate_export_start_2 - The cost and times of the following high export rate slot binary_sensor.predbat_high_rate_export_slot - A sensor that is 'on' to indicate when there is a high export rate slot active, 'off' otherwise Other rate entities predbat.rates - The current energy import rate in Pence with attributes of yesterday's, today and tomorrow's rates which can be charted predbat.rates_export - The current energy export rates in Pence (also can be charted) predbat.rates_gas - The current gas rates in Pence (also can be charted) predbat.cost_today - The total cost of energy so far today (since midnight) with attributes of the total cost every 5 minutes since midnight today predbat.cost_today_export - Same as predbat.cost_today, but for all export income since midnight today predbat.cost_today_import - Same as predbat.cost_today, but for all import costs since midnight today predbat.cost_hour - The total cost of energy averaged over the last hour predbat.cost_today_export - Same as predbat.cost_hour, but for export predbat.cost_today_import - Same as predbat.cost_hour, but for import predbat.ppkwh_today - The cost in pence/kWh of the house load today accounting for the change in battery level predbat.ppkwh_hour - The cost in pence/kWh of the house load averaged over the last hour, accounting for the change in battery level Inverter data Some inverters store inverter settings in flash memory that can have a limited number of write cycles so Predbat counts the commands that it sends to the inverter so you can keep track of this: predbat.inverter_register_writes is the incrementing total number of writes across all inverters If you want to create a utility meter to record daily inverter register writes, add the following to your configuration.yaml (NB: the utility meter has to be defined in YAML, it cannot be configured via the HA User Interface): utility_meter: # Predbat daily inverter writes utility meter predbat_daily_inverter_writes: source: predbat.inverter_register_writes name: Predbat Daily Inverter Writes unique_id: predbat_daily_inverter_writes cycle: daily Add a card of type 'markdown' to your dashboard to display a simple dashboard of inverter writes: type: markdown content: >- {% set dd = ((as_timestamp(now()) - as_timestamp(\"2024-12-22 17:20:00\"))/86400) | int %} {% set tw = (states('predbat.inverter_register_writes') | int) %} {{ dd }} days, total {{ tw }} inverter writes {{ states('sensor.predbat_daily_inverter_writes')|int(0) }} writes today Average {{ (tw / dd ) | int(0) }} writes per day You'll need to change the hard-coded timestamp \"2024-12-12...\" to the date/time you first started counting Predbat inverter writes from to get the number of days and average writes per day correct. TIP: If your inverter is ever replaced and you want to reset the inverter register writes back to zero, simply update the entity state of predbat.inverter_register_writes using Settings / Developer Tools / States and search for the entity. Car data binary_sensor.predbat_car_charging_slot - A binary sensor indicating when to charge your car (if car planning is enabled) - which can be used in an automation as described in Predbat led car charging . The planned attribute of the binary_sensor contains details of all planned car charging activity with start and end dates and times, kWh to charge and charging cost. Note that the start and ends are expressed in 'MM-DD HH:MM:SS\" format, use the template sensor below if you want to convert these to full date format, e.g. to display on an Apex chart predbat.car_charging_start - The time that car charging is planned to start at, in HH:MM:SS format predbat.car_soc_best - Predicted charge level of your car in the best plan at the end of the plan using the proposed car charging SoC% and charge window. Can also be charted predbat.cost_today_car - Current cost in pence so far today of charging all cars, with attribute of the projected future car charging costs and slots predbat.cost_total_car - A running total in pence of the below cost_yesterday_car sensor, with attribute of the total in pounds predbat.cost_yesterday_car - A sensor that gives the total energy costs in pence of charging all cars for yesterday (00:00-23:59 on the previous day) See Example Automation to separate car charging costs if you have multiple EV's and want to separate predbat.cost_today_car into costs per car. Template sensor to convert Predbat car charging times to full HA date format such as for displaying on an Apex chart: - unique_id: \"PredBat Car Charging Times\" - sensor: - name: \"PredBat Car Charging Times\" state: \"{{ now() }}\" attributes: planned_times: > {% set times = state_attr('binary_sensor.predbat_car_charging_slot','planned') %} {% set ns = namespace(erg = []) %} {% set delta = now().date().strftime(\"%Y\") | int %} {% for time in times %} {% set x = strptime(time.start,\"%m-%d %H:%M:%S\").replace(year=delta) %} {% set item = { \"start\": x | string } %} {% set ns.erg = ns.erg + [item] %} {% endfor %} {{ ns.erg }} iBoost Solar Diverter data binary_sensor.predbat_iboost_active - A binary sensor indicating when there is excess solar and the solar diverter (e.g. iBoost, Eddi or just plain immersion heater) should be active, can be used for automations to trigger the immersion heater boost input_number.predbat_iboost_today - Gives the amount of energy modelled that will be sent to the solar diverter today, increments during the day and is reset to zero at 11:30pm each night predbat.iboost_best - Predicted energy in kWh going into the iBoost solar diverter under the best plan You can use the iboost_best sensor to create a custom template sensor that gives the time to next planned iBoost: {% set iboost_times = state_attr(\"predbat.iboost_best\",\"results\") %} {% set times = iboost_times.keys()|list %} {% set iboost_energy = iboost_times.values()|list %} {% set ni = namespace(x=0) %} {% set data = namespace(h_bool=False) %} {% set iboost_starts = \"\" %} {% for ni in range(0,times|count()-1) if data.h_bool == false %} {% if iboost_energy[ni+1]-iboost_energy[ni] > 0 %} {% set data.h_bool = true %}{{ (as_timestamp (times[ni])-as_timestamp (now()) ) / 3600 | round (0) }} {% else %} {% endif %} {% endfor %} {% if data.h_bool == false %} {{100}} {% endif %} If no iBoost is imminent then the sensor is set to 100h, and if currently boosting it will produce a small negative answer. Thanks to @mogons57 for the template sensor code. Carbon data The following sensors output by Predbat give historic and predicted carbon data. They are used in the carbon chart - see creating the Predbat charts . predbat.carbon - Predicted Carbon energy in g at the end of the plan with attributes giving the breakdown of predicted Carbon impact by half hour time slots predbat.carbon_best - Predicted Carbon intensity in g for your home under the best plan based on grid imports, grid exports and the grid's projected carbon intensity predbat.carbon_now - A sensor that gives the current Grid Carbon intensity in g/kWh predbat.carbon_today - A sensor that tracks your home's Carbon impact today in g based on your grid import minus your grid export Cost saving data The following sensors output by Predbat give cost-saving data that Predbat achieved, i.e. the financial benefits of using Predbat. They are used in the daily cost-saving and total cost-savings charts - see creating the Predbat charts : predbat.cost_yesterday - A sensor that gives the total energy costs in pence for yesterday (00:00-23:59 on the previous day) predbat.savings_total_actual - A running total in pence of the above cost_yesterday sensor, with attribute of the total in pounds predbat.savings_total_predbat - A running total in pence of the below savings_yesterday_predbat sensor, with attribute of the total in pounds predbat.savings_total_pvbat - A running total of the below savings_yesterday_pvbat sensor, with attribute of the total in pounds predbat.savings_total_soc - A running total of what the final SoC in kWh would have been at the end of each day if you were not using Predbat predbat.savings_yesterday_predbat - A sensor which tells you how much money Predbat saved you yesterday compared to not using Predbat, and only charging at the lowest import rate in the 24 hour period predbat.savings_yesterday_pvbat - A sensor which tells you how much money you saved from using Predbat vs not having a PV and battery system at all and all house load being met from grid import Note: The savings using Predbat are calculated by default compared to having one fixed nightly charge slot set to charge at the lowest import rate with a target of 100% You can change the number of simulated charge slots in apps.yaml by setting calculate_savings_max_charge_slots to the number of slots to allow. If set to 0 then Demand (ECO) mode will be used as the baseline or if non-zero then the maximum number of slots can be set (e.g. 2). Solar forecast data The following sensors give the forecast Solar data from Solcast. Predbat populates these sensors irrespective of whether you are using the Predbat direct Solcast or Solcast integration method to get your Solar forecast, but if you are using the Solcast integration then the Predbat sensors mirror the similarly named Solcast integration sensors so could be disabled if you so wish. sensor.predbat_pv_today - Tracks the PV forecast in kWh for today, attributes give the total today, remaining amount today and the half-hourly data sensor.predbat_pv_tomorrow - Tracks the PV forecast in kWh for tomorrow, attributes give the total today, remaining amount today and the half-hourly data sensor.predbat_pv_d2 - Similar to the above, but tracking the PV forecast for the day after tomorrow sensor.predbat_pv_d3 - PV forecast for two days after tomorrow sensor.predbat_pv_forecast_h0 - Tracks the PV 'power now' forecast in Watts, attributes give the 10% and 90% power now forecast The solar sensor attributes include: total - total PV forecast for the day total10 - total PV 10% forecast for the day total90 - total PV 90% forecast for the day totalCL - total calibrated PV forecast for the day, this is the PV forecast adjusted by Predbat based on historical forecast vs generation data. The calibration should take account of shading or panel performance issues remaining/remaining10/remaining90/remainingCL - forecast solar generation for the remainder of the day detailedForecast - a half hourly breakdown of solar forecast for the day, with similar PV estimate, 10% estimate, 90% estimate and calibrated estimate values Dummy inverter sensors Predbat can now manage different inverter types, some of which don't have all the same control characteristics. Predbat might create dummy entities for control aspects that your inverter doesn't natively support. For example, for each Gen 1 hybrid inverter (N=0, 1, etc if there are multiple inverters), Predbat creates the following dummy inverter entities: sensor.predbat_ge_N_idle_end_time sensor.predbat_ge_N_idle_start_time sensor.predbat_ge_N_scheduled_discharge_enable These sensors can be ignored and excluded from the recorder history if you wish. Alert data sensor.predbat_alertfeed_status - Gives you data on the currently active weather alert (if configured) and in the attributes a list of all active alerts with their details Predbat Logfile Predbat writes detailed logging, status and progress activity information to a logfile as it runs and so this file should be checked if predbat.status reports an error, or if you want to verify that Predbat is running OK. There is a lot of output in the logfile, this is normal! If you are using the Predbat app then the logfile can easily be viewed via the 'Log' tab of the Predbat web interface . To directly view the physical logfile, it can be found in one of three different directories in Home Assistant with slightly different filenames depending on how you installed Predbat: if you have used the Predbat app installation method , the logfile will be /addon_configs/6adb4f0d_predbat/predbat.log , if the HACS, Appdaemon app then Predbat installation method , it's /homeassistant/appdaemon/appdaemon.log , or if the combined AppDaemon/Predbat app installation method was used, it's /addon_configs/46f69597_appdaemon-predbat/predbat.log . You will need to use a file editor within Home Assistant (e.g. either the File editor or Studio Code Server apps) to view Predbat's logfile if you are not using the Predbat app. See editing configuration files within Home Assistant if you need to install an editor. Automated monitoring that Predbat and GivTCP are running OK With Predbat performing an important function, managing your battery charging and discharging to best reduce your electricity bills, you may find these automations useful to monitor that everything is running OK, and if not, to try restarting the failing app, and raise an alert on your mobile device running the Home Assistant Companion app. Two monitors are provided, one for Predbat and one for GivTCP (for GivEnergy inverters). Both monitors are written on the basis that Predbat/GivTCP are running as apps within the Home Assistant Supervisor. If you are running Predbat within Docker then the automation won't work as written. The GivTCP monitor is for use with a GivEnergy inverter, if you have a different inverter type then you may be able to use the GivTCP monitor as a basis for developing a similar inverter-specific error detection automation for your inverter. To create a new automation: Settings / Automations & Scenes Create Automation / Create new Automation Three dots (top right corner) / Edit in YAML Delete the existing (template) automation code and copy/paste the supplied automation code below GivTCP Activity Monitor This automation will raise an alert if any of the following occur: The inverter goes offline for more than 15 minutes No last_updated_time received from the inverter for more than 15 minutes Inverter temperature less than 5 degrees for more than 15 minutes (should never happen) The battery goes offline to the inverter for more than 15 minutes GivTCP app is not running Mosquitto broker app is not running The script will need to be customised for your inverter ID, battery ID and mobile details, and can be extended for multiple inverters and batteries by duplicating the triggers and adding appropriate battery and inverter IDs. alias: GivTCP activity monitor description: Alert when communications to GivTCP have ceased for 15 minutes triggers: - trigger: state entity_id: sensor.givtcp_<inverter id>_last_updated_time to: \"null\" for: minutes: 15 variables: alert_text: No GivTCP update received from inverter <id> restart_app: GivTCP - trigger: state entity_id: - sensor.givtcp_<inverter id>_status from: online for: minutes: 15 variables: alert_text: No GivTCP update received from inverter <id> restart_app: GivTCP - trigger: numeric_state entity_id: - sensor.givtcp_<inverter id>_invertor_temperature for: minutes: 15 below: 10 variables: alert_text: No GivTCP update received from inverter <id> restart_app: GivTCP - trigger: state entity_id: - sensor.givtcp_<battery id>_battery_cells to: unknown for: minutes: 15 variables: alert_text: Battery <battery_id> is offline to GivTCP restart_app: GivTCP - trigger: state entity_id: - binary_sensor.givtcp_running to: \"off\" for: minutes: 15 variables: alert_text: GivTCP app is not running restart_app: GivTCP - trigger: state entity_id: - binary_sensor.mosquitto_broker_running to: \"off\" for: minutes: 15 variables: alert_text: Mosquitto Broker app is not running restart_app: Mosquitto actions: - action: notify.mobile_app_<your mobile device id> alias: Send a notification data: title: GivTCP communication issue message: | {{now().strftime('%-d %b %H:%M')}} ISSUE: {{ alert_text }} for the past 15 minutes, restarting {{ restart_app }} data: visibility: public persistent: true push: sound: name: default critical: 1 volume: 0.8 sticky: true color: red - choose: - conditions: - condition: template value_template: \"{{ restart_app == 'GivTCP' }}\" sequence: - alias: Restart GivTCP app action: hassio.addon_restart data: addon: 533ea71a_givtcp - conditions: - condition: template value_template: \"{{ restart_app == 'Mosquitto' }}\" sequence: - alias: Restart Mosquitto app action: hassio.addon_restart data: addon: core_mosquitto trace: stored_traces: 20 mode: single The last two triggers (GivTCP and Mosquitto running) trigger if any of these apps that Predbat is dependent upon are not running. You will need to enable a binary sensor for each app to be able to use these triggers in the automation: Navigate to Settings / Devices and Services / Devices and search for 'GivTCP' Click on the GivTCP app, and under 'Sensors', click 'XX entities not shown' Click the 'Running' sensor, then the cogwheel, and Enable the sensor Repeat these steps for the 'Mosquitto' app. As an extension to the above, if you don't want the automation to restart the failing app and instead just send an alert that there is a problem, delete the 'choose' code above. Restarting GivTCP does however lose the current GivTCP log-in Home Assistant. NB: If you are using GivTCP v2 rather than v3, replace the '533ea71a_givtcp' with 'a6a2857d_givtcp'. Predbat Error Monitor This automation will raise an alert if Predbat's status turns to Error for more than 5 minutes. In normal operation, Predbat will automatically run and update its plan and forecast every 5 minutes. If the automation detects that Predbat has not done this for 20 minutes, then an alert will be raised and the automation will restart the Predbat app to try to resolve a 'hung Predbat' issue. In the same way for the GivTCP and Mosquitto apps above, the last trigger requires you to enable a binary sensor that detects that the Predbat/AppDaemon app is running. Follow the same steps to enable the binary sensor for either the 'Predbat' or (deprecated) 'AppDaemon' app depending on which Predbat installation method you followed. The script will need to be customised for your mobile details. alias: Predbat error monitor description: Alert when Predbat has raised an exception trace: stored_traces: 50 triggers: - trigger: template alias: Predbat status contains 'Error' for 10 minutes value_template: \"{{ 'Error' in states('predbat.status') }}\" for: minutes: 10 variables: alert_text: >- Predbat status is {{ states('predbat.status') }}, error={{ state_attr('predbat.status', 'error') }} - trigger: state alias: Predbat is in error status for 10 minutes entity_id: predbat.status attribute: error to: \"true\" for: minutes: 10 variables: alert_text: >- Predbat status is {{ states('predbat.status') }}, error={{ state_attr('predbat.status', 'error') }} - trigger: state alias: Predbat status.last_updated has not changed for 20 minutes entity_id: predbat.status attribute: last_updated for: minutes: 20 variables: alert_text: >- Predbat last_updated=' {{ state_attr('predbat.status','last_updated')|as_timestamp|timestamp_custom('%a %H:%M') }}', unchanged for 20 mins; Status='{{ states('predbat.status') }}', restarting restart_predbat: \"Y\" - trigger: state alias: Predbat app not running for 15 minutes entity_id: binary_sensor.predbat_running to: \"off\" for: minutes: 15 variables: alert_text: Predbat app is not running, restarting restart_predbat: \"Y\" - trigger: state alias: predbat_active stuck on for 20 minutes entity_id: - switch.predbat_active for: minutes: 20 variables: alert_text: Predbat active has been stuck on (updating the plan) for 20 minutes, restarting restart_predbat: \"Y\" - trigger: template alias: Predbat entities not populated for 20 minutes value_template: \"{{ states('predbat.plan_html') == 'unknown' }}\" for: minutes: 20 variables: alert_text: >- Predbat plan is unknown for 20 minutes, possibly failed on startup, restarting restart_predbat: \"Y\" - alias: \"Heartbeat: check Predbat has populated output entities OK\" trigger: time_pattern minutes: /30 id: heartbeat actions: - alias: Heartbeat, check Predbat output variables are populated if: - condition: trigger id: - heartbeat then: - if: - condition: template value_template: \"{{states('predbat.plan_html') == 'unknown' }}\" then: - variables: alert_text: >- Predbat has not populated its output entities, possibly failed on startup, restarting restart_predbat: \"Y\" else: - stop: \"Heartbeat check: Predbat plan is populated, all is OK\" - action: notify.mobile_app_<your mobile device id> alias: Send alert message data: title: Predbat status issue message: | {{now().strftime('%-d %b %H:%M')}} ISSUE: {{ alert_text }} data: visibility: public persistent: true push: sound: name: default critical: 1 volume: 0.8 sticky: true color: red - if: - condition: template value_template: \"{{ restart_predbat == 'Y' }}\" then: - action: hassio.addon_restart data: addon: 6adb4f0d_predbat alias: Restart Predbat app mode: single NB: If you are using AppDaemon rather than the Predbat app, replace '6adb4f0d_predbat' with 'a0d7b954_appdaemon' and change 'binary_sensor.predbat_running' to 'binary_sensor.appdaemon_running'. An error alert looks like this:","title":"Output data"},{"location":"output-data/#output-data","text":"Each time Predbat runs it outputs a lot of information about the current performance of your solar/battery system and the predicted load, PV, cost, CO2, car charging, etc. This section of the documentation explains the different output and logging data that Predbat produces and gives an overview of how to display that information within Home Assistant. There can never be a single Predbat dashboard that suits every user, so instead Predbat gives a starter set of displays that can be adapted to your individual needs.","title":"Output data"},{"location":"output-data/#web-interface","text":"The Predbat Web Interface provides an easy to use way to see and change different aspects of your Predbat system including view the current plan, adjust the configuration, view the charts, check your apps.yaml and view the logfiles.","title":"Web interface"},{"location":"output-data/#displaying-output-data","text":"Each Predbat configuration item is named input_number.predbat_xxx , switch.predbat_yyy or select.predbat_zzz depending on the control type.","title":"Displaying output data"},{"location":"output-data/#creating-a-simple-predbat-dashboard","text":"Each time Predbat runs it auto-generates a dashboard with the filename predbat_dashboard.yaml that can be used as a starter for your own Predbat dashboard. Depending on how you installed Predbat this predbat_dashboard.yaml file will be held in one of three different directories in Home Assistant: if you have used the Predbat app installation method , it will be in the directory /addon_configs/6adb4f0d_predbat/ , or, with the deprecated HACS, Appdaemon app then Predbat installation method , it's /config/appdaemon/apps/batpred/config/ . You will need to use a file editor within Home Assistant (e.g. either the File editor or Studio Code Server apps) to open the predbat_dashboard.yaml file - see editing configuration files within Home Assistant if you need to install an editor. Once opened, select and copy all the contents of the predbat_dashboard.yaml file and add the contents to a new dashboard page: Go to Settings/Dashboards, double click an existing dashboard name or 'Add Dashboard'/'New dashboard from scratch'/enter a name/click Create, then double click the newly created dashboard Click the pencil icon in the top right corner, click the lower dashed box (Create section), click the solid blue boxed plus symbol to 'Add card', scroll down the list of cards to the bottom and click 'Manual', delete all the template card configuration and paste the contents of the predbat_dashboard.yaml file copied earlier, then 'Save' and 'Done' in the top right. This will give you a simple Predbat control and output dashboard that you can then resequence and customise as you wish.","title":"Creating a simple Predbat dashboard"},{"location":"output-data/#creating-a-compact-predbat-control-dashboard","text":"You can also create a dashboard page that's dynamically generated to automatically include all the Predbat control and output entities, so when new entities are added in future Predbat releases, you don't have to edit the dashboard. Firstly you need to install HACS if it isn't already installed, and then install two HACS front-end components: Auto Entities ( https://github.com/thomasloven/lovelace-auto-entities ) automatically generates a list of entities that match a wildcard expression Lovelace Collapsable Cards ( https://github.com/RossMcMillan92/lovelace-collapsable-cards ) wraps the entity lists within a drop-down toggle Installation steps: Click the HACS icon on the left-hand side panel Click the three dots in the top right corner then 'Custom Repositories' Paste (or type) in the following repository name https://github.com/RossMcMillan92/lovelace-collapsable-cards , choose Type 'Dashboard', and click Add Close the Custom Repositories dialogue Click 'Explore & Download Repositories' Search for 'collapsable cards', click the name of it, check it's the right one, click 'Download', 'Download' again, then 'Reload' Click 'Explore & Download Repositories' again, search for 'auto-entities', then 'Download', 'Download', 'Reload' Now create the dynamic dashboard: Go to Settings/Dashboards, double click an existing dashboard or 'Add Dashboard'/'New dashboard from scratch'/enter a name/click Create, then double click click the new dashboard Click the pencil icon in the top right corner, then the plus symbol on the far right of the next row to create a new View Enter a title of the View, then Save Click the pencil icon in the top right corner, click the lower dashed box (Create section), click the solid blue boxed plus symbol to 'Add card', scroll down the list of cards to the bottom and click 'Manual', delete all the template card configuration and copy/paste the following YAML into the dashboard and click 'Save': type: vertical-stack title: Predbat \ud83e\udd87 cards: - type: entities entities: - entity: predbat.status - type: weblink name: Predbat Web Console url: /hassio/ingress/6adb4f0d_predbat - entity: update.predbat_version - entity: select.predbat_update - entity: select.predbat_mode - entity: select.predbat_saverestore - entity: switch.predbat_active - type: custom:collapsable-cards title: \ud83d\udd00 Control defaultOpen: false cards: - type: custom:collapsable-cards title: \ud83d\udd22 Input Variables defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: input_number.predbat* exclude: [] unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: \ud83d\udd00 Switches defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: switch.predbat* exclude: [] unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: \ud83d\udd22 Selectors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: select.predbat* exclude: [] unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: '#\ufe0f\u20e3 Sensors' defaultOpen: false cards: - type: custom:collapsable-cards title: \ud83d\udcb7 Cost Sensors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: predbat.*cost* - entity_id: predbat.*rate* - entity_id: predbat.*metric* exclude: - entity_id: predbat.*start* - entity_id: predbat.*end* - entity_id: predbat.*duration* unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: \ud83d\udcb7 Saving Sensors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: predbat.*saving* exclude: - entity_id: predbat.*start* - entity_id: predbat.*end* - entity_id: predbat.*duration* unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: \ud83d\udd5b Time/Duration Sensors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: predbat.*start* - entity_id: predbat.*end* - entity_id: predbat.*duration* - entity_id: predbat.*record* exclude: [] unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: \u26a1 Power Sensors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: predbat.*soc* - entity_id: predbat.*energy* - entity_id: predbat.*load* - entity_id: predbat.*battery* - entity_id: predbat.*kw* - entity_id: predbat.*power* - entity_id: predbat.*charge* - entity_id: predbat.*iboost* - entity_id: predbat.*grid* - entity_id: sensor.predbat_pv* exclude: - entity_id: predbat.*savings* - entity_id: predbat.*start* - entity_id: predbat.*end* - entity_id: predbat.*duration* - entity_id: predbat.*record* unique: true sort: method: friendly_name numeric: false - type: custom:collapsable-cards title: 1\ufe0f\u20e3 Binary Sensors defaultOpen: false cards: - type: custom:auto-entities card: type: entities filter: include: - entity_id: binary_sensor.predbat* exclude: [] unique: true sort: method: friendly_name numeric: false This will give you a compact dynamically created list of all Predbat entities which groups the entities by type and is collapsed by default to prevent screen clutter. Credit @DJBenson for the code.","title":"Creating a compact Predbat control dashboard"},{"location":"output-data/#viewing-the-predbat-plan","text":"predbat.plan_html - A sensor that contains an HTML render of the Predbat predicted best plan, detailing import and export rates, predicted house load, solar generation, any solar clipping, battery SoC, car and iBoost charging, and Predbat's planned charging and discharging activities. The plan is contained in the 'html' attribute, and its recommended to Create the Predbat Plan card as an easy way to see the plan that Predbat has created. The sensor also contains the 'text' attribute which gives a HTML formatted brief text description of the Predbat plan, and the 'raw' attribute which repeats the plan data but in raw (unformatted) JSON format. If you are using the Predbat app or docker then the Predbat plan can also be viewed via the 'Plan' view of the Predbat web interface , and the text description via the 'Dash' view .","title":"Viewing the Predbat plan"},{"location":"output-data/#graphing-the-predbat-predictions","text":"A set of Apex Charts can also be created to see graphically what Predbat plans to do - Creating the charts . Renditions of the key charts can also be seen in the 'Charts' view of the Predbat web interface .","title":"Graphing the Predbat predictions"},{"location":"output-data/#basic-status","text":"switch.predbat_active - Automatically set by Predbat to On when Predbat is busy calculating or controlling your inverter, or Off when Predbat is waiting for the next time it needs to perform a plan calculation update. If you toggle this switch in Home Assistant it will force Predbat to perform an update now (useful for automations). predbat.status - Gives the current status & errors and logs any changes that Predbat makes to your inverter. The different Predbat status values and their meanings are detailed in what does Predbat do . predbat.status additionally has the following attributes that are automatically populated: Last updated - date and time that Predbat last updated the plan Debug - A set of arrays containing Predbat's planned charging and discharging time windows and battery limits (in kWh) Version - version of Predbat that's running Error - binary value true or false depending upon whether Predbat is in an error status or nor","title":"Basic status"},{"location":"output-data/#sensor-data","text":"Predbat outputs the values it read from your inverters as totals, this gives the current power flow: predbat.load_power - The current house load in Watts predbat.battery_power - The current power of your battery (charging or discharging) in Watts predbat.pv_power - The current power of your PV system in Watts predbat.grid_power - The current grid power flow (import or export) in Watts","title":"Sensor data"},{"location":"output-data/#baseline-data","text":"Predbat outputs the following sensors to predict what your battery is expected to do over the forecast_hours duration of the plan with no changes made by Predbat. This is considered to be the 'baseline' plan: NB: All of Predbat's forecasts are from midnight today to the forecast_hours duration (set in apps.yaml) into the future and shouldn't be confused with 'today' figures. e.g. predbat.pv_energy is the actual PV energy from midnight today, and for the predicted forecast_hours (typically 48) ahead so will be much larger than sensor.solcast_pv_forecast_today which is today's Solcast PV forecast. predbat.battery_cycle - Predicted baseline battery cycle in kWh (total kWh processed) with attributes of the prediction every 5 minutes to the end of the plan predbat.battery_hours_left - The number of hours left until your home battery is predicted to run out under the baseline plan (stops at the maximum prediction time) predbat.car_soc - The expected charge level of your car at the end of the baseline plan. Can also be charted predbat.charge_end - Predicted end time of the next forced battery charging under the baseline plan predbat.charge_limit - Predicted baseline battery charge limit for the next charge in percent with attributes of all future battery charging times & limits predbat.charge_limit_kw - Predicted baseline battery charge limit for the next charge in kWh with attributes of future charging times & limits predbat.charge_start - Predicted start time of the next forced battery charging under the baseline plan predbat.duration - The duration of the prediction maximum in hours predbat.export_energy - Total kWh of predicted exports under the baseline plan with attributes of the predicted export kWh and their time slots in kW per 5-minute slots to the end of the baseline plan for charting predbat.import_energy - Total kWh of predicted imports under baseline plan with attributes of the predicted import kWh and their time slots predbat.import_energy_battery - Total kWh of predicted import energy used to charge the home battery under the baseline plan predbat.import_energy_house - Predicted import energy used by the home under the baseline plan that is not provided by your home battery (e.g. due to a flat battery or load above the maximum discharge rate) predbat.load_energy - Total kWh of predicted house load under the baseline plan with attributes of the predicted load kWh in 5-minute slots to the end of the plan with attributes of the average instantaneous house load power in kW in 5-minute slots to the end of the plan predbat.metric - Total predicted cost for the baseline plan, taking account of predicted solar generation, house load, import and export rates. Attributes contain data for charting the cost prediction in 5-minute slots to the end of the plan predbat.pv_energy - Predicted PV energy in kWh under the baseline plan with attributes of the predicted PV generation in kWh with time slots predbat.soc_kw - Predicted state of charge (in kWh) at the end of the baseline plan prediction, not very useful in itself, but the attributes hold prediction data in 5-minute intervals which can be charted with Apex Charts (or similar) predbat.soc_min_kwh - Predicted lowest battery SoC value in kWh under the baseline plan with attribute of the date/time that that lowest SoC occurs at","title":"Baseline data"},{"location":"output-data/#pv-10-baseline-data","text":"Predbat outputs the following baseline results under the PV 10% scenario for the forecast_hours duration of the plan, these are known as the 'base10' predictions: predbat.base10_export_energy- Total predicted export energy in kWh for the PV 10% scenario, with attributes of the predicted export kWh and their time slots predbat.base10_import_energy- Total predicted import energy in kWh for the PV 10% scenario, with attributes of the predicted import kWh and their time slots predbat.base10_load_energy - Total predicted house load in kWh for the PV 10% scenario predbat.base10_metric - Total predicted cost for the PV 10% scenario, with attributes of the cost prediction in 5-minute slots to the end of the plan for charting predbat.base10_pv_energy - Predicted PV 10% energy in kWh with attributes of the predicted PV generation in kWh with time slots predbat.soc_kw_base10 - Predicted final state of charge (in kWh) of the battery, with attributes of the predicted SoC in 5-minute time slots to the end of the plan under the PV 10% scenario, for charting","title":"PV 10% Baseline data"},{"location":"output-data/#best-prediction-data","text":"Predbat outputs the following 'best' entities from the forecast (for the forecast_hours duration) based on the lowest cost consumption plan. The 'best' plan in Predbat parlance is simply Predbat's lowest cost predicted plan: predbat.battery_cycle_best - Predicted best battery cycle in kWh (total kWh processed) with attributes of the prediction in 5-minute slots. predbat.battery_power_best - Sensor gives the current battery power in watts, attributes give the future prediction of battery power in 5-minute slots predbat.best_battery_hours_left - Predicted total number of hours of battery capacity left under the best plan predbat.best_charge_end - Predicted end time of the next forced battery charging under the best plan predbat.best_charge_limit - Predicted best battery charge limit for the next charge in percent with attributes of all future battery charging times & limits predbat.best_charge_limit_kw - Predicted best battery charge limit for the next charge in kWh with attributes of future charging times & limits predbat.best_charge_start - Predicted start time of the next forced battery charging under the best plan predbat.best_export_end - Predicted end time of the next forced battery export under the best plan predbat.best_export_limit - Predicted best battery export limit in percent (will be 0% when discharging or 100% when not) with attributes of all future battery exports (kWh and time slots) predbat.best_export_limit_kw - Predicted best battery export limit in kWh predbat.best_export_start - Predicted start time of the next forced battery export under the best plan predbat.best_export_energy - Total kWh of predicted exports under the best plan, with attributes of the predicted export kWh and their time slots predbat.best_import_energy - Total kWh of predicted imports under the best plan, with attributes of the predicted import kWh and their time slots predbat.best_import_energy_battery - Total kWh of predicted import energy to charge the home battery under the best plan predbat.best_import_energy_house - Total kWh of predicted import energy used directly by the house under the best plan (e.g. due to a flat battery or the house load is greater than the max discharge rate) predbat.best_load_energy - Total kWh of predicted house load energy in kWh under the best plan with attributes of the predicted load kWh in 5 minute slots to the end of the plan predbat.best_metric - Total predicted cost for the best plan, taking account of predicted solar generation, house load, import and export rates. Attributes contain data for charting the cost prediction in 5-minute slots to the end of the plan predbat.best_pv_energy - Predicted PV energy in kWh under the best plan with attributes of the predicted PV generation in kWh with time slots predbat.best_soc_min_kwh - Predicted lowest battery SoC value in kWh under the best plan with attribute of the date/time that that lowest SoC occurs at predbat.car_soc_best - See Car data below predbat.carbon_best - See Carbon data below predbat.grid_power_best - The sensor gives the current grid power in Watts, attributes contain future prediction of battery power in 5 minute slots. in kW per 5 minute slots to the end of the best plan for charting predbat.iboost_best - See iBoost data below predbat.load_power_best - Gives the current grid power in W, attributes contain the predicted house load over time. with attributes of the average instantaneous house load power in kW in 5-minute slots to the end of the plan predbat.pv_power_best - Gives the current PV power in Watts, attributes contain the predicted PV power in kW per 5-minute slots to the end of the best plan for charting predbat.soc_kw_best - Predicted final state of charge (in kWh) with attributes of the predicted SoC in 5-minute time slots to the end of the best plan, for charting predbat.soc_kw_best_h1 - Single data point for the predicted state of charge in 1 hour (useful for calibration charts, predicted vs actual) predbat.soc_kw_best_h8 - Single data point for the predicted state of charge in 8 hours (useful for calibration charts, predicted vs actual) predbat.soc_kw_best_h12 - Single data point for the predicted state of charge in 12 hours (useful for calibration charts, predicted vs actual)","title":"Best Prediction data"},{"location":"output-data/#best-pv-10-prediction-data","text":"Predbat outputs the following best results under the PV 10% scenario for the forecast_hours duration, these are known as the 'best10' prediction: predbat.best10_metric - Predicted best cost in pence using the PV 10% solar forecast predbat.best10_export_energy- Predicted best export energy in kWh for PV 10% predbat.best10_import_energy- Predicted best import energy in kWH for PV 10% predbat.best10_load_energy - Predicted best load energy in kWh for PV 10% predbat.best10_pv_energy - Predicted best PV 10% energy in kWh predbat.soc_kw_best10 - As soc_kw_best but using the PV 10%, also holds minute-by-minute data (in attributes) to be charted","title":"Best PV 10% Prediction data"},{"location":"output-data/#in-day-load-adjustment-data","text":"The following sensors are used in the in-day adjustment chart - see creating the Predbat charts and in-day load adjustment : predbat.load_energy_actual - Total kWh of house load to end of plan, energy up to 'now' taken from today's actual energy, energy after 'now' from Predbat's prediction. Attributes of this actual/predicted energy in 5-minute slots from midnight today to the end of the plan for charting predbat.load_energy_adjusted - Total kWh of predicted house load to end of the plan, adjusted based on variance of today's actual load to the predicted load (based on historical data), dampened according to input_number.predbat_metric_inday_adjust_damping. Attributes contain the 5-minute slot forecasts to the end of the plan for charting predbat.load_energy_predicted - Total predicted kWh of house load to end of plan, attributes of predicted load in 5-minute slots from midnight today to the end of the plan for charting predbat.load_inday_adjustment - the % in-day adjustment factor used to adjust Predbat's predicted load by the actual load today. After midnight when insufficient data is available, this blends yesterday's final adjustment factor with today's developing factor: 0-3 hours : Uses 100% of yesterday's adjustment factor 3-24 hours : Blend of yesterday's adjustment factor with today's Additional attributes available: - yesterday_adjustment : Yesterday's final in-day adjustment factor as a percentage - yesterday_weight : The current blend weight applied to yesterday's factor as a percentage (100% at midnight, decreasing to 0% by 8 hours)","title":"In-day load adjustment data"},{"location":"output-data/#today-energy-data","text":"The following sensor's output by Predbat give the 'today' energy readings. They mirror input sensors fed into Predbat in apps.yaml and are used in the data prediction chart - see creating the Predbat charts : predbat.export_energy_h0 - Mirrors the export_today sensor configured in apps.yaml and gives today's total kWh of export energy predbat.import_energy_h0 - Mirrors the import_today sensor configured in apps.yaml and gives today's total kWh of import energy predbat.load_energy_h0 - Mirrors the load_today sensor configured in apps.yaml and gives today's total kWh of house load energy. Note that if you have configured load scaling then load_energy_h0 will have been scaled by the scaling factor. predbat.pv_energy_h0 - Mirrors the pv_today sensor configured in apps.yaml and gives today's total kWh of generated PV energy predbat.soc_kw_h0 - Mirrors the soc_kwh sensor configured in apps.yaml and gives today's total kWh of battery state of charge (SoC). Note that if you have configured battery scaling then soc_kw_h0 will have been scaled by the configured scaling factor","title":"'Today' energy data"},{"location":"output-data/#battery-status","text":"The following sensors are set based on what Predbat is currently controlling the battery to do: binary_sensor.predbat_charging - Set to 'on' when Predbat is force charging the battery (from solar, or if that is insufficient, from grid import), or 'off' otherwise binary_sensor.predbat_exporting - Set to 'on' when Predbat is force discharging the battery for export income, 'off' otherwise. These are useful for automations if for example, you want to turn off car charging when the battery is being exported.","title":"Battery status"},{"location":"output-data/#export-trigger","text":"binary_sensor.predbat_export_trigger_NAME - custom binary sensors that are set to On by Predbat when more than a specified amount of energy is being exported - see Triggers in apps.yaml","title":"Export trigger"},{"location":"output-data/#prediction-window","text":"predbat.record - The sensor is always zero; attributes contain the time window for the current predicted plan","title":"Prediction window"},{"location":"output-data/#energy-rate-data","text":"","title":"Energy rate data"},{"location":"output-data/#low-rate-import-entities","text":"predbat.low_rate_cost - The lowest import rate cost in Pence predbat.low_rate_duration - The time duration in minutes of the next low rate slot predbat.low_rate_end - End time of the next low import rate slot predbat.low_rate_start - Start time of the next low import rate slot predbat.low_rate_cost_2, predbat.low_rate_end_2, predbat.low_rate_start_2 - The cost and times of the following low import rate slot binary_sensor.predbat_low_rate_slot - A sensor that is 'on' to indicate when there is a low energy rate import slot active, 'off' otherwise","title":"Low-rate import entities"},{"location":"output-data/#high-rate-export-entities","text":"predbat.high_rate_export_cost - The highest export rate cost in Pence predbat.high_rate_export_duration - The time duration in minutes of the next high rate slot predbat.high_rate_export_end - End time of the next high export rate slot predbat.high_rate_export_start - Start time of the next high export rate slot predbat.high_rate_export_cost_2, predbat.high_rate_export_end_2, predbat.high_rate_export_start_2 - The cost and times of the following high export rate slot binary_sensor.predbat_high_rate_export_slot - A sensor that is 'on' to indicate when there is a high export rate slot active, 'off' otherwise","title":"High-rate export entities"},{"location":"output-data/#other-rate-entities","text":"predbat.rates - The current energy import rate in Pence with attributes of yesterday's, today and tomorrow's rates which can be charted predbat.rates_export - The current energy export rates in Pence (also can be charted) predbat.rates_gas - The current gas rates in Pence (also can be charted) predbat.cost_today - The total cost of energy so far today (since midnight) with attributes of the total cost every 5 minutes since midnight today predbat.cost_today_export - Same as predbat.cost_today, but for all export income since midnight today predbat.cost_today_import - Same as predbat.cost_today, but for all import costs since midnight today predbat.cost_hour - The total cost of energy averaged over the last hour predbat.cost_today_export - Same as predbat.cost_hour, but for export predbat.cost_today_import - Same as predbat.cost_hour, but for import predbat.ppkwh_today - The cost in pence/kWh of the house load today accounting for the change in battery level predbat.ppkwh_hour - The cost in pence/kWh of the house load averaged over the last hour, accounting for the change in battery level","title":"Other rate entities"},{"location":"output-data/#inverter-data","text":"Some inverters store inverter settings in flash memory that can have a limited number of write cycles so Predbat counts the commands that it sends to the inverter so you can keep track of this: predbat.inverter_register_writes is the incrementing total number of writes across all inverters If you want to create a utility meter to record daily inverter register writes, add the following to your configuration.yaml (NB: the utility meter has to be defined in YAML, it cannot be configured via the HA User Interface): utility_meter: # Predbat daily inverter writes utility meter predbat_daily_inverter_writes: source: predbat.inverter_register_writes name: Predbat Daily Inverter Writes unique_id: predbat_daily_inverter_writes cycle: daily Add a card of type 'markdown' to your dashboard to display a simple dashboard of inverter writes: type: markdown content: >- {% set dd = ((as_timestamp(now()) - as_timestamp(\"2024-12-22 17:20:00\"))/86400) | int %} {% set tw = (states('predbat.inverter_register_writes') | int) %} {{ dd }} days, total {{ tw }} inverter writes {{ states('sensor.predbat_daily_inverter_writes')|int(0) }} writes today Average {{ (tw / dd ) | int(0) }} writes per day You'll need to change the hard-coded timestamp \"2024-12-12...\" to the date/time you first started counting Predbat inverter writes from to get the number of days and average writes per day correct. TIP: If your inverter is ever replaced and you want to reset the inverter register writes back to zero, simply update the entity state of predbat.inverter_register_writes using Settings / Developer Tools / States and search for the entity.","title":"Inverter data"},{"location":"output-data/#car-data","text":"binary_sensor.predbat_car_charging_slot - A binary sensor indicating when to charge your car (if car planning is enabled) - which can be used in an automation as described in Predbat led car charging . The planned attribute of the binary_sensor contains details of all planned car charging activity with start and end dates and times, kWh to charge and charging cost. Note that the start and ends are expressed in 'MM-DD HH:MM:SS\" format, use the template sensor below if you want to convert these to full date format, e.g. to display on an Apex chart predbat.car_charging_start - The time that car charging is planned to start at, in HH:MM:SS format predbat.car_soc_best - Predicted charge level of your car in the best plan at the end of the plan using the proposed car charging SoC% and charge window. Can also be charted predbat.cost_today_car - Current cost in pence so far today of charging all cars, with attribute of the projected future car charging costs and slots predbat.cost_total_car - A running total in pence of the below cost_yesterday_car sensor, with attribute of the total in pounds predbat.cost_yesterday_car - A sensor that gives the total energy costs in pence of charging all cars for yesterday (00:00-23:59 on the previous day) See Example Automation to separate car charging costs if you have multiple EV's and want to separate predbat.cost_today_car into costs per car. Template sensor to convert Predbat car charging times to full HA date format such as for displaying on an Apex chart: - unique_id: \"PredBat Car Charging Times\" - sensor: - name: \"PredBat Car Charging Times\" state: \"{{ now() }}\" attributes: planned_times: > {% set times = state_attr('binary_sensor.predbat_car_charging_slot','planned') %} {% set ns = namespace(erg = []) %} {% set delta = now().date().strftime(\"%Y\") | int %} {% for time in times %} {% set x = strptime(time.start,\"%m-%d %H:%M:%S\").replace(year=delta) %} {% set item = { \"start\": x | string } %} {% set ns.erg = ns.erg + [item] %} {% endfor %} {{ ns.erg }}","title":"Car data"},{"location":"output-data/#iboost-solar-diverter-data","text":"binary_sensor.predbat_iboost_active - A binary sensor indicating when there is excess solar and the solar diverter (e.g. iBoost, Eddi or just plain immersion heater) should be active, can be used for automations to trigger the immersion heater boost input_number.predbat_iboost_today - Gives the amount of energy modelled that will be sent to the solar diverter today, increments during the day and is reset to zero at 11:30pm each night predbat.iboost_best - Predicted energy in kWh going into the iBoost solar diverter under the best plan You can use the iboost_best sensor to create a custom template sensor that gives the time to next planned iBoost: {% set iboost_times = state_attr(\"predbat.iboost_best\",\"results\") %} {% set times = iboost_times.keys()|list %} {% set iboost_energy = iboost_times.values()|list %} {% set ni = namespace(x=0) %} {% set data = namespace(h_bool=False) %} {% set iboost_starts = \"\" %} {% for ni in range(0,times|count()-1) if data.h_bool == false %} {% if iboost_energy[ni+1]-iboost_energy[ni] > 0 %} {% set data.h_bool = true %}{{ (as_timestamp (times[ni])-as_timestamp (now()) ) / 3600 | round (0) }} {% else %} {% endif %} {% endfor %} {% if data.h_bool == false %} {{100}} {% endif %} If no iBoost is imminent then the sensor is set to 100h, and if currently boosting it will produce a small negative answer. Thanks to @mogons57 for the template sensor code.","title":"iBoost Solar Diverter data"},{"location":"output-data/#carbon-data","text":"The following sensors output by Predbat give historic and predicted carbon data. They are used in the carbon chart - see creating the Predbat charts . predbat.carbon - Predicted Carbon energy in g at the end of the plan with attributes giving the breakdown of predicted Carbon impact by half hour time slots predbat.carbon_best - Predicted Carbon intensity in g for your home under the best plan based on grid imports, grid exports and the grid's projected carbon intensity predbat.carbon_now - A sensor that gives the current Grid Carbon intensity in g/kWh predbat.carbon_today - A sensor that tracks your home's Carbon impact today in g based on your grid import minus your grid export","title":"Carbon data"},{"location":"output-data/#cost-saving-data","text":"The following sensors output by Predbat give cost-saving data that Predbat achieved, i.e. the financial benefits of using Predbat. They are used in the daily cost-saving and total cost-savings charts - see creating the Predbat charts : predbat.cost_yesterday - A sensor that gives the total energy costs in pence for yesterday (00:00-23:59 on the previous day) predbat.savings_total_actual - A running total in pence of the above cost_yesterday sensor, with attribute of the total in pounds predbat.savings_total_predbat - A running total in pence of the below savings_yesterday_predbat sensor, with attribute of the total in pounds predbat.savings_total_pvbat - A running total of the below savings_yesterday_pvbat sensor, with attribute of the total in pounds predbat.savings_total_soc - A running total of what the final SoC in kWh would have been at the end of each day if you were not using Predbat predbat.savings_yesterday_predbat - A sensor which tells you how much money Predbat saved you yesterday compared to not using Predbat, and only charging at the lowest import rate in the 24 hour period predbat.savings_yesterday_pvbat - A sensor which tells you how much money you saved from using Predbat vs not having a PV and battery system at all and all house load being met from grid import Note: The savings using Predbat are calculated by default compared to having one fixed nightly charge slot set to charge at the lowest import rate with a target of 100% You can change the number of simulated charge slots in apps.yaml by setting calculate_savings_max_charge_slots to the number of slots to allow. If set to 0 then Demand (ECO) mode will be used as the baseline or if non-zero then the maximum number of slots can be set (e.g. 2).","title":"Cost saving data"},{"location":"output-data/#solar-forecast-data","text":"The following sensors give the forecast Solar data from Solcast. Predbat populates these sensors irrespective of whether you are using the Predbat direct Solcast or Solcast integration method to get your Solar forecast, but if you are using the Solcast integration then the Predbat sensors mirror the similarly named Solcast integration sensors so could be disabled if you so wish. sensor.predbat_pv_today - Tracks the PV forecast in kWh for today, attributes give the total today, remaining amount today and the half-hourly data sensor.predbat_pv_tomorrow - Tracks the PV forecast in kWh for tomorrow, attributes give the total today, remaining amount today and the half-hourly data sensor.predbat_pv_d2 - Similar to the above, but tracking the PV forecast for the day after tomorrow sensor.predbat_pv_d3 - PV forecast for two days after tomorrow sensor.predbat_pv_forecast_h0 - Tracks the PV 'power now' forecast in Watts, attributes give the 10% and 90% power now forecast The solar sensor attributes include: total - total PV forecast for the day total10 - total PV 10% forecast for the day total90 - total PV 90% forecast for the day totalCL - total calibrated PV forecast for the day, this is the PV forecast adjusted by Predbat based on historical forecast vs generation data. The calibration should take account of shading or panel performance issues remaining/remaining10/remaining90/remainingCL - forecast solar generation for the remainder of the day detailedForecast - a half hourly breakdown of solar forecast for the day, with similar PV estimate, 10% estimate, 90% estimate and calibrated estimate values","title":"Solar forecast data"},{"location":"output-data/#dummy-inverter-sensors","text":"Predbat can now manage different inverter types, some of which don't have all the same control characteristics. Predbat might create dummy entities for control aspects that your inverter doesn't natively support. For example, for each Gen 1 hybrid inverter (N=0, 1, etc if there are multiple inverters), Predbat creates the following dummy inverter entities: sensor.predbat_ge_N_idle_end_time sensor.predbat_ge_N_idle_start_time sensor.predbat_ge_N_scheduled_discharge_enable These sensors can be ignored and excluded from the recorder history if you wish.","title":"Dummy inverter sensors"},{"location":"output-data/#alert-data","text":"sensor.predbat_alertfeed_status - Gives you data on the currently active weather alert (if configured) and in the attributes a list of all active alerts with their details","title":"Alert data"},{"location":"output-data/#predbat-logfile","text":"Predbat writes detailed logging, status and progress activity information to a logfile as it runs and so this file should be checked if predbat.status reports an error, or if you want to verify that Predbat is running OK. There is a lot of output in the logfile, this is normal! If you are using the Predbat app then the logfile can easily be viewed via the 'Log' tab of the Predbat web interface . To directly view the physical logfile, it can be found in one of three different directories in Home Assistant with slightly different filenames depending on how you installed Predbat: if you have used the Predbat app installation method , the logfile will be /addon_configs/6adb4f0d_predbat/predbat.log , if the HACS, Appdaemon app then Predbat installation method , it's /homeassistant/appdaemon/appdaemon.log , or if the combined AppDaemon/Predbat app installation method was used, it's /addon_configs/46f69597_appdaemon-predbat/predbat.log . You will need to use a file editor within Home Assistant (e.g. either the File editor or Studio Code Server apps) to view Predbat's logfile if you are not using the Predbat app. See editing configuration files within Home Assistant if you need to install an editor.","title":"Predbat Logfile"},{"location":"output-data/#automated-monitoring-that-predbat-and-givtcp-are-running-ok","text":"With Predbat performing an important function, managing your battery charging and discharging to best reduce your electricity bills, you may find these automations useful to monitor that everything is running OK, and if not, to try restarting the failing app, and raise an alert on your mobile device running the Home Assistant Companion app. Two monitors are provided, one for Predbat and one for GivTCP (for GivEnergy inverters). Both monitors are written on the basis that Predbat/GivTCP are running as apps within the Home Assistant Supervisor. If you are running Predbat within Docker then the automation won't work as written. The GivTCP monitor is for use with a GivEnergy inverter, if you have a different inverter type then you may be able to use the GivTCP monitor as a basis for developing a similar inverter-specific error detection automation for your inverter. To create a new automation: Settings / Automations & Scenes Create Automation / Create new Automation Three dots (top right corner) / Edit in YAML Delete the existing (template) automation code and copy/paste the supplied automation code below","title":"Automated monitoring that Predbat and GivTCP are running OK"},{"location":"output-data/#givtcp-activity-monitor","text":"This automation will raise an alert if any of the following occur: The inverter goes offline for more than 15 minutes No last_updated_time received from the inverter for more than 15 minutes Inverter temperature less than 5 degrees for more than 15 minutes (should never happen) The battery goes offline to the inverter for more than 15 minutes GivTCP app is not running Mosquitto broker app is not running The script will need to be customised for your inverter ID, battery ID and mobile details, and can be extended for multiple inverters and batteries by duplicating the triggers and adding appropriate battery and inverter IDs. alias: GivTCP activity monitor description: Alert when communications to GivTCP have ceased for 15 minutes triggers: - trigger: state entity_id: sensor.givtcp_<inverter id>_last_updated_time to: \"null\" for: minutes: 15 variables: alert_text: No GivTCP update received from inverter <id> restart_app: GivTCP - trigger: state entity_id: - sensor.givtcp_<inverter id>_status from: online for: minutes: 15 variables: alert_text: No GivTCP update received from inverter <id> restart_app: GivTCP - trigger: numeric_state entity_id: - sensor.givtcp_<inverter id>_invertor_temperature for: minutes: 15 below: 10 variables: alert_text: No GivTCP update received from inverter <id> restart_app: GivTCP - trigger: state entity_id: - sensor.givtcp_<battery id>_battery_cells to: unknown for: minutes: 15 variables: alert_text: Battery <battery_id> is offline to GivTCP restart_app: GivTCP - trigger: state entity_id: - binary_sensor.givtcp_running to: \"off\" for: minutes: 15 variables: alert_text: GivTCP app is not running restart_app: GivTCP - trigger: state entity_id: - binary_sensor.mosquitto_broker_running to: \"off\" for: minutes: 15 variables: alert_text: Mosquitto Broker app is not running restart_app: Mosquitto actions: - action: notify.mobile_app_<your mobile device id> alias: Send a notification data: title: GivTCP communication issue message: | {{now().strftime('%-d %b %H:%M')}} ISSUE: {{ alert_text }} for the past 15 minutes, restarting {{ restart_app }} data: visibility: public persistent: true push: sound: name: default critical: 1 volume: 0.8 sticky: true color: red - choose: - conditions: - condition: template value_template: \"{{ restart_app == 'GivTCP' }}\" sequence: - alias: Restart GivTCP app action: hassio.addon_restart data: addon: 533ea71a_givtcp - conditions: - condition: template value_template: \"{{ restart_app == 'Mosquitto' }}\" sequence: - alias: Restart Mosquitto app action: hassio.addon_restart data: addon: core_mosquitto trace: stored_traces: 20 mode: single The last two triggers (GivTCP and Mosquitto running) trigger if any of these apps that Predbat is dependent upon are not running. You will need to enable a binary sensor for each app to be able to use these triggers in the automation: Navigate to Settings / Devices and Services / Devices and search for 'GivTCP' Click on the GivTCP app, and under 'Sensors', click 'XX entities not shown' Click the 'Running' sensor, then the cogwheel, and Enable the sensor Repeat these steps for the 'Mosquitto' app. As an extension to the above, if you don't want the automation to restart the failing app and instead just send an alert that there is a problem, delete the 'choose' code above. Restarting GivTCP does however lose the current GivTCP log-in Home Assistant. NB: If you are using GivTCP v2 rather than v3, replace the '533ea71a_givtcp' with 'a6a2857d_givtcp'.","title":"GivTCP Activity Monitor"},{"location":"output-data/#predbat-error-monitor","text":"This automation will raise an alert if Predbat's status turns to Error for more than 5 minutes. In normal operation, Predbat will automatically run and update its plan and forecast every 5 minutes. If the automation detects that Predbat has not done this for 20 minutes, then an alert will be raised and the automation will restart the Predbat app to try to resolve a 'hung Predbat' issue. In the same way for the GivTCP and Mosquitto apps above, the last trigger requires you to enable a binary sensor that detects that the Predbat/AppDaemon app is running. Follow the same steps to enable the binary sensor for either the 'Predbat' or (deprecated) 'AppDaemon' app depending on which Predbat installation method you followed. The script will need to be customised for your mobile details. alias: Predbat error monitor description: Alert when Predbat has raised an exception trace: stored_traces: 50 triggers: - trigger: template alias: Predbat status contains 'Error' for 10 minutes value_template: \"{{ 'Error' in states('predbat.status') }}\" for: minutes: 10 variables: alert_text: >- Predbat status is {{ states('predbat.status') }}, error={{ state_attr('predbat.status', 'error') }} - trigger: state alias: Predbat is in error status for 10 minutes entity_id: predbat.status attribute: error to: \"true\" for: minutes: 10 variables: alert_text: >- Predbat status is {{ states('predbat.status') }}, error={{ state_attr('predbat.status', 'error') }} - trigger: state alias: Predbat status.last_updated has not changed for 20 minutes entity_id: predbat.status attribute: last_updated for: minutes: 20 variables: alert_text: >- Predbat last_updated=' {{ state_attr('predbat.status','last_updated')|as_timestamp|timestamp_custom('%a %H:%M') }}', unchanged for 20 mins; Status='{{ states('predbat.status') }}', restarting restart_predbat: \"Y\" - trigger: state alias: Predbat app not running for 15 minutes entity_id: binary_sensor.predbat_running to: \"off\" for: minutes: 15 variables: alert_text: Predbat app is not running, restarting restart_predbat: \"Y\" - trigger: state alias: predbat_active stuck on for 20 minutes entity_id: - switch.predbat_active for: minutes: 20 variables: alert_text: Predbat active has been stuck on (updating the plan) for 20 minutes, restarting restart_predbat: \"Y\" - trigger: template alias: Predbat entities not populated for 20 minutes value_template: \"{{ states('predbat.plan_html') == 'unknown' }}\" for: minutes: 20 variables: alert_text: >- Predbat plan is unknown for 20 minutes, possibly failed on startup, restarting restart_predbat: \"Y\" - alias: \"Heartbeat: check Predbat has populated output entities OK\" trigger: time_pattern minutes: /30 id: heartbeat actions: - alias: Heartbeat, check Predbat output variables are populated if: - condition: trigger id: - heartbeat then: - if: - condition: template value_template: \"{{states('predbat.plan_html') == 'unknown' }}\" then: - variables: alert_text: >- Predbat has not populated its output entities, possibly failed on startup, restarting restart_predbat: \"Y\" else: - stop: \"Heartbeat check: Predbat plan is populated, all is OK\" - action: notify.mobile_app_<your mobile device id> alias: Send alert message data: title: Predbat status issue message: | {{now().strftime('%-d %b %H:%M')}} ISSUE: {{ alert_text }} data: visibility: public persistent: true push: sound: name: default critical: 1 volume: 0.8 sticky: true color: red - if: - condition: template value_template: \"{{ restart_predbat == 'Y' }}\" then: - action: hassio.addon_restart data: addon: 6adb4f0d_predbat alias: Restart Predbat app mode: single NB: If you are using AppDaemon rather than the Predbat app, replace '6adb4f0d_predbat' with 'a0d7b954_appdaemon' and change 'binary_sensor.predbat_running' to 'binary_sensor.appdaemon_running'. An error alert looks like this:","title":"Predbat Error Monitor"},{"location":"plugins/","text":"\ud83d\ude80 Feature: Plugin System Implementation Summary Core Plugin System ( plugin_system.py ) Auto-discovery : Automatically finds and loads plugins from multiple directories ( plugins/ , same directory, parent directory) Flexible plugin detection : Supports multiple plugin patterns (classes ending in 'Plugin'', PREDBAT_PLUGIN marker, initialize_plugin() function) Lifecycle hooks : Provides four key integration points: on_init : Called when plugin system initializes on_update : Called during each update cycle on_shutdown : Called during graceful shutdown on_web_start : Called when web interface starts Error resilience : Continues loading other plugins even if one fails Base class : Optional PredBatPlugin base class for standardized plugin development Integration Points Main application : Plugin system initializes after web interface startup and calls update hooks during each cycle Web interface : New endpoint registration system allows plugins to add custom HTTP endpoints dynamically Graceful shutdown : Ensures all plugins are properly cleaned up \ud83d\udd27 Technical Details Plugin files must end with _plugin.py for auto-discovery Plugins can be simple classes, inherit from PredBatPlugin , or use initialization functions Web endpoints can be registered by plugins for custom interfaces (e.g., metrics endpoints) Full error handling and logging throughout the plugin lifecycle No breaking changes to existing functionality \ud83c\udfaf Use Cases This plugin system enables: Custom metrics collection (Prometheus, InfluxDB, etc.) Additional web interfaces and dashboards Third-party integrations without modifying core code Custom notification systems Extended data processing and analysis \ud83e\uddea Backward Compatibility Fully backward compatible - no changes to existing functionality Plugin system is optional and gracefully handles failures Existing code continues to work unchanged","title":"\ud83d\ude80 Feature: Plugin System Implementation"},{"location":"plugins/#feature-plugin-system-implementation","text":"","title":"\ud83d\ude80 Feature: Plugin System Implementation"},{"location":"plugins/#summary","text":"Core Plugin System ( plugin_system.py ) Auto-discovery : Automatically finds and loads plugins from multiple directories ( plugins/ , same directory, parent directory) Flexible plugin detection : Supports multiple plugin patterns (classes ending in 'Plugin'', PREDBAT_PLUGIN marker, initialize_plugin() function) Lifecycle hooks : Provides four key integration points: on_init : Called when plugin system initializes on_update : Called during each update cycle on_shutdown : Called during graceful shutdown on_web_start : Called when web interface starts Error resilience : Continues loading other plugins even if one fails Base class : Optional PredBatPlugin base class for standardized plugin development Integration Points Main application : Plugin system initializes after web interface startup and calls update hooks during each cycle Web interface : New endpoint registration system allows plugins to add custom HTTP endpoints dynamically Graceful shutdown : Ensures all plugins are properly cleaned up","title":"Summary"},{"location":"plugins/#technical-details","text":"Plugin files must end with _plugin.py for auto-discovery Plugins can be simple classes, inherit from PredBatPlugin , or use initialization functions Web endpoints can be registered by plugins for custom interfaces (e.g., metrics endpoints) Full error handling and logging throughout the plugin lifecycle No breaking changes to existing functionality","title":"\ud83d\udd27 Technical Details"},{"location":"plugins/#use-cases","text":"This plugin system enables: Custom metrics collection (Prometheus, InfluxDB, etc.) Additional web interfaces and dashboards Third-party integrations without modifying core code Custom notification systems Extended data processing and analysis","title":"\ud83c\udfaf Use Cases"},{"location":"plugins/#backward-compatibility","text":"Fully backward compatible - no changes to existing functionality Plugin system is optional and gracefully handles failures Existing code continues to work unchanged","title":"\ud83e\uddea Backward Compatibility"},{"location":"predbat-plan-card/","text":"Predbat Plan card Predbat can create its own plan card which can be added to your Home Assistant dashboard. At a glance, the Predbat plan shows you the plan going forward for home demand, EV charging, iBoost and your battery, and any actions that Predbat is planning to take. Displaying the Predbat plan Firstly install the HTML template card in HACS: In HACS, click on Frontend Click the blue Explore and download repositories button and type 'HTML' Click on 'HTML Jinja2 Template card', then click the blue 'Download', then 'Download' again to install it When prompted to 'reload your browser', click 'Reload' NB: Do not install the very similarly named 'Lovelace Html card', it won't work! You must install the 'HTML Jinja2 Template card'. Next, on a Home Assistant dashboard, click the blue 'Add card', scroll down the list of cards to the bottom and click 'Manual', delete the template card configuration and copy/paste the following to display the Predbat plan: type: custom:html-template-card title: Predbat plan ignore_line_breaks: true content: | {{ state_attr('predbat.plan_html', 'html') }} You should see something like this: If you get an error 'Custom element doesn't exist: html-template-card' then you've not installed the Jinja2 template card correctly from HACS. Understanding the Predbat plan For every period (slot) that Predbat has planned for (the forecast_hours setting in apps.yaml ), the Predbat plan shows: The import rate in pence for that slot The export rate in pence for that slot What 'status' Predbat will be in (e.g. Charging, Discharging) Any limit applied (e.g. charging to 70%) Forecast Solar generation (from Solcast) Forecast house load (from your historical load data) Planned car charging (if car charging is configured in Predbat) Planned iBoost immersion heating (if iBoost is configured) What the battery SoC will be at the start of the slot The forecast cost for the half-hour slot A running total cost Forecast CO2 Carbon intensity and Carbon footprint emitted by the grid's electricity generation, and the direction of travel over the slot (if carbon forecasting is enabled) Rate symbols (import and export): ? \u2146 - Rate that has been modified based on input_number.predbat_metric_future_rate_offset_import or input_number.predbat_metric_future_rate_offset_export ? \u2696 - Rate that has been estimated using future rate estimation data (e.g. Nordpool) = - Rate that has been overridden by the user's apps.yaml \u00b1 - Rate that has been adjusted with a rate offset in the user's apps.yaml $ - Rate that has been adjusted for an Octopus Saving session ? - Rate that has not yet been defined and the previous day's data was used instead Battery SoC symbols: \u2192 - Current SoC expected to remain level \u2198 - Current SoC expected to fall \u2197 - Current SoC expected to rise Cost symbols: \u2192 - Current cost expected to remain level \u2198 - Current cost expected to fall (due to export) \u2197 - Current cost expected to rise (due to import or standing charge) Explaining each column in the Predbat plan in more detail: Time - Predbat plans your home, solar and battery load in (by default) 30-minute slots, on the :00 and :30 minutes past each hour. The Predbat slots are therefore aligned to Octopus Agile slots or rate change times on any other tariff. The slot length defaults to being 30 minutes long, but can be changed by setting plan_interval_minutes in apps.yaml . Import - The import rate for that time slot in pence. The rate will be coloured Blue if the price is zero pence or negative, Green if the rate is less than the import rate threshold, Red if the rate is more than 1.5 times the import rate threshold, and Yellow if the rate is between 1 and 1.5 times the import rate threshold. See the Predbat customisation guide for an explanation of the import rate threshold (and overriding it), but in essence Predbat will consider blue and green-coloured slots as preferred candidates for importing, yellow and red (higher rates) will not. If battery charging is planned by Predbat for a particular slot, the import rate for that slot will be highlighted in bold text. Export - Similarly, the export rate for that time slot in pence. The rate will be coloured White if the price is less than the export rate threshold, Yellow if it is more than the export rate threshold, and pale Red if the rate is more than 1.5 times the export rate threshold. So in essence, Yellow and Red coloured export rates will be considered as priorities for exporting, and White will not. If battery discharging is planned by Predbat for a particular slot, the export rate for that slot will be highlighted in bold text. State - Predbat's status controls whether the battery is charging, discharging to support house load (Demand mode), discharging and force exported, or being held at the current level. Alongside the state is an arrow which points upwards if the battery SoC is increasing (i.e. charging), to the right if the battery SoC remains constant, or downwards if the battery SoC is decreasing (i.e. discharging). If Predbat's plan has been over-ridden and the slot has been manually controlled to be a Charging slot, Discharging or Idle, then alongside the State and battery SoC arrow will be an upside down 'F' (\u214e) indicating it is a 'Forced' activity. The slot will be coloured Green for Charging, Yellow for Discharging, Silver Grey for Freeze Charging, Dark Grey for Freeze Discharging, Pale Blue for Hold Charging or White for Idle. NB: The Predbat plan is shown in (by default) 30-minute time slots, but Predbat actually plans battery activity in 5-minute segments within the slot. If the Home Assistant control switch.predbat_calculate_export_oncharge is set to True, then within a slot (and depending on import and export rates), Predbat could potentially plan for there to be both charging and discharging activity - if Predbat plans this, the state will show as both Charging and Exporting in the same slot. Limit % - Alongside any battery activity (charging, discharging, etc) there will be a SoC limit. This limit is what the SoC is planned to be at the end of the slot. e.g. 'Charge\u2197 70%' is charge to 70% SoC, and 'Exp\u2198 4%' is force exporting the battery to the 4% reserve level. If Predbat is planning a slow charge or slow export then the limit will be preceded by a snail symbol (\ud83d\udc0c) and will be shown as 'limit.tens_of_percentage_rate_reduction'. e.g.: 16.3 means limit of 16% and charge/discharge at 70% of normal rate. PV kWh - The predicted solar forecast for the half-hour slot, estimated from the Solcast Forecast . If the PV forecast is above 0.2kWh for the slot it will be coloured Melon Red with a little sun symbol, above 0.1kWh it will be Yellow with a sun symbol, otherwise, it will be Silver-Grey. Load kWh - The predicted house load for the half-hour slot, estimated as a weighted average of the number of days_previous Historical data from your inverter or other house load sensor. If the load forecast is 0.5kWh or above for the slot it will be coloured Orangey-Red, from 0.25kWh to 0.5 it will be coloured Yellow, above 0 to 0.25, it will be Light Green, and if zero, it will be coloured White. Clip kWh - (Only shown if switch.predbat_plan_debug is turned on), shows the total amount of energy predicted to be lost due to clipping either due to your inverter not being able to handle all the PV that has been generated (due to lack of AC capacity or DC charging), or due to an export limit being set. If the amount of solar clipping predicted to occur in that slot is more than 0.1kWh then the kWh will be coloured Orange, if its more than 0.01kWh it will be coloured Yellow, otherwise, it will be White. Xload kWh - (Only shown if switch.predbat_plan_debug is turned on), shows the load that was added externally to Predbat with load_forecast settings, this might come from PredAI, PredHeat or other sources depending on your configuration. Car kWh - The total predicted car charging for the half-hour slot. This column will only be shown if num_cars in apps.yaml is 1 or more. If the car is planned to be charged in that slot then the kWh will be coloured Yellow, otherwise, it will be White. iBoost kWh - The energy planned for solar diverter immersion heating such as iBoost or MyEnergi Eddi. This column will only be shown if switch.predbat_iboost_enable is set to True. If the solar diverter is planned to be on in that slot then the kWh will be coloured Yellow, otherwise it will be White. SoC % - The estimate of battery State of Charge percentage at the start of the time slot together with an arrow pointing up, to the right or downwards to indicate whether the battery SoC is increasing, remaining constant or decreasing during the time slot. The 'SoC %' can be read in conjunction with the 'Limit %'; the SoC column gives the estimated SoC at the beginning of the slot, the Limit column the estimated SoC at the end of the slot. If the SoC is 50% or greater it will be coloured Green, 20% or greater, Yellow, and if less than 20%, Orangey-Red. Cost - The estimated cost in pence for the time slot together with an arrow indicating whether the total cost today is increasing, staying flat or decreasing. If the cost for the slot is 10p or more it will be coloured Orangey-Red, \u00bdp or more it will be coloured Yellow, -\u00bdp or less it will be coloured Green, otherwise, it will be coloured White. Total - The total cumulative cost so far for 'today' at the start of the slot, including the standing charge. At midnight tonight this cumulative cost will be reset to the daily standing charge (or zero if metric_standing_charge wasn't set in apps.yaml ). Due to the way Predbat works, the total cost is always reported (in Predbat output entities, this HTML plan, in the Apex charts , etc) as starting from midnight today and adding on from there. Looking at the sample Predbat plan above as an example, the plan starts at 10:00 with the total cost today already being \u00a33.13. The house load is then fully met through the day and evening by the battery (with some PV top-up charging) so the total cost remains constant at \u00a33.13. In the 22:30 and 23:00 slots there is a little grid import, and then at 23:30 there's grid import and the battery starts to be charged. As you can see the Total continues to increase in the plan past midnight with each Total being the Total from the preceding slot plus the Cost estimate from the preceding slot - a reminder that Total gives the running total at the start of the slot. The total cost is always coloured White. CO2 (g/kWh) - The estimated CO2 Carbon intensity emitted by the grid when generating electricity at the start of the slot. This column will only be shown if switch.predbat_carbon_enable is set to True. The CO2 value will be coloured according to how high the carbon footprint intensity is: greater or equal to 450g/kWh it will be deep red; greater or equal to 290, dark red; then golden orange from 200 upwards; yellow from 120; green from 40 and light green if less than 40. CO2 (kg) - The estimated CO2 Carbon footprint that the grid will emit generating electricity at the start of the slot and the direction of travel over the slot. This column will only be shown if switch.predbat_carbon_enable is set to True. The carbon amount in kg will be coloured according to the direction of travel over the slot; if the carbon value rises by 10kg or more it will be orange with an upward arrow; if falling by 10kg or more it will be green with a downwards arrow, and in the middle, white with a horizontal arrow. Debug mode for Predbat Plan If Predbat expert mode is turned on then a number of additional controls and switches are made available in Home Assistant. If switch.predbat_plan_debug is then turned on then the Predbat plan shows additional 'debugging' information for the import rate, export rate, load and PV columns, and the clip kWh column described above. The Predbat plan will now look like this with plan_debug turned on: Import and Export rates will now show the actual rate (according to how you have set up the energy rates ) and also in brackets the effective import or export rate. The effective rate takes into account battery and inverter energy losses for charging and discharging and converting from DC to AC and vice-versa. Note that the Cost and Total columns are always based on the actual Import and Export rate. Using the above debug plan as an example: At 22:30 the battery is being charged. The actual import rate is 14.07p, but after conversion losses to store the grid AC into the DC battery, the energy being put into the battery has effectively cost 14.81p - for every 1kWh of AC grid import you don't get 1kWh of DC stored in the battery, so 1kWh of battery charge has effectively cost slightly more than the import rate. At 00:30 the battery is being force exported and excess energy (above the estimated house load of 0.47kWh) will be exported. The actual export rate is 18.22p but after losses converting the stored DC battery charge into AC to supply the home and export it, the energy being exported has effectively only earned 17.31p - it will take slightly more than 1kWh of stored DC battery charge to get 1kWh of AC to use or export so each discharged and exported kWh earns slightly less. Putting these together, at 00:00, the effective import rate (after losses) is 13.93p, the effective export rate is 17.31p, so even though battery and inverter conversion losses have been incurred, there is still a 3.38p profit per kWh and Predbat plans to charge and then export the battery in the same slot to generate that profit. With debug mode turned on, the Load column shows the predicted load in kWh for the half-hour slot and in brackets the modelled load variance value using the load variance model . The PV column in debug mode changes shows the predicted PV generation in kWh for the half-hour slot and the Solcast 10% forecast in brackets. Note that Predbat's forecasted PV generation already contains a input_number.predbat_pv_metric10_weight weighted value of the Solcast 10% forecast . Note that the values in brackets in the load and PV columns are each only shown if they are non-zero. The debug mode on the Predbat plan can be quite useful to understand from the import and export rates after conversion losses , why Predbat plans to charge or force export the battery. There's a further explanation of the Predbat forecast and plan in the FAQ's. Customising and Reformatting the Predbat Plan An additional independent front-end Home Assistant component the 'Predbat Table Card' is available on HACS that gives a number of additional customisation and configuration options to tailor how the Predbat plan looks and is highly recommended if you want to change the standard plan look and feel: Change the sequence of columns and which columns are shown in the plan Restyle the columns, or retain the Predbat original colour scheme Easily change Predbat's planned activity for a slot by clicking on the slot time, then selecting Demand, Charge, Export, Freeze Charge or Freeze Export Apply custom light/dark themes Show the weather forecast alongside the plan Display different columns for different screen widths, e.g. less detail on a phone, more on a tablet/PC See the Predbat Table Card repository for more details. PV Prediction summary The same author of the Predbat Table Card has produced a nice visualisation for the Solar Forecast for the next few days: See the PV Card Preview repository","title":"Predbat Plan card"},{"location":"predbat-plan-card/#predbat-plan-card","text":"Predbat can create its own plan card which can be added to your Home Assistant dashboard. At a glance, the Predbat plan shows you the plan going forward for home demand, EV charging, iBoost and your battery, and any actions that Predbat is planning to take.","title":"Predbat Plan card"},{"location":"predbat-plan-card/#displaying-the-predbat-plan","text":"Firstly install the HTML template card in HACS: In HACS, click on Frontend Click the blue Explore and download repositories button and type 'HTML' Click on 'HTML Jinja2 Template card', then click the blue 'Download', then 'Download' again to install it When prompted to 'reload your browser', click 'Reload' NB: Do not install the very similarly named 'Lovelace Html card', it won't work! You must install the 'HTML Jinja2 Template card'. Next, on a Home Assistant dashboard, click the blue 'Add card', scroll down the list of cards to the bottom and click 'Manual', delete the template card configuration and copy/paste the following to display the Predbat plan: type: custom:html-template-card title: Predbat plan ignore_line_breaks: true content: | {{ state_attr('predbat.plan_html', 'html') }} You should see something like this: If you get an error 'Custom element doesn't exist: html-template-card' then you've not installed the Jinja2 template card correctly from HACS.","title":"Displaying the Predbat plan"},{"location":"predbat-plan-card/#understanding-the-predbat-plan","text":"For every period (slot) that Predbat has planned for (the forecast_hours setting in apps.yaml ), the Predbat plan shows: The import rate in pence for that slot The export rate in pence for that slot What 'status' Predbat will be in (e.g. Charging, Discharging) Any limit applied (e.g. charging to 70%) Forecast Solar generation (from Solcast) Forecast house load (from your historical load data) Planned car charging (if car charging is configured in Predbat) Planned iBoost immersion heating (if iBoost is configured) What the battery SoC will be at the start of the slot The forecast cost for the half-hour slot A running total cost Forecast CO2 Carbon intensity and Carbon footprint emitted by the grid's electricity generation, and the direction of travel over the slot (if carbon forecasting is enabled) Rate symbols (import and export): ? \u2146 - Rate that has been modified based on input_number.predbat_metric_future_rate_offset_import or input_number.predbat_metric_future_rate_offset_export ? \u2696 - Rate that has been estimated using future rate estimation data (e.g. Nordpool) = - Rate that has been overridden by the user's apps.yaml \u00b1 - Rate that has been adjusted with a rate offset in the user's apps.yaml $ - Rate that has been adjusted for an Octopus Saving session ? - Rate that has not yet been defined and the previous day's data was used instead Battery SoC symbols: \u2192 - Current SoC expected to remain level \u2198 - Current SoC expected to fall \u2197 - Current SoC expected to rise Cost symbols: \u2192 - Current cost expected to remain level \u2198 - Current cost expected to fall (due to export) \u2197 - Current cost expected to rise (due to import or standing charge) Explaining each column in the Predbat plan in more detail: Time - Predbat plans your home, solar and battery load in (by default) 30-minute slots, on the :00 and :30 minutes past each hour. The Predbat slots are therefore aligned to Octopus Agile slots or rate change times on any other tariff. The slot length defaults to being 30 minutes long, but can be changed by setting plan_interval_minutes in apps.yaml . Import - The import rate for that time slot in pence. The rate will be coloured Blue if the price is zero pence or negative, Green if the rate is less than the import rate threshold, Red if the rate is more than 1.5 times the import rate threshold, and Yellow if the rate is between 1 and 1.5 times the import rate threshold. See the Predbat customisation guide for an explanation of the import rate threshold (and overriding it), but in essence Predbat will consider blue and green-coloured slots as preferred candidates for importing, yellow and red (higher rates) will not. If battery charging is planned by Predbat for a particular slot, the import rate for that slot will be highlighted in bold text. Export - Similarly, the export rate for that time slot in pence. The rate will be coloured White if the price is less than the export rate threshold, Yellow if it is more than the export rate threshold, and pale Red if the rate is more than 1.5 times the export rate threshold. So in essence, Yellow and Red coloured export rates will be considered as priorities for exporting, and White will not. If battery discharging is planned by Predbat for a particular slot, the export rate for that slot will be highlighted in bold text. State - Predbat's status controls whether the battery is charging, discharging to support house load (Demand mode), discharging and force exported, or being held at the current level. Alongside the state is an arrow which points upwards if the battery SoC is increasing (i.e. charging), to the right if the battery SoC remains constant, or downwards if the battery SoC is decreasing (i.e. discharging). If Predbat's plan has been over-ridden and the slot has been manually controlled to be a Charging slot, Discharging or Idle, then alongside the State and battery SoC arrow will be an upside down 'F' (\u214e) indicating it is a 'Forced' activity. The slot will be coloured Green for Charging, Yellow for Discharging, Silver Grey for Freeze Charging, Dark Grey for Freeze Discharging, Pale Blue for Hold Charging or White for Idle. NB: The Predbat plan is shown in (by default) 30-minute time slots, but Predbat actually plans battery activity in 5-minute segments within the slot. If the Home Assistant control switch.predbat_calculate_export_oncharge is set to True, then within a slot (and depending on import and export rates), Predbat could potentially plan for there to be both charging and discharging activity - if Predbat plans this, the state will show as both Charging and Exporting in the same slot. Limit % - Alongside any battery activity (charging, discharging, etc) there will be a SoC limit. This limit is what the SoC is planned to be at the end of the slot. e.g. 'Charge\u2197 70%' is charge to 70% SoC, and 'Exp\u2198 4%' is force exporting the battery to the 4% reserve level. If Predbat is planning a slow charge or slow export then the limit will be preceded by a snail symbol (\ud83d\udc0c) and will be shown as 'limit.tens_of_percentage_rate_reduction'. e.g.: 16.3 means limit of 16% and charge/discharge at 70% of normal rate. PV kWh - The predicted solar forecast for the half-hour slot, estimated from the Solcast Forecast . If the PV forecast is above 0.2kWh for the slot it will be coloured Melon Red with a little sun symbol, above 0.1kWh it will be Yellow with a sun symbol, otherwise, it will be Silver-Grey. Load kWh - The predicted house load for the half-hour slot, estimated as a weighted average of the number of days_previous Historical data from your inverter or other house load sensor. If the load forecast is 0.5kWh or above for the slot it will be coloured Orangey-Red, from 0.25kWh to 0.5 it will be coloured Yellow, above 0 to 0.25, it will be Light Green, and if zero, it will be coloured White. Clip kWh - (Only shown if switch.predbat_plan_debug is turned on), shows the total amount of energy predicted to be lost due to clipping either due to your inverter not being able to handle all the PV that has been generated (due to lack of AC capacity or DC charging), or due to an export limit being set. If the amount of solar clipping predicted to occur in that slot is more than 0.1kWh then the kWh will be coloured Orange, if its more than 0.01kWh it will be coloured Yellow, otherwise, it will be White. Xload kWh - (Only shown if switch.predbat_plan_debug is turned on), shows the load that was added externally to Predbat with load_forecast settings, this might come from PredAI, PredHeat or other sources depending on your configuration. Car kWh - The total predicted car charging for the half-hour slot. This column will only be shown if num_cars in apps.yaml is 1 or more. If the car is planned to be charged in that slot then the kWh will be coloured Yellow, otherwise, it will be White. iBoost kWh - The energy planned for solar diverter immersion heating such as iBoost or MyEnergi Eddi. This column will only be shown if switch.predbat_iboost_enable is set to True. If the solar diverter is planned to be on in that slot then the kWh will be coloured Yellow, otherwise it will be White. SoC % - The estimate of battery State of Charge percentage at the start of the time slot together with an arrow pointing up, to the right or downwards to indicate whether the battery SoC is increasing, remaining constant or decreasing during the time slot. The 'SoC %' can be read in conjunction with the 'Limit %'; the SoC column gives the estimated SoC at the beginning of the slot, the Limit column the estimated SoC at the end of the slot. If the SoC is 50% or greater it will be coloured Green, 20% or greater, Yellow, and if less than 20%, Orangey-Red. Cost - The estimated cost in pence for the time slot together with an arrow indicating whether the total cost today is increasing, staying flat or decreasing. If the cost for the slot is 10p or more it will be coloured Orangey-Red, \u00bdp or more it will be coloured Yellow, -\u00bdp or less it will be coloured Green, otherwise, it will be coloured White. Total - The total cumulative cost so far for 'today' at the start of the slot, including the standing charge. At midnight tonight this cumulative cost will be reset to the daily standing charge (or zero if metric_standing_charge wasn't set in apps.yaml ). Due to the way Predbat works, the total cost is always reported (in Predbat output entities, this HTML plan, in the Apex charts , etc) as starting from midnight today and adding on from there. Looking at the sample Predbat plan above as an example, the plan starts at 10:00 with the total cost today already being \u00a33.13. The house load is then fully met through the day and evening by the battery (with some PV top-up charging) so the total cost remains constant at \u00a33.13. In the 22:30 and 23:00 slots there is a little grid import, and then at 23:30 there's grid import and the battery starts to be charged. As you can see the Total continues to increase in the plan past midnight with each Total being the Total from the preceding slot plus the Cost estimate from the preceding slot - a reminder that Total gives the running total at the start of the slot. The total cost is always coloured White. CO2 (g/kWh) - The estimated CO2 Carbon intensity emitted by the grid when generating electricity at the start of the slot. This column will only be shown if switch.predbat_carbon_enable is set to True. The CO2 value will be coloured according to how high the carbon footprint intensity is: greater or equal to 450g/kWh it will be deep red; greater or equal to 290, dark red; then golden orange from 200 upwards; yellow from 120; green from 40 and light green if less than 40. CO2 (kg) - The estimated CO2 Carbon footprint that the grid will emit generating electricity at the start of the slot and the direction of travel over the slot. This column will only be shown if switch.predbat_carbon_enable is set to True. The carbon amount in kg will be coloured according to the direction of travel over the slot; if the carbon value rises by 10kg or more it will be orange with an upward arrow; if falling by 10kg or more it will be green with a downwards arrow, and in the middle, white with a horizontal arrow.","title":"Understanding the Predbat plan"},{"location":"predbat-plan-card/#debug-mode-for-predbat-plan","text":"If Predbat expert mode is turned on then a number of additional controls and switches are made available in Home Assistant. If switch.predbat_plan_debug is then turned on then the Predbat plan shows additional 'debugging' information for the import rate, export rate, load and PV columns, and the clip kWh column described above. The Predbat plan will now look like this with plan_debug turned on: Import and Export rates will now show the actual rate (according to how you have set up the energy rates ) and also in brackets the effective import or export rate. The effective rate takes into account battery and inverter energy losses for charging and discharging and converting from DC to AC and vice-versa. Note that the Cost and Total columns are always based on the actual Import and Export rate. Using the above debug plan as an example: At 22:30 the battery is being charged. The actual import rate is 14.07p, but after conversion losses to store the grid AC into the DC battery, the energy being put into the battery has effectively cost 14.81p - for every 1kWh of AC grid import you don't get 1kWh of DC stored in the battery, so 1kWh of battery charge has effectively cost slightly more than the import rate. At 00:30 the battery is being force exported and excess energy (above the estimated house load of 0.47kWh) will be exported. The actual export rate is 18.22p but after losses converting the stored DC battery charge into AC to supply the home and export it, the energy being exported has effectively only earned 17.31p - it will take slightly more than 1kWh of stored DC battery charge to get 1kWh of AC to use or export so each discharged and exported kWh earns slightly less. Putting these together, at 00:00, the effective import rate (after losses) is 13.93p, the effective export rate is 17.31p, so even though battery and inverter conversion losses have been incurred, there is still a 3.38p profit per kWh and Predbat plans to charge and then export the battery in the same slot to generate that profit. With debug mode turned on, the Load column shows the predicted load in kWh for the half-hour slot and in brackets the modelled load variance value using the load variance model . The PV column in debug mode changes shows the predicted PV generation in kWh for the half-hour slot and the Solcast 10% forecast in brackets. Note that Predbat's forecasted PV generation already contains a input_number.predbat_pv_metric10_weight weighted value of the Solcast 10% forecast . Note that the values in brackets in the load and PV columns are each only shown if they are non-zero. The debug mode on the Predbat plan can be quite useful to understand from the import and export rates after conversion losses , why Predbat plans to charge or force export the battery. There's a further explanation of the Predbat forecast and plan in the FAQ's.","title":"Debug mode for Predbat Plan"},{"location":"predbat-plan-card/#customising-and-reformatting-the-predbat-plan","text":"An additional independent front-end Home Assistant component the 'Predbat Table Card' is available on HACS that gives a number of additional customisation and configuration options to tailor how the Predbat plan looks and is highly recommended if you want to change the standard plan look and feel: Change the sequence of columns and which columns are shown in the plan Restyle the columns, or retain the Predbat original colour scheme Easily change Predbat's planned activity for a slot by clicking on the slot time, then selecting Demand, Charge, Export, Freeze Charge or Freeze Export Apply custom light/dark themes Show the weather forecast alongside the plan Display different columns for different screen widths, e.g. less detail on a phone, more on a tablet/PC See the Predbat Table Card repository for more details.","title":"Customising and Reformatting the Predbat Plan"},{"location":"predbat-plan-card/#pv-prediction-summary","text":"The same author of the Predbat Table Card has produced a nice visualisation for the Solar Forecast for the next few days: See the PV Card Preview repository","title":"PV Prediction summary"},{"location":"predheat/","text":"Predheat Predheat attempts to model water-based central heating systems based on a boiler or a heat pump. Further details can be found in the Predheat YouTube video Operation The app runs every 5 minutes (by default) and will automatically update its prediction for the heating system for the next period, up to a maximum of 48 hours. The inputs are as follows An external temperature sensor, can be a real one or one created by an Internet service An internal temperature sensor, ideally from your home thermostat The target temperature sensor, is what your home thermostat is set to. A heating energy sensor in kWh (not strictly required but needed to plot historical usage and calibrate) The flow temperature setting of your heating, can be static or a sensor Your current energy rates, either from the Octopus Energy plugin or hand-typed into the configuration Some data about your home that you have to figure out for yourself and calibrate. The outputs are: Prediction of the internal house temperature going forward, including times when the heating will be active Your predicted energy usage and costs. The energy usage, if electric, can also be connected to Predbat to help you project your home battery usage. Future versions will also offer Predbat to run in master mode, controlling your home's heating in the same way as a smart thermostat (e.g. Nest) Installation guide Predheat is now part of Predbat, you will need to configure it using apps.yaml and then enable it by turning on switch.predbat_predheat_enable Weather install You will need a weather forecast service available in Home Assistant for Predbat to be able to forecast heating demand based on the weather forecast. You should be able to use any weather service, the Met Office integration is known to work with Predheat as is the Open Weather Map integration . If you are using OpenWeather then you will need to create an OpenWeather account and then register for a One Call API subscription plan . This does need a credit/debit card but won't cost anything. You get 1000 API calls a day for free, so edit your limit in the account to 1000 to avoid ever being charged. Then add in the Home Assistant service and connect up your API key to obtain hourly weather data. Apex Charts install Use HACS to install Apex Charts: https://github.com/RomRider/apexcharts-card There is a template of example_Predheat charts you can use. Create a new Apex chart for each chart in this template and copy the YAML code into the chart. Configuration guide You need to edit your Predbat apps.yaml to configure your system. Copy the following predheat.yaml template and append it to the end of Predbat's apps.yaml , after your existing inverter/battery configuration. Set the mode ( mode ) to 'gas' or 'pump' depending on if you have a gas boiler or heat pump. Set the external temperature sensor ( external_temperature ) either to a real sensor or create one from the open weather map by adding this sensor to your configuration.yaml file for HA: template: - sensor: - name: \"external_temperature\" unit_of_measurement: 'c' state_class: measurement state: > {{ state_attr('weather.openweathermap', 'temperature') }} Set internal_temperature to point to one or more internal temperature sensors, if you have a heating thermostat then ideally link it to this or to a sensor at least in a similar area of the house. The weather configuration points to the Open Weather Map sensor by default so should work as-is. Set the target_temperature to point to a sensor that indicates what your boiler thermostat is set to, or manually enter the temperature setting here. Set smart_thermostat to True if your thermostat starts the boiler ahead of time for the new target temperature or False for regular options. Set heating_energy To point to a sensor that indicates the energy consumed by your boiler/heat pump in kWh. If the sensor isn't accurate then use heating_energy_scaling to adjust it to the actual energy consumed. You can also comment this line out if you don't have a sensor, but no historical cost information will be produced. Now you need to make a list of all your radiators in the house, measure them and look up their BTU output at Delta 50 and their volume in Litres. The links below may be useful for various standard radiators: https://www.bestheating.com/milano-kent-straight-chrome-heated-towel-rail-various-sizes-91119 https://www.bestheating.com/milano-compact-type-11-single-panel-radiator-multi-sizes-available-74174 https://www.bestheating.com/milano-compact-type-22-double-panel-radiator-multi-sizes-available-74176 https://www.bestheating.com/milano-compact-type-21-double-panel-plus-radiator-multi-sizes-available-74175 Add up all the BTUs and divide by 3.41 to gain the heat output in Watts and set that in heat_output configuration option. Add up all the litres of water, add in some extra for the piping and an expansion vessel if present (e.g. 5-10 litres) and set heat_volume accordingly. Set the heat_max_power and heat_min_power to the minimum and maximum power output of your boiler/heat pump in watts. This should be specified as the maximum output power and not the maximum input energy. E.g. a heat pump with a COP of 4 might output 7kW but could only consume 1.7kW. Set hysteresis To the amount of hysteresis in degrees applied by your thermostat when turning it on, the default is 0.5 Set hysteresis_off To the amount of hysteresis in degrees applied by your thermostat when turning it off, the default is 0.1 Set heating_cop to the nominal COP of your system. For a gas boiler use 1.0 (as the efficiency will be based on flow temperature) or for a heat pump set it to the best value which is likely around 4.0 (it will be scaled down for cold weather). Set flow_temp To the target flow temperature of your system, either via a sensor or as a fixed value. E.g. gas boilers are often set to say 60 or 70 degrees while heat pumps are much lower e.g. 30 or 40. Set flow_difference_target to be the difference in flow temperature (in vs out) where your heating system will run at full power if it is above. e.g. for gas boilers this maybe something around 40 while on a heat pump, it could be much lower e.g. 10. Set volume_temp If you have a sensor on your radiators which can confirm the water temperature, this must not be near the heat pump/boiler but instead as close to the interior temperature sensor as possible. If you do not have a sensor then instead PredHeat will calculate the next temperature and store it in next_volume_temp for use in the next calculation cycle. For energy rates, they will come from the Predbat configuration, ensure you have your electric or gas rates set correctly. Note you can also change the tables for gas_efficiency , heat_pump_efficiency and delta_correction in the Predheat configuration but the defaults should be fine to get going. Set run_every to how often you want Predheat to update its heat energy prediction. By default this is every 5 minutes. Now comes the tricky part, we need to calculate the heat loss for your house: What will help here is historical temperature data, find a time period in the last few weeks when your heating was turned off (for a few hours beforehand) and the house is cooling down. Measure the number of degrees the house drops by in a given time period. Divide that figure (e.g. 1.5 degrees) by the time period e.g. (3 hours) and then again divide it by the average difference between the inside and outside temperature (e.g. 19 degrees inside, 9 degrees outside, so a temperature difference of 4 degrees) = 1.5 degrees / 3 hours / 10 degrees difference = 0.05. Set that figure to heat_loss_degrees . It may be best to compute this when it's cold out and if you have your heating turned off overnight. Note in future versions of Predheat I might make this calculation automatic. Next, we need to work out the number of watts of heat loss in the house, this can be done by looking at the energy consumed when the heating comes on. Pick a period of heating, ideally from the time the temperature starts increasing for a complete hour of increase, looking at the increase in temperature in degrees, add to that static heat loss which is heat_loss_degrees (internal temp - external temp) 1 hour to get the total degrees accounted for. Now divide that by the external temperature difference again / (internal_temp - external_temp) and multiply the final figure by the energy your system consumed in Watts during that period (can be found either from your sensor or just by looking at your energy bill for the same 1 hour period). The final figure should be the number of watts your house loses per 1 degree of external temperature difference and be set to heat_loss_watts Then you can set heat_gain_static to be the static heat output of other things in your house eg. computers and people. You can figure this out by looking at how many degrees of temperature difference your house can maintain without any heating and multiply up your heat loss watts figure by this. Weather Compensation If your heat source makes use of weather compensation then add the following to the configuration to map out your heat curve. The example has a flow temp of 45C at -3C outside and 25C at 15C outside: weather_compensation: -20: 45.0 -3: 45.0 15: 25.0 20: 25.0 Predheat will fill in the gaps between the points provided. Link Predheat to Predbat Add a load_forecast entry in apps.yaml to configure Predbat to use the Predheat load forecast : load_forecast: - predheat.heat_energy$external Exclude Heat Pump load If your load_today sensor in apps.yaml already contains your heat pump load then when Predbat forecasts your house load, the heat pump load will be double counted - once from historical house load data, and once from the Predheat forecast. To resolve this you need to use car_charging_energy to exclude heat pump load from the historical house load energy. e.g.: car_charging_energy: - 'sensor.ashp_energy_today'","title":"Predheat"},{"location":"predheat/#predheat","text":"Predheat attempts to model water-based central heating systems based on a boiler or a heat pump. Further details can be found in the Predheat YouTube video","title":"Predheat"},{"location":"predheat/#operation","text":"The app runs every 5 minutes (by default) and will automatically update its prediction for the heating system for the next period, up to a maximum of 48 hours. The inputs are as follows An external temperature sensor, can be a real one or one created by an Internet service An internal temperature sensor, ideally from your home thermostat The target temperature sensor, is what your home thermostat is set to. A heating energy sensor in kWh (not strictly required but needed to plot historical usage and calibrate) The flow temperature setting of your heating, can be static or a sensor Your current energy rates, either from the Octopus Energy plugin or hand-typed into the configuration Some data about your home that you have to figure out for yourself and calibrate. The outputs are: Prediction of the internal house temperature going forward, including times when the heating will be active Your predicted energy usage and costs. The energy usage, if electric, can also be connected to Predbat to help you project your home battery usage. Future versions will also offer Predbat to run in master mode, controlling your home's heating in the same way as a smart thermostat (e.g. Nest)","title":"Operation"},{"location":"predheat/#installation-guide","text":"Predheat is now part of Predbat, you will need to configure it using apps.yaml and then enable it by turning on switch.predbat_predheat_enable","title":"Installation guide"},{"location":"predheat/#weather-install","text":"You will need a weather forecast service available in Home Assistant for Predbat to be able to forecast heating demand based on the weather forecast. You should be able to use any weather service, the Met Office integration is known to work with Predheat as is the Open Weather Map integration . If you are using OpenWeather then you will need to create an OpenWeather account and then register for a One Call API subscription plan . This does need a credit/debit card but won't cost anything. You get 1000 API calls a day for free, so edit your limit in the account to 1000 to avoid ever being charged. Then add in the Home Assistant service and connect up your API key to obtain hourly weather data.","title":"Weather install"},{"location":"predheat/#apex-charts-install","text":"Use HACS to install Apex Charts: https://github.com/RomRider/apexcharts-card There is a template of example_Predheat charts you can use. Create a new Apex chart for each chart in this template and copy the YAML code into the chart.","title":"Apex Charts install"},{"location":"predheat/#configuration-guide","text":"You need to edit your Predbat apps.yaml to configure your system. Copy the following predheat.yaml template and append it to the end of Predbat's apps.yaml , after your existing inverter/battery configuration. Set the mode ( mode ) to 'gas' or 'pump' depending on if you have a gas boiler or heat pump. Set the external temperature sensor ( external_temperature ) either to a real sensor or create one from the open weather map by adding this sensor to your configuration.yaml file for HA: template: - sensor: - name: \"external_temperature\" unit_of_measurement: 'c' state_class: measurement state: > {{ state_attr('weather.openweathermap', 'temperature') }} Set internal_temperature to point to one or more internal temperature sensors, if you have a heating thermostat then ideally link it to this or to a sensor at least in a similar area of the house. The weather configuration points to the Open Weather Map sensor by default so should work as-is. Set the target_temperature to point to a sensor that indicates what your boiler thermostat is set to, or manually enter the temperature setting here. Set smart_thermostat to True if your thermostat starts the boiler ahead of time for the new target temperature or False for regular options. Set heating_energy To point to a sensor that indicates the energy consumed by your boiler/heat pump in kWh. If the sensor isn't accurate then use heating_energy_scaling to adjust it to the actual energy consumed. You can also comment this line out if you don't have a sensor, but no historical cost information will be produced. Now you need to make a list of all your radiators in the house, measure them and look up their BTU output at Delta 50 and their volume in Litres. The links below may be useful for various standard radiators: https://www.bestheating.com/milano-kent-straight-chrome-heated-towel-rail-various-sizes-91119 https://www.bestheating.com/milano-compact-type-11-single-panel-radiator-multi-sizes-available-74174 https://www.bestheating.com/milano-compact-type-22-double-panel-radiator-multi-sizes-available-74176 https://www.bestheating.com/milano-compact-type-21-double-panel-plus-radiator-multi-sizes-available-74175 Add up all the BTUs and divide by 3.41 to gain the heat output in Watts and set that in heat_output configuration option. Add up all the litres of water, add in some extra for the piping and an expansion vessel if present (e.g. 5-10 litres) and set heat_volume accordingly. Set the heat_max_power and heat_min_power to the minimum and maximum power output of your boiler/heat pump in watts. This should be specified as the maximum output power and not the maximum input energy. E.g. a heat pump with a COP of 4 might output 7kW but could only consume 1.7kW. Set hysteresis To the amount of hysteresis in degrees applied by your thermostat when turning it on, the default is 0.5 Set hysteresis_off To the amount of hysteresis in degrees applied by your thermostat when turning it off, the default is 0.1 Set heating_cop to the nominal COP of your system. For a gas boiler use 1.0 (as the efficiency will be based on flow temperature) or for a heat pump set it to the best value which is likely around 4.0 (it will be scaled down for cold weather). Set flow_temp To the target flow temperature of your system, either via a sensor or as a fixed value. E.g. gas boilers are often set to say 60 or 70 degrees while heat pumps are much lower e.g. 30 or 40. Set flow_difference_target to be the difference in flow temperature (in vs out) where your heating system will run at full power if it is above. e.g. for gas boilers this maybe something around 40 while on a heat pump, it could be much lower e.g. 10. Set volume_temp If you have a sensor on your radiators which can confirm the water temperature, this must not be near the heat pump/boiler but instead as close to the interior temperature sensor as possible. If you do not have a sensor then instead PredHeat will calculate the next temperature and store it in next_volume_temp for use in the next calculation cycle. For energy rates, they will come from the Predbat configuration, ensure you have your electric or gas rates set correctly. Note you can also change the tables for gas_efficiency , heat_pump_efficiency and delta_correction in the Predheat configuration but the defaults should be fine to get going. Set run_every to how often you want Predheat to update its heat energy prediction. By default this is every 5 minutes. Now comes the tricky part, we need to calculate the heat loss for your house: What will help here is historical temperature data, find a time period in the last few weeks when your heating was turned off (for a few hours beforehand) and the house is cooling down. Measure the number of degrees the house drops by in a given time period. Divide that figure (e.g. 1.5 degrees) by the time period e.g. (3 hours) and then again divide it by the average difference between the inside and outside temperature (e.g. 19 degrees inside, 9 degrees outside, so a temperature difference of 4 degrees) = 1.5 degrees / 3 hours / 10 degrees difference = 0.05. Set that figure to heat_loss_degrees . It may be best to compute this when it's cold out and if you have your heating turned off overnight. Note in future versions of Predheat I might make this calculation automatic. Next, we need to work out the number of watts of heat loss in the house, this can be done by looking at the energy consumed when the heating comes on. Pick a period of heating, ideally from the time the temperature starts increasing for a complete hour of increase, looking at the increase in temperature in degrees, add to that static heat loss which is heat_loss_degrees (internal temp - external temp) 1 hour to get the total degrees accounted for. Now divide that by the external temperature difference again / (internal_temp - external_temp) and multiply the final figure by the energy your system consumed in Watts during that period (can be found either from your sensor or just by looking at your energy bill for the same 1 hour period). The final figure should be the number of watts your house loses per 1 degree of external temperature difference and be set to heat_loss_watts Then you can set heat_gain_static to be the static heat output of other things in your house eg. computers and people. You can figure this out by looking at how many degrees of temperature difference your house can maintain without any heating and multiply up your heat loss watts figure by this.","title":"Configuration guide"},{"location":"predheat/#weather-compensation","text":"If your heat source makes use of weather compensation then add the following to the configuration to map out your heat curve. The example has a flow temp of 45C at -3C outside and 25C at 15C outside: weather_compensation: -20: 45.0 -3: 45.0 15: 25.0 20: 25.0 Predheat will fill in the gaps between the points provided.","title":"Weather Compensation"},{"location":"predheat/#link-predheat-to-predbat","text":"Add a load_forecast entry in apps.yaml to configure Predbat to use the Predheat load forecast : load_forecast: - predheat.heat_energy$external","title":"Link Predheat to Predbat"},{"location":"predheat/#exclude-heat-pump-load","text":"If your load_today sensor in apps.yaml already contains your heat pump load then when Predbat forecasts your house load, the heat pump load will be double counted - once from historical house load data, and once from the Predheat forecast. To resolve this you need to use car_charging_energy to exclude heat pump load from the historical house load energy. e.g.: car_charging_energy: - 'sensor.ashp_energy_today'","title":"Exclude Heat Pump load"},{"location":"rest_api/","text":"Predbat REST API Predbat supports a REST API operated via its Web Interface, this is normally intended for use when Predbat runs in a Docker or Standalone rather than in Home Assistant /api/state - Method GET entity_id -> The entity to get, if not specified all entities are returned Example: /api/state?entity_id=predbat.status { \"state\": \"Demand\", \"attributes\": {\"friendly_name\": \"Status\", \"detail\": \"\", \"icon\": \"mdi:information\", \"last_updated\": \"2025-02-23 20:49:57.855074\"} } /api/state - Method POST Sets the state of an entity, this is done by changing its value without calling the service API, this means Predbat will not notice the change Not normally recommended You must post in 'json' as follows { \"entity_id\": \"predbat.status\", \"state\": \"Hello\", \"attributes\": {\"friendly_name\" : \"Fire\"} } /api/service - Method POST This is the recommended way to change a Predbat value, it will either make the change via home assistant or directly via Predbat if not connected. You must post in 'json' with the service name and the service data, as per Home Assistant services: { \"service\": \"switch/turn_on\", \"data\": {\"entity_id\": \"switch.predbat_expert_mode\"} }","title":"Predbat REST API"},{"location":"rest_api/#predbat-rest-api","text":"Predbat supports a REST API operated via its Web Interface, this is normally intended for use when Predbat runs in a Docker or Standalone rather than in Home Assistant","title":"Predbat REST API"},{"location":"rest_api/#apistate-method-get","text":"entity_id -> The entity to get, if not specified all entities are returned Example: /api/state?entity_id=predbat.status { \"state\": \"Demand\", \"attributes\": {\"friendly_name\": \"Status\", \"detail\": \"\", \"icon\": \"mdi:information\", \"last_updated\": \"2025-02-23 20:49:57.855074\"} }","title":"/api/state - Method GET"},{"location":"rest_api/#apistate-method-post","text":"Sets the state of an entity, this is done by changing its value without calling the service API, this means Predbat will not notice the change Not normally recommended You must post in 'json' as follows { \"entity_id\": \"predbat.status\", \"state\": \"Hello\", \"attributes\": {\"friendly_name\" : \"Fire\"} }","title":"/api/state - Method POST"},{"location":"rest_api/#apiservice-method-post","text":"This is the recommended way to change a Predbat value, it will either make the change via home assistant or directly via Predbat if not connected. You must post in 'json' with the service name and the service data, as per Home Assistant services: { \"service\": \"switch/turn_on\", \"data\": {\"entity_id\": \"switch.predbat_expert_mode\"} }","title":"/api/service - Method POST"},{"location":"todo-list/","text":"To-do list See GitHub issues","title":"To-do list"},{"location":"todo-list/#to-do-list","text":"See GitHub issues","title":"To-do list"},{"location":"video-guides/","text":"Video Guides All the video guides are now available on my YouTube channel: Springfall2008 Basic installation Playlist of Predbat installation videos Setting Up Home Assistant Basics, File Editor, SSH, HACS, Octopus, eWelink Installing MQTT and GivTCP on Home Assistant Predbat installation - Predbat, Solcast, Dashboard, Charts and Plans - App Method Configuration of apps.yaml Configuration of Predbat inside Home Assistant Understanding historical data Understanding the charts How to understand Predbat plans AppDaemon log files Documentation overview Other configuration videos Playlist of other Predbat configuration videos Multiple cars How to Tune your system for better performance Issues with Solcast free accounts and Home Assistant How to Install Predbat with the new App Features Playlist of Predbat feature videos Intelligent Octopus car charging Saving sessions and power-ups How to update Predbat Predbat mode and read-only mode Creating a dashboard Saving and restoring settings Manual plan override Charging curve and low power charging Controlling my car based on Predbat Slot Manual plan overrides for force charge/discharge/idle GivTCP auto restart feature GivEnergy Inverter Pause, Manual Freeze Charge/Discharge Optimising for Carbon Footprint Calculating your cost savings Comparing Energy Tariffs Introduction to Predheat Energy Tariffs Playlist of Tariff configuration videos Intelligent Octopus import + Agile export Intelligent Octopus import + Fixed export Octopus Agile import + Agile export Octopus Flux","title":"Video Guides"},{"location":"video-guides/#video-guides","text":"All the video guides are now available on my YouTube channel: Springfall2008","title":"Video Guides"},{"location":"video-guides/#basic-installation","text":"Playlist of Predbat installation videos Setting Up Home Assistant Basics, File Editor, SSH, HACS, Octopus, eWelink Installing MQTT and GivTCP on Home Assistant Predbat installation - Predbat, Solcast, Dashboard, Charts and Plans - App Method Configuration of apps.yaml Configuration of Predbat inside Home Assistant Understanding historical data Understanding the charts How to understand Predbat plans AppDaemon log files Documentation overview","title":"Basic installation"},{"location":"video-guides/#other-configuration-videos","text":"Playlist of other Predbat configuration videos Multiple cars How to Tune your system for better performance Issues with Solcast free accounts and Home Assistant How to Install Predbat with the new App","title":"Other configuration videos"},{"location":"video-guides/#features","text":"Playlist of Predbat feature videos Intelligent Octopus car charging Saving sessions and power-ups How to update Predbat Predbat mode and read-only mode Creating a dashboard Saving and restoring settings Manual plan override Charging curve and low power charging Controlling my car based on Predbat Slot Manual plan overrides for force charge/discharge/idle GivTCP auto restart feature GivEnergy Inverter Pause, Manual Freeze Charge/Discharge Optimising for Carbon Footprint Calculating your cost savings Comparing Energy Tariffs Introduction to Predheat","title":"Features"},{"location":"video-guides/#energy-tariffs","text":"Playlist of Tariff configuration videos Intelligent Octopus import + Agile export Intelligent Octopus import + Fixed export Octopus Agile import + Agile export Octopus Flux","title":"Energy Tariffs"},{"location":"web-interface/","text":"Web Interface The Predbat Web Interface provides an easy to use way to see and change different aspects of your Predbat system including view the current plan, adjust the configuration, view the charts, check your apps.yaml and view the logfiles. Accessing the Web Interface If you are running the Predbat app then the Predbat Web Interface can be accessed by clicking 'Open Web UI' on the app screen (arrowed): You can also turn on the 'Show in sidebar' option (circled) to have direct access to the web interface from the Home Assistant side bar. Another option is to include a link on your dashboard using an entities card: - type: entities entities: - type: weblink name: Predbat web interface url: /hassio/ingress/6adb4f0d_predbat icon: mdi:bat If you are not using the Predbat app then you may be able to access the Web Interface directly on port 5052 (e.g. with a Docker Container or native on your Linux/MAC). The port number can be changed by setting web_port in apps.yaml . NOTE: The Predbat web interface will not work with the AppDaemon or the Predbat-appdaemon installation methods. Web Interface Views A number of different views of Predbat are available and you can change your view using the top menu bar. Dash View The initial view is the Dash view which gives a summary of Predbat's status and mode, some easy-to-access debug options (see below), a text summary of Predbat's plan, and then all the output entities that Predbat creates. The Debug panel provides easy access to a number of files that are useful in diagnosing a problem and are usually required if you raise a Predbat GitHub issue : Download apps.yaml - provides a link to download your apps.yaml file . This is useful to identify issues with your Predbat configuration Create predbat_debug.yaml - turns Predbat's debug mode on and creates a Predbat debug file which contains your entire Predbat Home Assistant configuration; all the input settings for Predbat and all Predbat's output data including the current HTML plan, the best_* entities, etc. This debug file enables your setup to be recreated to identify any configuration issues it may have or Predbat bugs to be re-created. Confidential information such as your Solcast API or GECloud API are redacted in the debug file. Download predbat.log - provides a link to download the current Predbat logfile which contains progress and any error messages that occur whilst Predbat is running Download predbat_plan.html - provides a link to download the current Predbat HTML plan Note that before you can attach a downloaded apps.yaml or predbat_debug.yaml file to a GitHub issue you must rename the file extension, e.g. to '.txt', so for example apps.txt and predbat_debug.txt . This is because GitHub does not accept .yaml file attachments. Underneath the Debug panel is the Power Flow diagram. The Power Flow gives an 'instantaneous Power' snapshot of your PV generation, Battery charge/discharge, Grid import/export and House consumption using the power_xx entities defined in apps.yaml . Note these are a view of what is happening right now on your inverter and are not the same as the 'Energy Today' sensors in apps.yaml (load_today, import_today, export_today and pv_today) which give accumulated energy so far today and for the days_previous days history. Beneath that is the plan textual description panel which gives a brief summary of current battery level, forthcoming import rates, solar generation, planned charging, discharging and export activity. At the bottom of the view is the Predbat Entities panel which details all the other Predbat output entities, their current state and attributes. Any entity name can be clicked to swap to the Entities view for that entity. Plan View This view provides an easy way to see what Predbat is planning for your battery/inverter. It displays the current Predbat plan in (by default) 30 minute segments showing import and export rates, Predbat's planned state for the battery (charging, discharging, etc), predicted solar generation, predicted house load, car charging, cost, etc. Buttons enable you to easily swap between 'Plan' which shows the current Predbat Plan from now going forwards, a 'History' view of the plan from Midnight yesterday up to now, and 'Yesterday without Predbat' which is a simulated plan without any Predbat battery optimisation and an assumed number of charging periods . You can easily change Predbat's planned activity for a slot by clicking on the slot time, then selecting Manual Demand, Manual Charge, Manual Export, Manual Freeze Charge or Manual Freeze Export to set the activity. If you have previously changed Predbat's planned activity for a slot, choose Clear to return Predbat to its planned activity. Further details of the columns, what they show, the colour coding, etc can be found in the Predbat plan card documentation . You can also create a Predbat Plan card to show Predbat's plan on your own custom dashboard. Entities View This view enables you to look at the history of any predbat output entity or (input) configuration setting. Select the entity required to be viewed, the attributes to be charted (defaults to entity state) and the time period of history to view the entity over (but note you may need to increase HA's purge_keep_days first). You can select multiple entities and their attributes and Predbat will then display the current entity values, a chart of the selected attribute history, and then a list of prior historical values. The example below shows predbat import and export rates charted for the last 7 days: Charts View The Charts view provides an easy way of viewing a number of pre-created Predbat charts: Battery - Shows the historic Battery SoC for today and the predicted SoC for the plan duration under the Base/Base10/Best and Best10 scenarios (see explanation of these terms . The chart also shows where charging is planned under the Base and Best scenarios and forced Export under the Best scenario Power - Shows predicted Power for the plan duration. This includes battery charge and discharge, solar generation (PV), house load, iBoost load, car charging load, and grid import/export Cost - Shows the historic import, export and net total cost incurred for today and the predicted cost for the plan duration under the Base/Base10/Best and Best10 scenarios Rates - Shows historic and future import and export rates along with historic hourly and today pence per kWh so you can see where you have earned or spent the most on electricity during today InDay - Shows Predbat's predicted house load for today, the actual house load that has occurred so far today, and then Predbat's adjusted house load prediction based on the variance of today's actual load to predicted load PV - Shows today's predicted solar generation under the PV, PV10 and PV90 scenarios alongside today's actual solar generation PV7 - Similar to the PV chart but shows actual solar generation and forecast for the last 7 days including today Example PV chart: Compare View The Compare View provides access to Predbat's Compare Energy Tariff feature which enables you compare what Predbat predicts it would cost you (or you'd gain from export) on different energy tariffs with your predicted load and solar generation. Log View Predbat writes detailed logging, status and progress activity information to a logfile as it runs and so the Log view provides an easy way to see and download the Predbat logfile. By default the Log view opens in the Warnings tab which shows a filtered list of Warnings and Errors in the Predbat logfile. The Errors tab shows a filtered list of logfile Errors, and the All tab shows all entries in the Predbat logfile. Normal log messages are coloured Green, Warnings are Orange, and Errors in Red. The Logfile view shows newest entries at the top and auto-refreshes so as Predbat is executing the most recent logs will appear at the top and the log will scroll downwards. The Download tab gives the ability to download the logfile. Further details about the Predbat logfile and its location is described in the output data document . Config View The Config view provides a way to see and change all of Predbat's configuration entities in Home Assistant. For each entity is displayed the name, entity type, the current entity value and Predbat's default value for that entity. Any entities that are coloured pale red simply denote entities where you have changed the value from Predbat's default value - it does not indicate that the entity value is in error, its just that its different from the default value. Any entity name can be clicked to swap to the Entities view for that entity. You can also create a custom dashboard to see and update Predbat's control entities ; and full explanation of Predbat's control entities and what they do can be found in the customisation documentation . Apps View The Apps view allows you to look at your apps.yaml configuration and to modify the values within the web browser without having to edit the YAML file directly. Click the edit button to change a value, when all the edits are complete hit save to save the apps.yaml and Predbat will automatically be restarted with the new configuration. Predbat validates your apps.yaml every time it runs and if there are any configuration issues it displays a count of those errors and highlights the items in error in red: Further details of the apps.yaml error can be found in the Predbat Log . Components View The Components View enables you see the current status of the different Predbat Components and the key configuration settings being used by those components. You can restart individual Predbat components if required. Editor View The editor view allows you to edit apps.yaml as text directly within the web interface. If you make a syntax error then the error will be highlighted and save will be disabled pending a fix. Browse View The Browse view gives a simple file system browser to enable you to view any of the configuration, output and code files in the directory that Predbat is installed in. You can navigate around subfolders and view files, but not make any changes using the Browse view. Internals View The Internals view gives a view of Predbat's internal operations. It gives the hierarchy of threads, and their status; and the Predbat code object hierarchy. These are intended for debugging and developer activities, in normal use you can ignore this view! Docs View Provides a quick link to the Predbat documentation . Toggle Dark Mode As it says, toggles the Predbat web interface between light and dark mode.","title":"Web Interface"},{"location":"web-interface/#web-interface","text":"The Predbat Web Interface provides an easy to use way to see and change different aspects of your Predbat system including view the current plan, adjust the configuration, view the charts, check your apps.yaml and view the logfiles.","title":"Web Interface"},{"location":"web-interface/#accessing-the-web-interface","text":"If you are running the Predbat app then the Predbat Web Interface can be accessed by clicking 'Open Web UI' on the app screen (arrowed): You can also turn on the 'Show in sidebar' option (circled) to have direct access to the web interface from the Home Assistant side bar. Another option is to include a link on your dashboard using an entities card: - type: entities entities: - type: weblink name: Predbat web interface url: /hassio/ingress/6adb4f0d_predbat icon: mdi:bat If you are not using the Predbat app then you may be able to access the Web Interface directly on port 5052 (e.g. with a Docker Container or native on your Linux/MAC). The port number can be changed by setting web_port in apps.yaml . NOTE: The Predbat web interface will not work with the AppDaemon or the Predbat-appdaemon installation methods.","title":"Accessing the Web Interface"},{"location":"web-interface/#web-interface-views","text":"A number of different views of Predbat are available and you can change your view using the top menu bar.","title":"Web Interface Views"},{"location":"web-interface/#dash-view","text":"The initial view is the Dash view which gives a summary of Predbat's status and mode, some easy-to-access debug options (see below), a text summary of Predbat's plan, and then all the output entities that Predbat creates. The Debug panel provides easy access to a number of files that are useful in diagnosing a problem and are usually required if you raise a Predbat GitHub issue : Download apps.yaml - provides a link to download your apps.yaml file . This is useful to identify issues with your Predbat configuration Create predbat_debug.yaml - turns Predbat's debug mode on and creates a Predbat debug file which contains your entire Predbat Home Assistant configuration; all the input settings for Predbat and all Predbat's output data including the current HTML plan, the best_* entities, etc. This debug file enables your setup to be recreated to identify any configuration issues it may have or Predbat bugs to be re-created. Confidential information such as your Solcast API or GECloud API are redacted in the debug file. Download predbat.log - provides a link to download the current Predbat logfile which contains progress and any error messages that occur whilst Predbat is running Download predbat_plan.html - provides a link to download the current Predbat HTML plan Note that before you can attach a downloaded apps.yaml or predbat_debug.yaml file to a GitHub issue you must rename the file extension, e.g. to '.txt', so for example apps.txt and predbat_debug.txt . This is because GitHub does not accept .yaml file attachments. Underneath the Debug panel is the Power Flow diagram. The Power Flow gives an 'instantaneous Power' snapshot of your PV generation, Battery charge/discharge, Grid import/export and House consumption using the power_xx entities defined in apps.yaml . Note these are a view of what is happening right now on your inverter and are not the same as the 'Energy Today' sensors in apps.yaml (load_today, import_today, export_today and pv_today) which give accumulated energy so far today and for the days_previous days history. Beneath that is the plan textual description panel which gives a brief summary of current battery level, forthcoming import rates, solar generation, planned charging, discharging and export activity. At the bottom of the view is the Predbat Entities panel which details all the other Predbat output entities, their current state and attributes. Any entity name can be clicked to swap to the Entities view for that entity.","title":"Dash View"},{"location":"web-interface/#plan-view","text":"This view provides an easy way to see what Predbat is planning for your battery/inverter. It displays the current Predbat plan in (by default) 30 minute segments showing import and export rates, Predbat's planned state for the battery (charging, discharging, etc), predicted solar generation, predicted house load, car charging, cost, etc. Buttons enable you to easily swap between 'Plan' which shows the current Predbat Plan from now going forwards, a 'History' view of the plan from Midnight yesterday up to now, and 'Yesterday without Predbat' which is a simulated plan without any Predbat battery optimisation and an assumed number of charging periods . You can easily change Predbat's planned activity for a slot by clicking on the slot time, then selecting Manual Demand, Manual Charge, Manual Export, Manual Freeze Charge or Manual Freeze Export to set the activity. If you have previously changed Predbat's planned activity for a slot, choose Clear to return Predbat to its planned activity. Further details of the columns, what they show, the colour coding, etc can be found in the Predbat plan card documentation . You can also create a Predbat Plan card to show Predbat's plan on your own custom dashboard.","title":"Plan View"},{"location":"web-interface/#entities-view","text":"This view enables you to look at the history of any predbat output entity or (input) configuration setting. Select the entity required to be viewed, the attributes to be charted (defaults to entity state) and the time period of history to view the entity over (but note you may need to increase HA's purge_keep_days first). You can select multiple entities and their attributes and Predbat will then display the current entity values, a chart of the selected attribute history, and then a list of prior historical values. The example below shows predbat import and export rates charted for the last 7 days:","title":"Entities View"},{"location":"web-interface/#charts-view","text":"The Charts view provides an easy way of viewing a number of pre-created Predbat charts: Battery - Shows the historic Battery SoC for today and the predicted SoC for the plan duration under the Base/Base10/Best and Best10 scenarios (see explanation of these terms . The chart also shows where charging is planned under the Base and Best scenarios and forced Export under the Best scenario Power - Shows predicted Power for the plan duration. This includes battery charge and discharge, solar generation (PV), house load, iBoost load, car charging load, and grid import/export Cost - Shows the historic import, export and net total cost incurred for today and the predicted cost for the plan duration under the Base/Base10/Best and Best10 scenarios Rates - Shows historic and future import and export rates along with historic hourly and today pence per kWh so you can see where you have earned or spent the most on electricity during today InDay - Shows Predbat's predicted house load for today, the actual house load that has occurred so far today, and then Predbat's adjusted house load prediction based on the variance of today's actual load to predicted load PV - Shows today's predicted solar generation under the PV, PV10 and PV90 scenarios alongside today's actual solar generation PV7 - Similar to the PV chart but shows actual solar generation and forecast for the last 7 days including today Example PV chart:","title":"Charts View"},{"location":"web-interface/#compare-view","text":"The Compare View provides access to Predbat's Compare Energy Tariff feature which enables you compare what Predbat predicts it would cost you (or you'd gain from export) on different energy tariffs with your predicted load and solar generation.","title":"Compare View"},{"location":"web-interface/#log-view","text":"Predbat writes detailed logging, status and progress activity information to a logfile as it runs and so the Log view provides an easy way to see and download the Predbat logfile. By default the Log view opens in the Warnings tab which shows a filtered list of Warnings and Errors in the Predbat logfile. The Errors tab shows a filtered list of logfile Errors, and the All tab shows all entries in the Predbat logfile. Normal log messages are coloured Green, Warnings are Orange, and Errors in Red. The Logfile view shows newest entries at the top and auto-refreshes so as Predbat is executing the most recent logs will appear at the top and the log will scroll downwards. The Download tab gives the ability to download the logfile. Further details about the Predbat logfile and its location is described in the output data document .","title":"Log View"},{"location":"web-interface/#config-view","text":"The Config view provides a way to see and change all of Predbat's configuration entities in Home Assistant. For each entity is displayed the name, entity type, the current entity value and Predbat's default value for that entity. Any entities that are coloured pale red simply denote entities where you have changed the value from Predbat's default value - it does not indicate that the entity value is in error, its just that its different from the default value. Any entity name can be clicked to swap to the Entities view for that entity. You can also create a custom dashboard to see and update Predbat's control entities ; and full explanation of Predbat's control entities and what they do can be found in the customisation documentation .","title":"Config View"},{"location":"web-interface/#apps-view","text":"The Apps view allows you to look at your apps.yaml configuration and to modify the values within the web browser without having to edit the YAML file directly. Click the edit button to change a value, when all the edits are complete hit save to save the apps.yaml and Predbat will automatically be restarted with the new configuration. Predbat validates your apps.yaml every time it runs and if there are any configuration issues it displays a count of those errors and highlights the items in error in red: Further details of the apps.yaml error can be found in the Predbat Log .","title":"Apps View"},{"location":"web-interface/#components-view","text":"The Components View enables you see the current status of the different Predbat Components and the key configuration settings being used by those components. You can restart individual Predbat components if required.","title":"Components View"},{"location":"web-interface/#editor-view","text":"The editor view allows you to edit apps.yaml as text directly within the web interface. If you make a syntax error then the error will be highlighted and save will be disabled pending a fix.","title":"Editor View"},{"location":"web-interface/#browse-view","text":"The Browse view gives a simple file system browser to enable you to view any of the configuration, output and code files in the directory that Predbat is installed in. You can navigate around subfolders and view files, but not make any changes using the Browse view.","title":"Browse View"},{"location":"web-interface/#internals-view","text":"The Internals view gives a view of Predbat's internal operations. It gives the hierarchy of threads, and their status; and the Predbat code object hierarchy. These are intended for debugging and developer activities, in normal use you can ignore this view!","title":"Internals View"},{"location":"web-interface/#docs-view","text":"Provides a quick link to the Predbat documentation .","title":"Docs View"},{"location":"web-interface/#toggle-dark-mode","text":"As it says, toggles the Predbat web interface between light and dark mode.","title":"Toggle Dark Mode"},{"location":"what-does-predbat-do/","text":"What does Predbat do? Predbat is a home battery automation program. It runs every 5 minutes and, by default, forecasts 48 hours ahead (configurable via forecast_hours), with the plan typically covering at least 24 hours after the first charge slot (forecast_plan_hours). Predbat will automatically decide when to charge and discharge your battery to achieve the best (lowest) cost spend within the parameters you have set. It uses the solar production forecast from Solcast combined with your historical energy usage to make this prediction. The output is a prediction of the battery levels, solar generation, house load, charging activity, discharging activity, costs and import and export amounts based on (by default) 30-minute slots. Costs are based on energy pricing data, either manually configured (e.g. 7p from 11pm-4pm and 35p otherwise) or by using the Octopus Energy integration Both import and export rates are supported. Intelligent Octopus is also supported and takes into account allocated charging slots. The solar forecast used is the central scenario from Solcast/Forecast.solar (50%) with a configurable weighting towards the more pessimistic (10%) scenario. Predbat automatically programs your inverter with the appropriate charging and discharging controls. Both Hybrid inverters and AC-coupled inverters are supported by Predbat. Automatic planning of export slots is also supported, when enabled Predbat can start a forced discharge of the battery if the export rates are high and you have spare capacity. Historical load data is used to predict your consumption, optionally car charging load can be filtered out of this data. Predbat can be configured to manage the charging of your EV or to use a Solar Diverter, and take into account these loads on the house during these periods. Multiple inverter support is included but depends on all inverters running in lockstep. Terminology Basic terminology SoC - State of Charge - the % or kWh level of charge of your battery Target SoC - The target level that the battery is being charged to, e.g. we target 100% SoC means the battery is being charged to full Charge Limit - Another word for Target SoC Load - The energy your home is using to power your equipment e.g. oven, lights or electric car charging Grid - Your electric supply outside the house Import - Electricity drawn from the grid to be used in the home or to charge the battery Export - Electricity from your home from the battery or solar which is sent to the grid Demand - Demand Mode is when the battery covers the house load and charges from solar, to avoid importing or exporting (some systems call this ECO Mode). Charging - When your battery is charging, in Predbat this refers to force charge (from the grid). Discharge - The opposite of charge, when the battery is discharging. Exporting - When your battery is force discharging to create an export, in Predbat this refers to force export. Export Limit - When your battery is being force exported the export limit is the % battery level where the discharge will stop if reached. PV - Solar power that is generated in your home. Can also refer to a prediction of the solar for the day, by default is the 50% scenario (most likely generation). Inverter - The box that converts DC energy from solar or your battery into AC power for your home and the grid. The inverter also converts AC power from the grid into DC to charge a battery. Hybrid inverter - An inverter that can charge a battery from solar directly using DC power as well as charging it from AC power from the grid AC Coupled - A battery that comes with its own inverter and is always charged or discharged with AC (using an internal inverter) Micro Inverters - Small inverters that are fitted in line with the DC solar panels and produce AC power on a per-panel basis. Typically used with an AC-coupled battery. Slot - A period of time where Predbat acts e.g. charging. In Predbat everything is a multiple of 5 minutes Charge slots are always in multiples of the plan interval duration , default is 30 minutes, and align to the interval time boundaries to match the way energy rates are allocated Discharge slots can be any multiple of 5 minutes and always finish on a plan interval (default 30-minute) boundary. Low-rate slot - A time period where the import rate is below a threshold, making it suitable for charging. By default Predbat automatically calculates this threshold based on future import rates. You can adjust the threshold using input_number.predbat_rate_low_threshold ( expert mode ) - see Battery margins and metrics options . High-rate slot - A time period where the export rate is above a threshold, making it suitable for forced export. By default Predbat automatically calculates this threshold based on future export rates. You can adjust the threshold using input_number.predbat_rate_high_threshold ( expert mode ) - see Battery margins and metrics options . Loss - Refers to energy lost in your system due to heat or other factors. PV10 - A prediction of the 10% scenario for solar, this is like a worst case, occurs 1 in 10 days PV90 - A prediction of the 90% scenario for solar, this is like a best case, occurs 1 in 10 days Base - Usually refers to the expected outcome if Predbat takes no further action, meaning just what is currently configured on your inverter. Best - The best plan that Predbat could come up with, as in what it will do (assuming Read-only is off) Actual - Used to refer to what has already happened in the past. Base10 - The base scenario but with the 10% outcome for Solar and Load (worst case) Charge Limit Base - This is the target charge % in the Base plan (what is currently set on your inverter) Best10 - The best plan but with the 10% outcome for Solar and Load (worst case) Charge Limit Best - This is the target charge % in the Best plan (what is currently set on your inverter) Export Limit Best - This is the target to force export to in % in the Best plan. Best SoC Keep - The amount of battery you want to keep in the plan that Predbat has made Predbat modes When you first install Predbat it will be in 'Monitor' mode. You can configure Predbat's mode of operation using the drop-down menu in select.predbat_mode . You will find a full description of Predbat Modes in the Customisation Guide. Once you are ready for Predbat to take control move this setting to one of the active control modes. Predbat status The current Predbat status is reported in the Home Assistant entity predbat.status : Demand - This is the default, the load will be covered by solar and/or battery. Excess solar will charge the battery or be exported if the battery is full. This is described as 'Eco' Mode for GivEnergy inverters but other inverters use different terminology. Demand (Holiday) - Predbat is in Demand mode, and additionally Holiday Mode is active. Charging - The battery charges from the grid and the grid also covers any load. Solar power will also be used to charge the battery. Freeze charging - The battery is charging but the current battery level (SoC) is frozen (held). Think of it as a charge to the current battery level. The grid or solar covers any house load. If there is a shortfall of Solar power to meet house load, the excess house load is met from grid import, but if there is excess Solar power above the house load, the excess solar will be used to charge the battery, Hold charging - A type of charge where the target SoC % is the same or lower than the current SoC %. This is similar to charge freeze, but it is selected as a result of planning, and cannot be manually selected. No Charge - A charge where the target SoC % is lower than the current battery SoC level so there will be no charging unless the usage is unexpectedly high. Exporting - The battery is being force-discharged. The house load will be covered by the battery and any excess is exported to the grid. Any solar generated will be exported. Freeze exporting - The battery is in demand mode, but with charging disabled. The battery or solar covers the house load. As charging is disabled, if there is excess solar generated, the current SoC level will be held and the excess solar will be exported. If there is a shortfall of generated solar power to meet the house load, the battery will discharge to meet the extra load. Demand [Freeze exporting] - Predbat's Demand mode has been overridden and Predbat is set to Freeze exporting mode. See Freeze Export during Demand . Hold exporting - The plan was to force export but the minimum battery level was reached and thus the battery is kept in Demand mode. If the battery level again gets above the threshold it will be changed back to Export mode. Hold for car and Demand, Hold for car - A car is charging (either Predbat-led or Octopus-led), the battery is in Demand mode, but is set to prevent discharging into the car (requires switch.predbat_car_charging_from_battery to be set to On). Hold for iBoost and Demand, Hold for iBoost - iBoost is active, the battery is in Demand mode, but is set to prevent discharging into the iBoost (requires switch.predbat_iboost_prevent_discharge to be set to On). Read-Only - Predbat is in read-only mode , the plan will be produced and updated but no instructions will be sent to the inverter to charge or discharge. Read-Only (Axle) - Predbat is in read-only mode for the duration of an Axle VPP export event , and will automatically return to a normal execution mode at the end of the Axle event. [Alert] will be appended to the Predbat status if an Alert is active . Calibration - The inverter is calibrating the batteries. On GivEnergy systems the battery state of charge (SoC) level has to be calibrated by performing a full battery discharge and then a full charge so that the voltage levels associated with empty and full SoC can be determined. Predbat will pause executing the plan until the calibration automatically finishes - see Calibration FAQ . Error - If there is a configuration error or other problem, you should check the Predbat log file for more details.","title":"What does Predbat do?"},{"location":"what-does-predbat-do/#what-does-predbat-do","text":"Predbat is a home battery automation program. It runs every 5 minutes and, by default, forecasts 48 hours ahead (configurable via forecast_hours), with the plan typically covering at least 24 hours after the first charge slot (forecast_plan_hours). Predbat will automatically decide when to charge and discharge your battery to achieve the best (lowest) cost spend within the parameters you have set. It uses the solar production forecast from Solcast combined with your historical energy usage to make this prediction. The output is a prediction of the battery levels, solar generation, house load, charging activity, discharging activity, costs and import and export amounts based on (by default) 30-minute slots. Costs are based on energy pricing data, either manually configured (e.g. 7p from 11pm-4pm and 35p otherwise) or by using the Octopus Energy integration Both import and export rates are supported. Intelligent Octopus is also supported and takes into account allocated charging slots. The solar forecast used is the central scenario from Solcast/Forecast.solar (50%) with a configurable weighting towards the more pessimistic (10%) scenario. Predbat automatically programs your inverter with the appropriate charging and discharging controls. Both Hybrid inverters and AC-coupled inverters are supported by Predbat. Automatic planning of export slots is also supported, when enabled Predbat can start a forced discharge of the battery if the export rates are high and you have spare capacity. Historical load data is used to predict your consumption, optionally car charging load can be filtered out of this data. Predbat can be configured to manage the charging of your EV or to use a Solar Diverter, and take into account these loads on the house during these periods. Multiple inverter support is included but depends on all inverters running in lockstep.","title":"What does Predbat do?"},{"location":"what-does-predbat-do/#terminology","text":"","title":"Terminology"},{"location":"what-does-predbat-do/#basic-terminology","text":"SoC - State of Charge - the % or kWh level of charge of your battery Target SoC - The target level that the battery is being charged to, e.g. we target 100% SoC means the battery is being charged to full Charge Limit - Another word for Target SoC Load - The energy your home is using to power your equipment e.g. oven, lights or electric car charging Grid - Your electric supply outside the house Import - Electricity drawn from the grid to be used in the home or to charge the battery Export - Electricity from your home from the battery or solar which is sent to the grid Demand - Demand Mode is when the battery covers the house load and charges from solar, to avoid importing or exporting (some systems call this ECO Mode). Charging - When your battery is charging, in Predbat this refers to force charge (from the grid). Discharge - The opposite of charge, when the battery is discharging. Exporting - When your battery is force discharging to create an export, in Predbat this refers to force export. Export Limit - When your battery is being force exported the export limit is the % battery level where the discharge will stop if reached. PV - Solar power that is generated in your home. Can also refer to a prediction of the solar for the day, by default is the 50% scenario (most likely generation). Inverter - The box that converts DC energy from solar or your battery into AC power for your home and the grid. The inverter also converts AC power from the grid into DC to charge a battery. Hybrid inverter - An inverter that can charge a battery from solar directly using DC power as well as charging it from AC power from the grid AC Coupled - A battery that comes with its own inverter and is always charged or discharged with AC (using an internal inverter) Micro Inverters - Small inverters that are fitted in line with the DC solar panels and produce AC power on a per-panel basis. Typically used with an AC-coupled battery. Slot - A period of time where Predbat acts e.g. charging. In Predbat everything is a multiple of 5 minutes Charge slots are always in multiples of the plan interval duration , default is 30 minutes, and align to the interval time boundaries to match the way energy rates are allocated Discharge slots can be any multiple of 5 minutes and always finish on a plan interval (default 30-minute) boundary. Low-rate slot - A time period where the import rate is below a threshold, making it suitable for charging. By default Predbat automatically calculates this threshold based on future import rates. You can adjust the threshold using input_number.predbat_rate_low_threshold ( expert mode ) - see Battery margins and metrics options . High-rate slot - A time period where the export rate is above a threshold, making it suitable for forced export. By default Predbat automatically calculates this threshold based on future export rates. You can adjust the threshold using input_number.predbat_rate_high_threshold ( expert mode ) - see Battery margins and metrics options . Loss - Refers to energy lost in your system due to heat or other factors. PV10 - A prediction of the 10% scenario for solar, this is like a worst case, occurs 1 in 10 days PV90 - A prediction of the 90% scenario for solar, this is like a best case, occurs 1 in 10 days Base - Usually refers to the expected outcome if Predbat takes no further action, meaning just what is currently configured on your inverter. Best - The best plan that Predbat could come up with, as in what it will do (assuming Read-only is off) Actual - Used to refer to what has already happened in the past. Base10 - The base scenario but with the 10% outcome for Solar and Load (worst case) Charge Limit Base - This is the target charge % in the Base plan (what is currently set on your inverter) Best10 - The best plan but with the 10% outcome for Solar and Load (worst case) Charge Limit Best - This is the target charge % in the Best plan (what is currently set on your inverter) Export Limit Best - This is the target to force export to in % in the Best plan. Best SoC Keep - The amount of battery you want to keep in the plan that Predbat has made","title":"Basic terminology"},{"location":"what-does-predbat-do/#predbat-modes","text":"When you first install Predbat it will be in 'Monitor' mode. You can configure Predbat's mode of operation using the drop-down menu in select.predbat_mode . You will find a full description of Predbat Modes in the Customisation Guide. Once you are ready for Predbat to take control move this setting to one of the active control modes.","title":"Predbat modes"},{"location":"what-does-predbat-do/#predbat-status","text":"The current Predbat status is reported in the Home Assistant entity predbat.status : Demand - This is the default, the load will be covered by solar and/or battery. Excess solar will charge the battery or be exported if the battery is full. This is described as 'Eco' Mode for GivEnergy inverters but other inverters use different terminology. Demand (Holiday) - Predbat is in Demand mode, and additionally Holiday Mode is active. Charging - The battery charges from the grid and the grid also covers any load. Solar power will also be used to charge the battery. Freeze charging - The battery is charging but the current battery level (SoC) is frozen (held). Think of it as a charge to the current battery level. The grid or solar covers any house load. If there is a shortfall of Solar power to meet house load, the excess house load is met from grid import, but if there is excess Solar power above the house load, the excess solar will be used to charge the battery, Hold charging - A type of charge where the target SoC % is the same or lower than the current SoC %. This is similar to charge freeze, but it is selected as a result of planning, and cannot be manually selected. No Charge - A charge where the target SoC % is lower than the current battery SoC level so there will be no charging unless the usage is unexpectedly high. Exporting - The battery is being force-discharged. The house load will be covered by the battery and any excess is exported to the grid. Any solar generated will be exported. Freeze exporting - The battery is in demand mode, but with charging disabled. The battery or solar covers the house load. As charging is disabled, if there is excess solar generated, the current SoC level will be held and the excess solar will be exported. If there is a shortfall of generated solar power to meet the house load, the battery will discharge to meet the extra load. Demand [Freeze exporting] - Predbat's Demand mode has been overridden and Predbat is set to Freeze exporting mode. See Freeze Export during Demand . Hold exporting - The plan was to force export but the minimum battery level was reached and thus the battery is kept in Demand mode. If the battery level again gets above the threshold it will be changed back to Export mode. Hold for car and Demand, Hold for car - A car is charging (either Predbat-led or Octopus-led), the battery is in Demand mode, but is set to prevent discharging into the car (requires switch.predbat_car_charging_from_battery to be set to On). Hold for iBoost and Demand, Hold for iBoost - iBoost is active, the battery is in Demand mode, but is set to prevent discharging into the iBoost (requires switch.predbat_iboost_prevent_discharge to be set to On). Read-Only - Predbat is in read-only mode , the plan will be produced and updated but no instructions will be sent to the inverter to charge or discharge. Read-Only (Axle) - Predbat is in read-only mode for the duration of an Axle VPP export event , and will automatically return to a normal execution mode at the end of the Axle event. [Alert] will be appended to the Predbat status if an Alert is active . Calibration - The inverter is calibrating the batteries. On GivEnergy systems the battery state of charge (SoC) level has to be calibrated by performing a full battery discharge and then a full charge so that the voltage levels associated with empty and full SoC can be determined. Predbat will pause executing the plan until the calibration automatically finishes - see Calibration FAQ . Error - If there is a configuration error or other problem, you should check the Predbat log file for more details.","title":"Predbat status"}]}